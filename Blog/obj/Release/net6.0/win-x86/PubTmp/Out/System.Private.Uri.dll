from __future__ import annotations

from collections import defaultdict
import itertools
from typing import (
    Any,
    Callable,
    DefaultDict,
    Hashable,
    Sequence,
    TypeVar,
    cast,
)
import warnings

import numpy as np

from pandas._libs import (
    internals as libinternals,
    lib,
)
from pandas._libs.internals import BlockPlacement
from pandas._typing import (
    ArrayLike,
    Dtype,
    DtypeObj,
    Shape,
    type_t,
)
from pandas.errors import PerformanceWarning
from pandas.util._validators import validate_bool_kwarg

from pandas.core.dtypes.cast import infer_dtype_from_scalar
from pandas.core.dtypes.common import (
    ensure_platform_int,
    is_1d_only_ea_dtype,
    is_dtype_equal,
    is_list_like,
)
from pandas.core.dtypes.dtypes import ExtensionDtype
from pandas.core.dtypes.generic import (
    ABCDataFrame,
    ABCSeries,
)
from pandas.core.dtypes.missing import (
    array_equals,
    isna,
)

import pandas.core.algorithms as algos
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray
from pandas.core.arrays.sparse import SparseDtype
from pandas.core.construction import (
    ensure_wrapped_if_datetimelike,
    extract_array,
)
from pandas.core.indexers import maybe_convert_indices
from pandas.core.indexes.api import (
    Float64Index,
    Index,
    ensure_index,
)
from pandas.core.internals.base import (
    DataManager,
    SingleDataManager,
    interleaved_dtype,
)
from pandas.core.internals.blocks import (
    Block,
    CategoricalBlock,
    DatetimeTZBlock,
    ExtensionBlock,
    ensure_block_shape,
    extend_blocks,
    get_block_type,
    maybe_coerce_values,
    new_block,
)
from pandas.core.internals.ops import (
    blockwise_all,
    operate_blockwise,
)

# TODO: flexible with index=None and/or items=None

T = TypeVar("T", bound="BaseBlockManager")


class BaseBlockManager(DataManager):
    """
    Core internal data structure to implement DataFrame, Series, etc.

    Manage a bunch of labeled 2D mixed-type ndarrays. Essentially it's a
    lightweight blocked set of labeled data to be manipulated by the DataFrame
    public API class

    Attributes
    ----------
    shape
    ndim
    axes
    values
    items

    Methods
    -------
    set_axis(axis, new_labels)
    copy(deep=True)

    get_dtypes

    apply(func, axes, block_filter_fn)

    get_bool_data
    get_numeric_data

    get_slice(slice_like, axis)
    get(label)
    iget(loc)

    take(indexer, axis)
    reindex_axis(new_labels, axis)
    reindex_indexer(new_labels, indexer, axis)

    delete(label)
    insert(loc, label, value)
    set(label, value)

    Parameters
    ----------
    blocks: Sequence of Block
    axes: Sequence of Index
    verify_integrity: bool, default True

    Notes
    -----
    This is *not* a public API class
    """

    __slots__ = ()

    _blknos: np.ndarray
    _blklocs: np.ndarray
    blocks: tuple[Block, ...]
    axes: list[Index]

    ndim: int
    _known_consolidated: bool
    _is_consolidated: bool

    def __init__(self, blocks, axes, verify_integrity=True):
        raise NotImplementedError

    @classmethod
    def from_blocks(cls: type_t[T], blocks: list[Block], axes: list[Index]) -> T:
        raise NotImplementedError

    @property
    def blknos(self):
        """
        Suppose we want to find the array corresponding to our i'th column.

        blknos[i] identifies the block from self.blocks that contains this column.

        blklocs[i] identifies the column of interest within
        self.blocks[self.blknos[i]]
        """
        if self._blknos is None:
            # Note: these can be altered by other BlockManager methods.
            self._rebuild_blknos_and_blklocs()

        return self._blknos

    @property
    def blklocs(self):
        """
        See blknos.__doc__
        """
        if self._blklocs is None:
            # Note: these can be altered by other BlockManager methods.
            self._rebuild_blknos_and_blklocs()

        return self._blklocs

    def make_empty(self: T, axes=None) -> T:
        """return an empty BlockManager with the items axis of len 0"""
        if axes is None:
            axes = [Index([])] + self.axes[1:]

        # preserve dtype if possible
        if self.ndim == 1:
            assert isinstance(self, SingleBlockManager)  # for mypy
            blk = self.blocks[0]
            arr = blk.values[:0]
            bp = BlockPlacement(slice(0, 0))
            nb = blk.make_block_same_class(arr, placement=bp)
            blocks = [nb]
        else:
            blocks = []
        return type(self).from_blocks(blocks, axes)

    def __nonzero__(self) -> bool:
        return True

    # Python3 compat
    __bool__ = __nonzero__

    def _normalize_axis(self, axis: int) -> int:
        # switch axis to follow BlockManager logic
        if self.ndim == 2:
            axis = 1 if axis == 0 else 0
        return axis

    def set_axis(self, axis: int, new_labels: Index) -> None:
        # Caller is responsible for ensuring we have an Index object.
        self._validate_set_axis(axis, new_labels)
        self.axes[axis] = new_labels

    @property
    def is_single_block(self) -> bool:
        # Assumes we are 2D; overridden by SingleBlockManager
        return len(self.blocks) == 1

    def _rebuild_blknos_and_blklocs(self) -> None:
        """
        Update mgr._blknos / mgr._blklocs.
        """
        new_blknos = np.empty(self.shape[0], dtype=np.intp)
        new_blklocs = np.empty(self.shape[0], dtype=np.intp)
        new_blknos.fill(-1)
        new_blklocs.fill(-1)

        for blkno, blk in enumerate(self.blocks):
            rl = blk.mgr_locs
            new_blknos[rl.indexer] = blkno
            new_blklocs[rl.indexer] = np.arange(len(rl))

        if (new_blknos == -1).any():
            # TODO: can we avoid this?  it isn't cheap
            raise AssertionError("Gaps in blk ref_locs")

        self._blknos = new_blknos
        self._blklocs = new_blklocs

    @property
    def items(self) -> Index:
        return self.axes[0]

    def get_dtypes(self):
        dtypes = np.array([blk.dtype for blk in self.blocks])
        return dtypes.take(self.blknos)

    @property
    def arrays(self) -> list[ArrayLike]:
        """
        Quick access to the backing arrays of the Blocks.

        Only for compatibility with ArrayManager for testing convenience.
        Not to be used in actual code, and return value is not the same as the
        ArrayManager method (list of 1D arrays vs iterator of 2D ndarrays / 1D EAs).
        """
        return [blk.values for blk in self.blocks]

    def __repr__(self) -> str:
        output = type(self).__name__
        for i, ax in enumerate(self.axes):
            if i == 0:
                output += f"\nItems: {ax}"
            else:
                output += f"\nAxis {i}: {ax}"

        for block in self.blocks:
            output += f"\n{block}"
        return output

    def apply(
        self: T,
        f,
        align_keys: list[str] | None = None,
        ignore_failures: bool = False,
        **kwargs,
    ) -> T:
        """
        Iterate over the blocks, collect and create a new BlockManager.

        Parameters
        ----------
        f : str or callable
            Name of the Block method to apply.
        align_keys: List[str] or None, default None
        ignore_failures: bool, default False
        **kwargs
            Keywords to pass to `f`

        Returns
        -------
        BlockManager
        """
        assert "filter" not in kwargs

        align_keys = align_keys or []
        result_blocks: list[Block] = []
        # fillna: Series/DataFrame is responsible for making sure value is aligned

        aligned_args = {k: kwargs[k] for k in align_keys}

        for b in self.blocks:

            if aligned_args:

                for k, obj in aligned_args.items():
                    if isinstance(obj, (ABCSeries, ABCDataFrame)):
                        # The caller is responsible for ensuring that
                        #  obj.axes[-1].equals(self.items)
                        if obj.ndim == 1:
                            kwargs[k] = obj.iloc[b.mgr_locs.indexer]._values
                        else:
                            kwargs[k] = obj.iloc[:, b.mgr_locs.indexer]._values
                    else:
                        # otherwise we have an ndarray
                        kwargs[k] = obj[b.mgr_locs.indexer]

            try:
                if callable(f):
                    applied = b.apply(f, **kwargs)
                else:
                    applied = getattr(b, f)(**kwargs)
            except (TypeError, NotImplementedError):
                if not ignore_failures:
                    raise
                continue
            result_blocks = extend_blocks(applied, result_blocks)

        if ignore_failures:
            return self._combine(result_blocks)

        return type(self).from_blocks(result_blocks, self.axes)

    def where(self: T, other, cond, align: bool, errors: str) -> T:
        if align:
            align_keys = ["other", "cond"]
        else:
            align_keys = ["cond"]
            other = extract_array(other, extract_numpy=True)

        return self.apply(
            "where",
            align_keys=align_keys,
            other=other,
            cond=cond,
            errors=errors,
        )

    def setitem(self: T, indexer, value) -> T:
        return self.apply("setitem", indexer=indexer, value=value)

    def putmask(self, mask, new, align: bool = True):

        if align:
            align_keys = ["new", "mask"]
        else:
            align_keys = ["mask"]
            new = extract_array(new, extract_numpy=True)

        return self.apply(
            "putmask",
            align_keys=align_keys,
            mask=mask,
            new=new,
        )

    def diff(self: T, n: int, axis: int) -> T:
        axis = self._normalize_axis(axis)
        return self.apply("diff", n=n, axis=axis)

    def interpolate(self: T, **kwargs) -> T:
        return self.apply("interpolate", **kwargs)

    def shift(self: T, periods: int, axis: int, fill_value) -> T:
        axis = self._normalize_axis(axis)
        if fill_value is lib.no_default:
            fill_value = None

        if axis == 0 and self.ndim == 2 and self.nblocks > 1:
            # GH#35488 we need to watch out for multi-block cases
            # We only get here with fill_value not-lib.no_default
            ncols = self.shape[0]
            if periods > 0:
                indexer = np.array(
                    [-1] * periods + list(range(ncols - periods)), dtype=np.intp
                )
            else:
                nper = abs(periods)
                indexer = np.array(
                    list(range(nper, ncols)) + [-1] * nper, dtype=np.intp
                )
            result = self.reindex_indexer(
                self.items,
                indexer,
                axis=0,
                fill_value=fill_value,
                allow_dups=True,
                consolidate=False,
            )
            return result

        return self.apply("shift", periods=periods, axis=axis, fill_value=fill_value)

    def fillna(self: T, value, limit, inplace: bool, downcast) -> T:
        return self.apply(
            "fillna", value=value, limit=limit, inplace=inplace, downcast=downcast
        )

    def downcast(self: T) -> T:
        return self.apply("downcast")

    def astype(self: T, dtype, copy: bool = False, errors: str = "raise") -> T:
        return self.apply("astype", dtype=dtype, copy=copy, errors=errors)

    def convert(
        self: T,
        copy: bool = True,
        datetime: bool = True,
        numeric: bool = True,
        timedelta: bool = True,
    ) -> T:
        return self.apply(
            "convert",
            copy=copy,
            datetime=datetime,
            numeric=numeric,
            timedelta=timedelta,
        )

    def replace(self: T, to_replace, value, inplace: bool, regex: bool) -> T:
        assert np.ndim(value) == 0, value
        return self.apply(
            "replace", to_replace=to_replace, value=value, inplace=inplace, regex=regex
        )

    def replace_list(
        self: T,
        src_list: list[Any],
        dest_list: list[Any],
        inplace: bool = False,
        regex: bool = False,
    ) -> T:
        """do a list replace"""
        inplace = validate_bool_kwarg(inplace, "inplace")

        bm = self.apply(
            "_replace_list",
            src_list=src_list,
            dest_list=dest_list,
            inplace=inplace,
            regex=regex,
        )
        bm._consolidate_inplace()
        return bm

    def to_native_types(self: T, **kwargs) -> T:
        """
        Convert values to native types (strings / python objects) that are used
        in formatting (repr / csv).
        """
        return self.apply("to_native_types", **kwargs)

    def is_consolidated(self) -> bool:
        """
        Return True if more than one block with the same dtype
        """
        if not self._known_consolidated:
            self._consolidate_check()
        return self._is_consolidated

    def _consolidate_check(self) -> None:
        dtypes = [blk.dtype for blk in self.blocks if blk._can_consolidate]
        self._is_consolidated = len(dtypes) == len(set(dtypes))
        self._known_consolidated = True

    @property
    def is_numeric_mixed_type(self) -> bool:
        return all(block.is_numeric for block in self.blocks)

    @property
    def any_extension_types(self) -> bool:
        """Whether any of the blocks in this manager are extension blocks"""
        return any(block.is_extension for block in self.blocks)

    @property
    def is_view(self) -> bool:
        """return a boolean if we are a single block and are a view"""
        if len(self.blocks) == 1:
            return self.blocks[0].is_view

        # It is technically possible to figure out which blocks are views
        # e.g. [ b.values.base is not None for b in self.blocks ]
        # but then we have the case of possibly some blocks being a view
        # and some blocks not. setting in theory is possible on the non-view
        # blocks w/o causing a SettingWithCopy raise/warn. But this is a bit
        # complicated

        return False

    def get_bool_data(self: T, copy: bool = False) -> T:
        """
        Select blocks that are bool-dtype and columns from object-dtype blocks
        that are all-bool.

        Parameters
        ----------
        copy : bool, default False
            Whether to copy the blocks
        """

        new_blocks = []

        for blk in self.blocks:
            if blk.dtype == bool:
                new_blocks.append(blk)

            elif blk.is_object:
                nbs = blk._split()
                for nb in nbs:
                    if nb.is_bool:
                        new_blocks.append(nb)

        return self._combine(new_blocks, copy)

    def get_numeric_data(self: T, copy: bool = False) -> T:
        """
        Parameters
        ----------
        copy : bool, default False
            Whether to copy the blocks
        """
        return self._combine([b for b in self.blocks if b.is_numeric], copy)

    def _combine(
        self: T, blocks: list[Block], copy: bool = True, index: Index | None = None
    ) -> T:
        """return a new manager with the blocks"""
        if len(blocks) == 0:
            if self.ndim == 2:
                # retain our own Index dtype
                if index is not None:
                    axes = [self.items[:0], index]
                else:
                    axes = [self.items[:0]] + self.axes[1:]
                return self.make_empty(axes)
            return self.make_empty()

        # FIXME: optimization potential
        indexer = np.sort(np.concatenate([b.mgr_locs.as_array for b in blocks]))
        inv_indexer = lib.get_reverse_indexer(indexer, self.shape[0])

        new_blocks: list[Block] = []
        for b in blocks:
            b = b.copy(deep=copy)
            b.mgr_locs = BlockPlacement(inv_indexer[b.mgr_locs.indexer])
            new_blocks.append(b)

        axes = list(self.axes)
        if index is not None:
            axes[-1] = index
        axes[0] = self.items.take(indexer)

        return type(self).from_blocks(new_blocks, axes)

    @property
    def nblocks(self) -> int:
        return len(self.blocks)

    def copy(self: T, deep=True) -> T:
        """
        Make deep or shallow copy of BlockManager

        Parameters
        ----------
        deep : bool or string, default True
            If False, return shallow copy (do not copy data)
            If 'all', copy data and a deep copy of the index

        Returns
        -------
        BlockManager
        """
        # this preserves the notion of view copying of axes
        if deep:
            # hit in e.g. tests.io.json.test_pandas

            def copy_func(ax):
                return ax.copy(deep=True) if deep == "all" else ax.view()

            new_axes = [copy_func(ax) for ax in self.axes]
        else:
            new_axes = list(self.axes)

        res = self.apply("copy", deep=deep)
        res.axes = new_axes

        if deep:
            res._consolidate_inplace()
        return res

    def consolidate(self: T) -> T:
        """
        Join together blocks having same dtype

        Returns
        -------
        y : BlockManager
        """
        if self.is_consolidated():
            return self

        bm = type(self)(self.blocks, self.axes, verify_integrity=False)
        bm._is_consolidated = False
        bm._consolidate_inplace()
        return bm

    def _consolidate_inplace(self) -> None:
        if not self.is_consolidated():
            self.blocks = tuple(_consolidate(self.blocks))
            self._is_consolidated = True
            self._known_consolidated = True
            self._rebuild_blknos_and_blklocs()

    def reindex_indexer(
        self: T,
        new_axis: Index,
        indexer,
        axis: int,
        fill_value=None,
        allow_dups: bool = False,
        copy: bool = True,
        consolidate: bool = True,
        only_slice: bool = False,
    ) -> T:
        """
        Parameters
        ----------
        new_axis : Index
        indexer : ndarray of int64 or None
        axis : int
        fill_value : object, default None
        allow_dups : bool, default False
        copy : bool, default True
        consolidate: bool, default True
            Whether to consolidate inplace before reindexing.
        only_slice : bool, default False
            Whether to take views, not copies, along columns.

        pandas-indexer with -1's only.
        """
        if indexer is None:
            if new_axis is self.axes[axis] and not copy:
                return self

            result = self.copy(deep=copy)
            result.axes = list(self.axes)
            result.axes[axis] = new_axis
            return result

        if consolidate:
            self._consolidate_inplace()

        # some axes don't allow reindexing with dups
        if not allow_dups:
            self.axes[axis]._validate_can_reindex(indexer)

        if axis >= self.ndim:
            raise IndexError("Requested axis not found in manager")

        if axis == 0:
            new_blocks = self._slice_take_blocks_ax0(
                indexer, fill_value=fill_value, only_slice=only_slice
            )
        else:
            new_blocks = [
                blk.take_nd(
                    indexer,
                    axis=1,
                    fill_value=(
                        fill_value if fill_value is not None else blk.fill_value
                    ),
                )
                for blk in self.blocks
            ]

        new_axes = list(self.axes)
        new_axes[axis] = new_axis

        return type(self).from_blocks(new_blocks, new_axes)

    def _slice_take_blocks_ax0(
        self,
        slice_or_indexer: slice | np.ndarray,
        fill_value=lib.no_default,
        only_slice: bool = False,
    ) -> list[Block]:
        """
        Slice/take blocks along axis=0.

        Overloaded for SingleBlock

        Parameters
        ----------
        slice_or_indexer : slice or np.ndarray[int64]
        fill_value : scalar, default lib.no_default
        only_slice : bool, default False
            If True, we always return views on existing arrays, never copies.
            This is used when called from ops.blockwise.operate_blockwise.

        Returns
        -------
        new_blocks : list of Block
        """
        allow_fill = fill_value is not lib.no_default

        sl_type, slobj, sllen = _preprocess_slice_or_indexer(
            slice_or_indexer, self.shape[0], allow_fill=allow_fill
        )

        if self.is_single_block:
            blk = self.blocks[0]

            if sl_type == "slice":
                # GH#32959 EABlock would fail since we can't make 0-width
                # TODO(EA2D): special casing unnecessary with 2D EAs
                if sllen == 0:
                    return []
                bp = BlockPlacement(slice(0, sllen))
                return [blk.getitem_block_columns(slobj, new_mgr_locs=bp)]
            elif not allow_fill or self.ndim == 1:
                if allow_fill and fill_value is None:
                    fill_value = blk.fill_value

                if not allow_fill and only_slice:
                    # GH#33597 slice instead of take, so we get
                    #  views instead of copies
                    blocks = [
                        blk.getitem_block_columns(
                            slice(ml, ml + 1), new_mgr_locs=BlockPlacement(i)
                        )
                        for i, ml in enumerate(slobj)
                    ]
                    # We have
                    #  all(np.shares_memory(nb.values, blk.values) for nb in blocks)
                    return blocks
                else:
                    bp = BlockPlacement(slice(0, sllen))
                    return [
                        blk.take_nd(
                            slobj,
                            axis=0,
                            new_mgr_locs=bp,
                            fill_value=fill_value,
                        )
                    ]

        if sl_type == "slice":
            blknos = self.blknos[slobj]
            blklocs = self.blklocs[slobj]
        else:
            blknos = algos.take_nd(
                self.blknos, slobj, fill_value=-1, allow_fill=allow_fill
            )
            blklocs = algos.take_nd(
                self.blklocs, slobj, fill_value=-1, allow_fill=allow_fill
            )

        # When filling blknos, make sure blknos is updated before appending to
        # blocks list, that way new blkno is exactly len(blocks).
        blocks = []
        group = not only_slice
        for blkno, mgr_locs in libinternals.get_blkno_placements(blknos, group=group):
            if blkno == -1:
                # If we've got here, fill_value was not lib.no_default

                blocks.append(
                    self._make_na_block(placement=mgr_locs, fill_value=fill_value)
                )
            else:
                blk = self.blocks[blkno]

                # Otherwise, slicing along items axis is necessary.
                if not blk._can_consolidate and not blk._validate_ndim:
                    # i.e. we dont go through here for DatetimeTZBlock
                    # A non-consolidatable block, it's easy, because there's
                    # only one item and each mgr loc is a copy of that single
                    # item.
                    for mgr_loc in mgr_locs:
                        newblk = blk.copy(deep=False)
                        newblk.mgr_locs = BlockPlacement(slice(mgr_loc, mgr_loc + 1))
                        blocks.append(newblk)

                else:
                    # GH#32779 to avoid the performance penalty of copying,
                    #  we may try to only slice
                    taker = blklocs[mgr_locs.indexer]
                    max_len = max(len(mgr_locs), taker.max() + 1)
                    if only_slice:
                        taker = lib.maybe_indices_to_slice(taker, max_len)

                    if isinstance(taker, slice):
                        nb = blk.getitem_block_columns(taker, new_mgr_locs=mgr_locs)
                        blocks.append(nb)
                    elif only_slice:
                        # GH#33597 slice instead of take, so we get
                        #  views instead of copies
                        for i, ml in zip(taker, mgr_locs):
                            slc = slice(i, i + 1)
                            bp = BlockPlacement(ml)
                            nb = blk.getitem_block_columns(slc, new_mgr_locs=bp)
                            # We have np.shares_memory(nb.values, blk.values)
                            blocks.append(nb)
                    else:
                        nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
                        blocks.append(nb)

        return blocks

    def _make_na_block(self, placement: BlockPlacement, fill_value=None) -> Block:

        if fill_value is None:
            fill_value = np.nan
        block_shape = list(self.shape)
        block_shape[0] = len(placement)

        dtype, fill_value = infer_dtype_from_scalar(fill_value)
        # error: Argument "dtype" to "empty" has incompatible type "Union[dtype,
        # ExtensionDtype]"; expected "Union[dtype, None, type, _SupportsDtype, str,
        # Tuple[Any, int], Tuple[Any, Union[int, Sequence[int]]], List[Any], _DtypeDict,
        # Tuple[Any, Any]]"
        block_values = np.empty(block_shape, dtype=dtype)  # type: ignore[arg-type]
        block_values.fill(fill_value)
        return new_block(block_values, placement=placement, ndim=block_values.ndim)

    def take(self: T, indexer, axis: int = 1, verify: bool = True) -> T:
        """
        Take items along any axis.

        indexer : np.ndarray or slice
        axis : int, default 1
        verify : bool, default True
            Check that all entries are between 0 and len(self) - 1, inclusive.
            Pass verify=False if this check has been done by the caller.

        Returns
        -------
        BlockManager
        """
        # We have 6 tests that get here with a slice
        indexer = (
            np.arange(indexer.start, indexer.stop, indexer.step, dtype="int64")
            if isinstance(indexer, slice)
            else np.asanyarray(indexer, dtype="int64")
        )

        n = self.shape[axis]
        indexer = maybe_convert_indices(indexer, n, verify=verify)

        new_labels = self.axes[axis].take(indexer)
        return self.reindex_indexer(
            new_axis=new_labels,
            indexer=indexer,
            axis=axis,
            allow_dups=True,
            consolidate=False,
        )


class BlockManager(libinternals.BlockManager, BaseBlockManager):
    """
    BaseBlockManager that holds 2D blocks.
    """

    ndim = 2

    # ----------------------------------------------------------------
    # Constructors

    def __init__(
        self,
        blocks: Sequence[Block],
        axes: Sequence[Index],
        verify_integrity: bool = True,
    ):

        if verify_integrity:
            assert all(isinstance(x, Index) for x in axes)

            for block in blocks:
                if self.ndim != block.ndim:
                    raise AssertionError(
                        f"Number of Block dimensions ({block.ndim}) must equal "
                        f"number of axes ({self.ndim})"
                    )
                if isinstance(block, DatetimeTZBlock) and block.values.ndim == 1:
                    # TODO: remove once fastparquet no longer needs this
                    # error: Incompatible types in assignment (expression has type
                    # "Union[ExtensionArray, ndarray]", variable has type
                    # "DatetimeArray")
                    block.values = ensure_block_shape(  # type: ignore[assignment]
                        block.values, self.ndim
                    )
                    try:
                        block._cache.clear()
                    except AttributeError:
                        # _cache not initialized
                        pass

            self._verify_integrity()

    def _verify_integrity(self) -> None:
        mgr_shape = self.shape
        tot_items = sum(len(x.mgr_locs) for x in self.blocks)
        for block in self.blocks:
            if block.shape[1:] != mgr_shape[1:]:
                raise construction_error(tot_items, block.shape[1:], self.axes)
        if len(self.items) != tot_items:
            raise AssertionError(
                "Number of manager items must equal union of "
                f"block items\n# manager items: {len(self.items)}, # "
                f"tot_items: {tot_items}"
            )

    @classmethod
    def from_blocks(cls, blocks: list[Block], axes: list[Index]) -> BlockManager:
        """
        Constructor for BlockManager and SingleBlockManager with same signature.
        """
        return cls(blocks, axes, verify_integrity=False)

    # ----------------------------------------------------------------
    # Indexing

    def fast_xs(self, loc: int) -> ArrayLike:
        """
        Return the array corresponding to `frame.iloc[loc]`.

        Parameters
        ----------
        loc : int

        Returns
        -------
        np.ndarray or ExtensionArray
        """
        if len(self.blocks) == 1:
            return self.blocks[0].iget((slice(None), loc))

        dtype = interleaved_dtype([blk.dtype for blk in self.blocks])

        n = len(self)
        if isinstance(dtype, ExtensionDtype):
            # we'll eventually construct an ExtensionArray.
            result = np.empty(n, dtype=object)
            # TODO: let's just use dtype.empty?
        else:
            result = np.empty(n, dtype=dtype)

        result = ensure_wrapped_if_datetimelike(result)

        for blk in self.blocks:
            # Such assignment may incorrectly coerce NaT to None
            # result[blk.mgr_locs] = blk._slice((slice(None), loc))
            for i, rl in enumerate(blk.mgr_locs):
                result[rl] = blk.iget((i, loc))

        if isinstance(dtype, ExtensionDtype):
            result = dtype.construct_array_type()._from_sequence(result, dtype=dtype)

        return result

    def iget(self, i: int) -> SingleBlockManager:
        """
        Return the data as a SingleBlockManager.
        """
        block = self.blocks[self.blknos[i]]
        values = block.iget(self.blklocs[i])

        # shortcut for select a single-dim from a 2-dim BM
        bp = BlockPlacement(slice(0, len(values)))
        values = maybe_coerce_values(values)
        nb = type(block)(values, placement=bp, ndim=1)
        return SingleBlockManager(nb, self.axes[1])

    def iget_values(self, i: int) -> ArrayLike:
        """
        Return the data for column i as the values (ndarray or ExtensionArray).
        """
        block = self.blocks[self.blknos[i]]
        values = block.iget(self.blklocs[i])
        return values

    @property
    def column_arrays(self) -> list[np.ndarray]:
        """
        Used in the JSON C code to access column arrays.
        This optimizes compared to using `iget_values` by converting each
        block.values to a np.ndarray only once up front
        """
        # special casing datetimetz to avoid conversion through object dtype
        arrays = [
            blk.values._ndarray
            if isinstance(blk, DatetimeTZBlock)
            else np.asarray(blk.values)
            for blk in self.blocks
        ]
        result = []
        for i in range(len(self.items)):
            arr = arrays[self.blknos[i]]
            if arr.ndim == 2:
                values = arr[self.blklocs[i]]
            else:
                values = arr
            result.append(values)
        return result

    def iset(self, loc: int | slice | np.ndarray, value: ArrayLike):
        """
        Set new item in-place. Does not consolidate. Adds new Block if not
        contained in the current set of items
        """
        value = extract_array(value, extract_numpy=True)
        # FIXME: refactor, clearly separate broadcasting & zip-like assignment
        #        can prob also fix the various if tests for sparse/categorical
        if self._blklocs is None and self.ndim > 1:
            self._rebuild_blknos_and_blklocs()

        # Note: we exclude DTA/TDA here
        vdtype = getattr(value, "dtype", None)
        value_is_extension_type = is_1d_only_ea_dtype(vdtype)

        # categorical/sparse/datetimetz
        if value_is_extension_type:

            def value_getitem(placement):
                return value

        else:
            if value.ndim == 2:
                value = value.T
            else:
                value = ensure_block_shape(value, ndim=2)

            def value_getitem(placement):
                return value[placement.indexer]

            if value.shape[1:] != self.shape[1:]:
                raise AssertionError(
                    "Shape of new values must be compatible with manager shape"
                )

        if lib.is_integer(loc):
            # We have 6 tests where loc is _not_ an int.
            # In this case, get_blkno_placements will yield only one tuple,
            #  containing (self._blknos[loc], BlockPlacement(slice(0, 1, 1)))

            # error: Incompatible types in assignment (expression has type
            # "List[Union[int, slice, ndarray]]", variable has type "Union[int,
            # slice, ndarray]")
            loc = [loc]  # type: ignore[assignment]

        # Accessing public blknos ensures the public versions are initialized
        blknos = self.blknos[loc]
        blklocs = self.blklocs[loc].copy()

        unfit_mgr_locs = []
        unfit_val_locs = []
        removed_blknos = []
        for blkno, val_locs in libinternals.get_blkno_placements(blknos, group=True):
            blk = self.blocks[blkno]
            blk_locs = blklocs[val_locs.indexer]
            if blk.should_store(value):
                blk.set_inplace(blk_locs, value_getitem(val_locs))
            else:
                unfit_mgr_locs.append(blk.mgr_locs.as_array[blk_locs])
                unfit_val_locs.append(val_locs)

                # If all block items are unfit, schedule the block for removal.
                if len(val_locs) == len(blk.mgr_locs):
                    removed_blknos.append(blkno)
                else:
                    blk.delete(blk_locs)
                    self._blklocs[blk.mgr_locs.indexer] = np.arange(len(blk))

        if len(removed_blknos):
            # Remove blocks & update blknos accordingly
            is_deleted = np.zeros(self.nblocks, dtype=np.bool_)
            is_deleted[removed_blknos] = True

            new_blknos = np.empty(self.nblocks, dtype=np.intp)
            new_blknos.fill(-1)
            new_blknos[~is_deleted] = np.arange(self.nblocks - len(removed_blknos))
            self._blknos = new_blknos[self._blknos]
            self.blocks = tuple(
                blk for i, blk in enumerate(self.blocks) if i not in set(removed_blknos)
            )

        if unfit_val_locs:
            unfit_mgr_locs = np.concatenate(unfit_mgr_locs)
            unfit_count = len(unfit_mgr_locs)

            new_blocks: list[Block] = []
            if value_is_extension_type:
                # This code (ab-)uses the fact that EA blocks contain only
                # one item.
                # TODO(EA2D): special casing unnecessary with 2D EAs
                new_blocks.extend(
                    new_block(
                        values=value,
                        ndim=self.ndim,
                        placement=slice(mgr_loc, mgr_loc + 1),
                    )
                    for mgr_loc in unfit_mgr_locs
                )

                self._blknos[unfit_mgr_locs] = np.arange(unfit_count) + len(self.blocks)
                self._blklocs[unfit_mgr_locs] = 0

            else:
                # unfit_val_locs contains BlockPlacement objects
                unfit_val_items = unfit_val_locs[0].append(unfit_val_locs[1:])

                new_blocks.append(
                    new_block(
                        values=value_getitem(unfit_val_items),
                        ndim=self.ndim,
                        placement=unfit_mgr_locs,
                    )
                )

                self._blknos[unfit_mgr_locs] = len(self.blocks)
                self._blklocs[unfit_mgr_locs] = np.arange(unfit_count)

            self.blocks += tuple(new_blocks)

            # Newly created block's dtype may already be present.
            self._known_consolidated = False

    def insert(self, loc: int, item: Hashable, value: ArrayLike) -> None:
        """
        Insert item at selected position.

        Parameters
        ----------
        loc : int
        item : hashable
        value : np.ndarray or ExtensionArray
        """
        # insert to the axis; this could possibly raise a TypeError
        new_axis = self.items.insert(loc, item)

        if value.ndim == 2:
            value = value.T
        else:
            value = ensure_block_shape(value, ndim=self.ndim)

        block = new_block(values=value, ndim=self.ndim, placement=slice(loc, loc + 1))

        for blkno, count in _fast_count_smallints(self.blknos[loc:]):
            blk = self.blocks[blkno]
            if count == len(blk.mgr_locs):
                blk.mgr_locs = blk.mgr_locs.add(1)
            else:
                new_mgr_locs = blk.mgr_locs.as_array.copy()
                new_mgr_locs[new_mgr_locs >= loc] += 1
                blk.mgr_locs = BlockPlacement(new_mgr_locs)

        # Accessing public blklocs ensures the public versions are initialized
        if loc == self.blklocs.shape[0]:
            # np.append is a lot faster, let's use it if we can.
            self._blklocs = np.append(self._blklocs, 0)
            self._blknos = np.append(self._blknos, len(self.blocks))
        else:
            self._blklocs = np.insert(self._blklocs, loc, 0)
            self._blknos = np.insert(self._blknos, loc, len(self.blocks))

        self.axes[0] = new_axis
        self.blocks += (block,)

        self._known_consolidated = False

        if len(self.blocks) > 100:
            warnings.warn(
                "DataFrame is highly fragmented.  This is usually the result "
                "of calling `frame.insert` many times, which has poor performance.  "
                "Consider joining all columns at once using pd.concat(axis=1) "
                "instead.  To get a de-fragmented frame, use `newframe = frame.copy()`",
                PerformanceWarning,
                stacklevel=5,
            )

    def idelete(self, indexer) -> BlockManager:
        """
        Delete selected locations, returning a new BlockManager.
        """
        is_deleted = np.zeros(self.shape[0], dtype=np.bool_)
        is_deleted[indexer] = True
        taker = (~is_deleted).nonzero()[0]

        nbs = self._slice_take_blocks_ax0(taker, only_slice=True)
        new_columns = self.items[~is_deleted]
        axes = [new_columns, self.axes[1]]
        return type(self)(tuple(nbs), axes)

    # ----------------------------------------------------------------
    # Block-wise Operation

    def grouped_reduce(self: T, func: Callable, ignore_failures: bool = False) -> T:
        """
        Apply grouped reduction function blockwise, returning a new BlockManager.

        Parameters
        ----------
        func : grouped reduction function
        ignore_failures : bool, default False
            Whether to drop blocks where func raises TypeError.

        Returns
        -------
        BlockManager
        """
        result_blocks: list[Block] = []

        for blk in self.blocks:
            if blk.is_object:
                # split on object-dtype blocks bc some columns may raise
                #  while others do not.
                for sb in blk._split():
                    try:
                        applied = sb.apply(func)
                    except (TypeError, NotImplementedError):
                        if not ignore_failures:
                            raise
                        continue
                    result_blocks = extend_blocks(applied, result_blocks)
            else:
                try:
                    applied = blk.apply(func)
                except (TypeError, NotImplementedError):
                    if not ignore_failures:
                        raise
                    continue
                result_blocks = extend_blocks(applied, result_blocks)

        if len(result_blocks) == 0:
            index = Index([None])  # placeholder
        else:
            index = Index(range(result_blocks[0].values.shape[-1]))

        if ignore_failures:
            return self._combine(result_blocks, copy=False, index=index)

        return type(self).from_blocks(result_blocks, [self.axes[0], index])

    def reduce(
        self: T, func: Callable, ignore_failures: bool = False
    ) -> tuple[T, np.ndarray]:
        """
        Apply reduction function blockwise, returning a single-row BlockManager.

        Parameters
        ----------
        func : reduction function
        ignore_failures : bool, default False
            Whether to drop blocks where func raises TypeError.

        Returns
        -------
        BlockManager
        np.ndarray
            Indexer of mgr_locs that are retained.
        """
        # If 2D, we assume that we're operating column-wise
        assert self.ndim == 2

        res_blocks: list[Block] = []
        for blk in self.blocks:
            nbs = blk.reduce(func, ignore_failures)
            res_blocks.extend(nbs)

        index = Index([None])  # placeholder
        if ignore_failures:
            if res_blocks:
                indexer = np.concatenate([blk.mgr_locs.as_array for blk in res_blocks])
                new_mgr = self._combine(res_blocks, copy=False, index=index)
            else:
                indexer = []
                new_mgr = type(self).from_blocks([], [self.items[:0], index])
        else:
            indexer = np.arange(self.shape[0])
            new_mgr = type(self).from_blocks(res_blocks, [self.items, index])
        return new_mgr, indexer

    def operate_blockwise(self, other: BlockManager, array_op) -> BlockManager:
        """
        Apply array_op blockwise with another (aligned) BlockManager.
        """
        return operate_blockwise(self, other, array_op)

    def _equal_values(self: BlockManager, other: BlockManager) -> bool:
        """
        Used in .equals defined in base class. Only check the column values
        assuming shape and indexes have already been checked.
        """
        return blockwise_all(self, other, array_equals)

    def quantile(
        self: T,
        *,
        qs: Float64Index,
        axis: int = 0,
        interpolation="linear",
    ) -> T:
        """
        Iterate over blocks applying quantile reduction.
        This routine is intended for reduction type operations and
        will do inference on the generated blocks.

        Parameters
        ----------
        axis: reduction axis, default 0
        consolidate: bool, default True. Join together blocks having same
            dtype
        interpolation : type of interpolation, default 'linear'
        qs : list of the quantiles to be computed

        Returns
        -------
        BlockManager
        """
        # Series dispatches to DataFrame for quantile, which allows us to
        #  simplify some of the code here and in the blocks
        assert self.ndim >= 2
        assert is_list_like(qs)  # caller is responsible for this
        assert axis == 1  # only ever called this way

        new_axes = list(self.axes)
        new_axes[1] = Float64Index(qs)

        blocks = [
            blk.quantile(axis=axis, qs=qs, interpolation=interpolation)
            for blk in self.blocks
        ]

        return type(self)(blocks, new_axes)

    # ----------------------------------------------------------------

    def unstack(self, unstacker, fill_value) -> BlockManager:
        """
        Return a BlockManager with all blocks unstacked..

        Parameters
        ----------
        unstacker : reshape._Unstacker
        fill_value : Any
            fill_value for newly introduced missing values.

        Returns
        -------
        unstacked : BlockManager
        """
        new_columns = unstacker.get_new_columns(self.items)
        new_index = unstacker.new_index

        new_blocks: list[Block] = []
        columns_mask: list[np.ndarray] = []

        for blk in self.blocks:
            blk_cols = self.items[blk.mgr_locs.indexer]
            new_items = unstacker.get_new_columns(blk_cols)
            new_placement = new_columns.get_indexer(new_items)

            blocks, mask = blk._unstack(
                unstacker, fill_value, new_placement=new_placement
            )

            new_blocks.extend(blocks)
            columns_mask.extend(mask)

        new_columns = new_columns[columns_mask]

        bm = BlockManager(new_blocks, [new_columns, new_index])
        return bm

    def to_dict(self, copy: bool = True):
        """
        Return a dict of str(dtype) -> BlockManager

        Parameters
        ----------
        copy : bool, default True

        Returns
        -------
        values : a dict of dtype -> BlockManager
        """

        bd: dict[str, list[Block]] = {}
        for b in self.blocks:
            bd.setdefault(str(b.dtype), []).append(b)

        # TODO(EA2D): the combine will be unnecessary with 2D EAs
        return {dtype: self._combine(blocks, copy=copy) for dtype, blocks in bd.items()}

    def as_array(
        self,
        transpose: bool = False,
        dtype: Dtype | None = None,
        copy: bool = False,
        na_value=lib.no_default,
    ) -> np.ndarray:
        """
        Convert the blockmanager data into an numpy array.

        Parameters
        ----------
        transpose : bool, default False
            If True, transpose the return array.
        dtype : object, default None
            Data type of the return array.
        copy : bool, default False
            If True then guarantee that a copy is returned. A value of
            False does not guarantee that the underlying data is not
            copied.
        na_value : object, default lib.no_default
            Value to be used as the missing value sentinel.

        Returns
        -------
        arr : ndarray
        """
        if len(self.blocks) == 0:
            arr = np.empty(self.shape, dtype=float)
            return arr.transpose() if transpose else arr

        # We want to copy when na_value is provided to avoid
        # mutating the original object
        copy = copy or na_value is not lib.no_default

        if self.is_single_block:
            blk = self.blocks[0]
            if blk.is_extension:
                # Avoid implicit conversion of extension blocks to object

                # error: Item "ndarray" of "Union[ndarray, ExtensionArray]" has no
                # attribute "to_numpy"
                arr = blk.values.to_numpy(  # type: ignore[union-attr]
                    dtype=dtype, na_value=na_value
                ).reshape(blk.shape)
            else:
                arr = np.asarray(blk.get_values())
                if dtype:
                    # error: Argument 1 to "astype" of "_ArrayOrScalarCommon" has
                    # incompatible type "Union[ExtensionDtype, str, dtype[Any],
                    # Type[object]]"; expected "Union[dtype[Any], None, type,
                    # _SupportsDType, str, Union[Tuple[Any, int], Tuple[Any, Union[int,
                    # Sequence[int]]], List[Any], _DTypeDict, Tuple[Any, Any]]]"
                    arr = arr.astype(dtype, copy=False)  # type: ignore[arg-type]
        else:
            arr = self._interleave(dtype=dtype, na_value=na_value)
            # The underlying data was copied within _interleave
            copy = False

        if copy:
            arr = arr.copy()

        if na_value is not lib.no_default:
            arr[isna(arr)] = na_value

        return arr.transpose() if transpose else arr

    def _interleave(
        self, dtype: Dtype | None = None, na_value=lib.no_default
    ) -> np.ndarray:
        """
        Return ndarray from blocks with specified item order
        Items must be contained in the blocks
        """
        if not dtype:
            dtype = interleaved_dtype([blk.dtype for blk in self.blocks])

        # TODO: https://github.com/pandas-dev/pandas/issues/22791
        # Give EAs some input on what happens here. Sparse needs this.
        if isinstance(dtype, SparseDtype):
            dtype = dtype.subtype
        elif isinstance(dtype, ExtensionDtype):
            dtype = np.dtype("object")
        elif is_dtype_equal(dtype, str):
            dtype = np.dtype("object")

        # error: Argument "dtype" to "empty" has incompatible type
        # "Union[ExtensionDtype, str, dtype[Any], Type[object], None]"; expected
        # "Union[dtype[Any], None, type, _SupportsDType, str, Union[Tuple[Any, int],
        # Tuple[Any, Union[int, Sequence[int]]], List[Any], _DTypeDict,
        # Tuple[Any, Any]]]"
        result = np.empty(self.shape, dtype=dtype)  # type: ignore[arg-type]

        itemmask = np.zeros(self.shape[0])

        for blk in self.blocks:
            rl = blk.mgr_locs
            if blk.is_extension:
                # Avoid implicit conversion of extension blocks to object

                # error: Item "ndarray" of "Union[ndarray, ExtensionArray]" has no
                # attribute "to_numpy"
                arr = blk.values.to_numpy(  # type: ignore[union-attr]
                    dtype=dtype, na_value=na_value
                )
            else:
                # error: Argument 1 to "get_values" of "Block" has incompatible type
                # "Union[ExtensionDtype, str, dtype[Any], Type[object], None]"; expected
                # "Union[dtype[Any], ExtensionDtype, None]"
                arr = blk.get_values(dtype)  # type: ignore[arg-type]
            result[rl.indexer] = arr
            itemmask[rl.indexer] = 1

        if not itemmask.all():
            raise AssertionError("Some items were not contained in blocks")

        return result


class SingleBlockManager(BaseBlockManager, SingleDataManager):
    """manage a single block with"""

    ndim = 1
    _is_consolidated = True
    _known_consolidated = True
    __slots__ = ()
    is_single_block = True

    def __init__(
        self,
        block: Block,
        axis: Index,
        verify_integrity: bool = False,
        fastpath=lib.no_default,
    ):
        assert isinstance(block, Block), type(block)
        assert isinstance(axis, Index), type(axis)

        if fastpath is not lib.no_default:
            warnings.warn(
                "The `fastpath` keyword is deprecated and will be removed "
                "in a future version.",
                FutureWarning,
                stacklevel=2,
            )

        self.axes = [axis]
        self.blocks = (block,)

    @classmethod
    def from_blocks(cls, blocks: list[Block], axes: list[Index]) -> SingleBlockManager:
        """
        Constructor for BlockManager and SingleBlockManager with same signature.
        """
        assert len(blocks) == 1
        assert len(axes) == 1
        return cls(blocks[0], axes[0], verify_integrity=False)

    @classmethod
    def from_array(cls, array: ArrayLike, index: Index) -> SingleBlockManager:
        """
        Constructor for if we have an array that is not yet a Block.
        """
        block = new_block(array, placement=slice(0, len(index)), ndim=1)
        return cls(block, index)

    def __getstate__(self):
        block_values = [b.values for b in self.blocks]
        block_items = [self.items[b.mgr_locs.indexer] for b in self.blocks]
        axes_array = list(self.axes)

        extra_state = {
            "0.14.1": {
                "axes": axes_array,
                "blocks": [
                    {"values": b.values, "mgr_locs": b.mgr_locs.indexer}
                    for b in self.blocks
                ],
            }
        }

        # First three elements of the state are to maintain forward
        # compatibility with 0.13.1.
        return axes_array, block_values, block_items, extra_state

    def __setstate__(self, state):
        def unpickle_block(values, mgr_locs, ndim: int) -> Block:
            # TODO(EA2D): ndim would be unnecessary with 2D EAs
            # older pickles may store e.g. DatetimeIndex instead of DatetimeArray
            values = extract_array(values, extract_numpy=True)
            return new_block(values, placement=mgr_locs, ndim=ndim)

        if isinstance(state, tuple) and len(state) >= 4 and "0.14.1" in state[3]:
            state = state[3]["0.14.1"]
            self.axes = [ensure_index(ax) for ax in state["axes"]]
            ndim = len(self.axes)
            self.blocks = tuple(
                unpickle_block(b["values"], b["mgr_locs"], ndim=ndim)
                for b in state["blocks"]
            )
        else:
            raise NotImplementedError("pre-0.14.1 pickles are no longer supported")

        self._post_setstate()

    def _post_setstate(self):
        pass

    @property
    def _block(self) -> Block:
        return self.blocks[0]

    @property
    def _blknos(self):
        """compat with BlockManager"""
        return None

    @property
    def _blklocs(self):
        """compat with BlockManager"""
        return None

    def getitem_mgr(self, indexer) -> SingleBlockManager:
        # similar to get_slice, but not restricted to slice indexer
        blk = self._block
        array = blk._slice(indexer)
        if array.ndim > 1:
            # This will be caught by Series._get_values
            raise ValueError("dimension-expanding indexing not allowed")

        bp = BlockPlacement(slice(0, len(array)))
        block = blk.make_block_same_class(array, placement=bp)

        new_idx = self.index[indexer]
        return type(self)(block, new_idx)

    def get_slice(self, slobj: slice, axis: int = 0) -> SingleBlockManager:
        assert isinstance(slobj, slice), type(slobj)
        if axis >= self.ndim:
            raise IndexError("Requested axis not found in manager")

        blk = self._block
        array = blk._slice(slobj)
        bp = BlockPlacement(slice(0, len(array)))
        block = blk.make_block_same_class(array, placement=bp)
        new_index = self.index._getitem_slice(slobj)
        return type(self)(block, new_index)

    @property
    def index(self) -> Index:
        return self.axes[0]

    @property
    def dtype(self) -> DtypeObj:
        return self._block.dtype

    def get_dtypes(self) -> np.ndarray:
        return np.array([self._block.dtype])

    def external_values(self):
        """The array that Series.values returns"""
        return self._block.external_values()

    def internal_values(self):
        """The array that Series._values returns"""
        return self._block.values

    def array_values(self):
        """The array that Series.array returns"""
        return self._block.array_values

    @property
    def _can_hold_na(self) -> bool:
        return self._block._can_hold_na

    def is_consolidated(self) -> bool:
        return True

    def _consolidate_check(self):
        pass

    def _consolidate_inplace(self):
        pass

    def idelete(self, indexer) -> SingleBlockManager:
        """
        Delete single location from SingleBlockManager.

        Ensures that self.blocks doesn't become empty.
        """
        self._block.delete(indexer)
        self.axes[0] = self.axes[0].delete(indexer)
        return self

    def fast_xs(self, loc):
        """
        fast path for getting a cross-section
        return a view of the data
        """
        raise NotImplementedError("Use series._values[loc] instead")

    def set_values(self, values: ArrayLike):
        """
        Set the values of the single block in place.

        Use at your own risk! This does not check if the passed values are
        valid for the current Block/SingleBlockManager (length, dtype, etc).
        """
        self.blocks[0].values = values
        self.blocks[0]._mgr_locs = BlockPlacement(slice(len(values)))

    def _equal_values(self: T, other: T) -> bool:
        """
        Used in .equals defined in base class. Only check the column values
        assuming shape and indexes have already been checked.
        """
        # For SingleBlockManager (i.e.Series)
        if other.ndim != 1:
            return False
        left = self.blocks[0].values
        right = other.blocks[0].values
        return array_equals(left, right)


# --------------------------------------------------------------------
# Constructor Helpers


def create_block_manager_from_blocks(
    blocks: list[Block], axes: list[Index], consolidate: bool = True
) -> BlockManager:
    try:
        mgr = BlockManager(blocks, axes)

    except ValueError as err:
        arrays = [blk.values for blk in blocks]
        tot_items = sum(arr.shape[0] for arr in arrays)
        raise construction_error(tot_items, arrays[0].shape[1:], axes, err)

    if consolidate:
        mgr._consolidate_inplace()
    return mgr


# We define this here so we can override it in tests.extension.test_numpy
def _extract_array(obj):
    return extract_array(obj, extract_numpy=True)


def create_block_manager_from_arrays(
    arrays,
    names: Index,
    axes: list[Index],
    consolidate: bool = True,
) -> BlockManager:
    assert isinstance(names, Index)
    assert isinstance(axes, list)
    assert all(isinstance(x, Index) for x in axes)

    arrays = [_extract_array(x) for x in arrays]

    try:
        blocks = _form_blocks(arrays, names, axes, consolidate)
        mgr = BlockManager(blocks, axes)
    except ValueError as e:
        raise construction_error(len(arrays), arrays[0].shape, axes, e)
    if consolidate:
        mgr._consolidate_inplace()
    return mgr


def construction_error(
    tot_items: int,
    block_shape: Shape,
    axes: list[Index],
    e: ValueError | None = None,
):
    """raise a helpful message about our construction"""
    passed = tuple(map(int, [tot_items] + list(block_shape)))
    # Correcting the user facing error message during dataframe construction
    if len(passed) <= 2:
        passed = passed[::-1]

    implied = tuple(len(ax) for ax in axes)
    # Correcting the user facing error message during dataframe construction
    if len(implied) <= 2:
        implied = implied[::-1]

    # We return the exception object instead of raising it so that we
    #  can raise it in the caller; mypy plays better with that
    if passed == implied and e is not None:
        return e
    if block_shape[0] == 0:
        return ValueError("Empty data passed with indices specified.")
    return ValueError(f"Shape of passed values is {passed}, indices imply {implied}")


# -----------------------------------------------------------------------


def _form_blocks(
    arrays: list[ArrayLike], names: Index, axes: list[Index], consolidate: bool
) -> list[Block]:
    # put "leftover" items in float bucket, where else?
    # generalize?
    items_dict: DefaultDict[str, list] = defaultdict(list)
    extra_locs = []

    names_idx = names
    if names_idx.equals(axes[0]):
        names_indexer = np.arange(len(names_idx))
    else:
        assert names_idx.intersection(axes[0]).is_unique
        names_indexer = names_idx.get_indexer_for(axes[0])

    for i, name_idx in enumerate(names_indexer):
        if name_idx == -1:
            extra_locs.append(i)
            continue

        v = arrays[name_idx]

        block_type = get_block_type(v)
        items_dict[block_type.__name__].append((i, v))

    blocks: list[Block] = []
    if len(items_dict["NumericBlock"]):
        numeric_blocks = _multi_blockify(
            items_dict["NumericBlock"], consolidate=consolidate
        )
        blocks.extend(numeric_blocks)

    if len(items_dict["DatetimeLikeBlock"]):
        dtlike_blocks = _multi_blockify(
            items_dict["DatetimeLikeBlock"], consolidate=consolidate
        )
        blocks.extend(dtlike_blocks)

    if len(items_dict["DatetimeTZBlock"]):
        dttz_blocks = [
            new_block(
                ensure_block_shape(extract_array(array), 2),
                klass=DatetimeTZBlock,
                placement=i,
                ndim=2,
            )
            for i, array in items_dict["DatetimeTZBlock"]
        ]
        blocks.extend(dttz_blocks)

    if len(items_dict["ObjectBlock"]) > 0:
        object_blocks = _simple_blockify(
            items_dict["ObjectBlock"], np.object_, consolidate=consolidate
        )
        blocks.extend(object_blocks)

    if len(items_dict["CategoricalBlock"]) > 0:
        cat_blocks = [
            new_block(array, klass=CategoricalBlock, placement=i, ndim=2)
            for i, array in items_dict["CategoricalBlock"]
        ]
        blocks.extend(cat_blocks)

    if len(items_dict["ExtensionBlock"]):
        external_blocks = [
            new_block(array, klass=ExtensionBlock, placement=i, ndim=2)
            for i, array in items_dict["ExtensionBlock"]
        ]

        blocks.extend(external_blocks)

    if len(extra_locs):
        shape = (len(extra_locs),) + tuple(len(x) for x in axes[1:])

        # empty items -> dtype object
        block_values = np.empty(shape, dtype=object)
        block_values.fill(np.nan)

        na_block = new_block(block_values, placement=extra_locs, ndim=2)
        blocks.append(na_block)

    return blocks


def _simple_blockify(tuples, dtype, consolidate: bool) -> list[Block]:
    """
    return a single array of a block that has a single dtype; if dtype is
    not None, coerce to this dtype
    """
    if not consolidate:
        return _tuples_to_blocks_no_consolidate(tuples, dtype=dtype)

    values, placement = _stack_arrays(tuples, dtype)

    # TODO: CHECK DTYPE?
    if dtype is not None and values.dtype != dtype:  # pragma: no cover
        values = values.astype(dtype)

    block = new_block(values, placement=placement, ndim=2)
    return [block]


def _multi_blockify(tuples, dtype: DtypeObj | None = None, consolidate: bool = True):
    """return an array of blocks that potentially have different dtypes"""

    if not consolidate:
        return _tuples_to_blocks_no_consolidate(tuples, dtype=dtype)

    # group by dtype
    grouper = itertools.groupby(tuples, lambda x: x[1].dtype)

    new_blocks = []
    for dtype, tup_block in grouper:

        # error: Argument 2 to "_stack_arrays" has incompatible type
        # "Union[ExtensionDtype, str, dtype[Any], Type[str], Type[float], Type[int],
        # Type[complex], Type[bool], Type[object], None]"; expected "dtype[Any]"
        values, placement = _stack_arrays(
            list(tup_block), dtype  # type: ignore[arg-type]
        )

        block = new_block(values, placement=placement, ndim=2)
        new_blocks.append(block)

    return new_blocks


def _tuples_to_blocks_no_consolidate(tuples, dtype: DtypeObj | None) -> list[Block]:
    # tuples produced within _form_blocks are of the form (placement, whatever, array)
    if dtype is not None:
        return [
            new_block(
                np.atleast_2d(x[1].astype(dtype, copy=False)), placement=x[0], ndim=2
            )
            for x in tuples
        ]
    return [new_block(np.atleast_2d(x[1]), placement=x[0], ndim=2) for x in tuples]


def _stack_arrays(tuples, dtype: np.dtype):

    placement, arrays = zip(*tuples)

    first = arrays[0]
    shape = (len(arrays),) + first.shape

    stacked = np.empty(shape, dtype=dtype)
    for i, arr in enumerate(arrays):
        stacked[i] = arr

    return stacked, placement


def _consolidate(blocks: tuple[Block, ...]) -> list[Block]:
    """
    Merge blocks having same dtype, exclude non-consolidating blocks
    """
    # sort by _can_consolidate, dtype
    gkey = lambda x: x._consolidate_key
    grouper = itertools.groupby(sorted(blocks, key=gkey), gkey)

    new_blocks: list[Block] = []
    for (_can_consolidate, dtype), group_blocks in grouper:
        merged_blocks = _merge_blocks(
            list(group_blocks), dtype=dtype, can_consolidate=_can_consolidate
        )
        new_blocks = extend_blocks(merged_blocks, new_blocks)
    return new_blocks


def _merge_blocks(
    blocks: list[Block], dtype: DtypeObj, can_consolidate: bool
) -> list[Block]:

    if len(blocks) == 1:
        return blocks

    if can_consolidate:

        # TODO: optimization potential in case all mgrs contain slices and
        # combination of those slices is a slice, too.
        new_mgr_locs = np.concatenate([b.mgr_locs.as_array for b in blocks])

        new_values: ArrayLike

        if isinstance(blocks[0].dtype, np.dtype):
            # error: List comprehension has incompatible type List[Union[ndarray,
            # ExtensionArray]]; expected List[Union[complex, generic,
            # Sequence[Union[int, float, complex, str, bytes, generic]],
            # Sequence[Sequence[Any]], SupportsArray]]
            new_values = np.vstack([b.values for b in blocks])  # type: ignore[misc]
        else:
            bvals = [blk.values for blk in blocks]
            bvals2 = cast(Sequence[NDArrayBackedExtensionArray], bvals)
            new_values = bvals2[0]._concat_same_type(bvals2, axis=0)

        argsort = np.argsort(new_mgr_locs)
        new_values = new_values[argsort]
        new_mgr_locs = new_mgr_locs[argsort]

        bp = BlockPlacement(new_mgr_locs)
        return [new_block(new_values, placement=bp, ndim=2)]

    # can't consolidate --> no merge
    return blocks


def _fast_count_smallints(arr: np.ndarray) -> np.ndarray:
    """Faster version of set(arr) for sequences of small numbers."""
    counts = np.bincount(arr.astype(np.int_))
    nz = counts.nonzero()[0]
    return np.c_[nz, counts[nz]]


def _preprocess_slice_or_indexer(
    slice_or_indexer: slice | np.ndarray, length: int, allow_fill: bool
):
    if isinstance(slice_or_indexer, slice):
        return (
            "slice",
            slice_or_indexer,
            libinternals.slice_len(slice_or_indexer, length),
        )
    else:
        if (
            not isinstance(slice_or_indexer, np.ndarray)
            or slice_or_indexer.dtype.kind != "i"
        ):
            dtype = getattr(slice_or_indexer, "dtype", None)
            raise TypeError(type(slice_or_indexer), dtype)

        indexer = ensure_platform_int(slice_or_indexer)
        if not allow_fill:
            indexer = maybe_convert_indices(indexer, length)
        return "fancy", indexer, len(indexer)
                                                                                                                                                                                                                                                                                                                                   t,szablon:!(t) e,edytor:Nie mona doda folderu rozwizania {0} do rozwizania, poniewa folder rozwizania o tym samym unikatowym identyfikatorze ju istnieje.OglneMProjekt wymaga systemu Windows 8.1 lub nowszy aby mg zosta zaadowany.Okrelona lokalizacja znajduje si na nieprawidowym dysku lub dysku tylko do odczytu lub zawiera nazw urzdzenia zarezerwowan dla systemu.Nazwy folderw rozwizania nie mog:
 zawiera adnego z nastpujcych znakw: / ? : & \ * " < > | # %
  zawiera znakw kontrolnych Unicode
  zawiera znakw zastpczych
 by zarezerwowan nazw systemow, zawierajc CON, AUX, PRN, COM1 lub LPT2
 by znakami '.' lub '..'

Wprowad prawidow nazw.Nazwy katalogw nie mog zawiera adnego z nastpujcych znakw: 

		:  *  ?  |  ""  <  >

 Wprowad poprawn lokalizacj.Nazwy projektw i rozwiza nie mog:
 zawiera adnego z nastpujcych znakw: / ? : & \ * "" < > | # %
 zawiera znakw kontrolnych Unicode
 zawiera nieprawidowych znaki zastpczych
 by nazwami zarezerwowanymi systemu, w tym CON, AUX, PRN, COM1 lub LPT2
 by znakami . lub ..

Wprowad prawidow nazw.NNie mona otworzy pliku, do ktrego odwouje si plik skrtu {0}.+Trwa adowanie pliku projektu {0}...Trwa otwieranie rozwizania...*adowanie pliku rozwizania {0}...Zlokalizuj plik projektuOstrzeenie: Kopia zapasowa pliku projektu jest tworzona w ciece wzgldnej, ktra rwni si od oryginalnej cieki wzgldnej rozwizania. Rnica w hierarchii folderw moe tworzy problemy w otwieraniu lub kompilowaniu kopii zapasowej rozwizania i projektu.-Bd podczas tworzenia kopii zapasowej: {0}6Bd podczas tworzenia katalogu kopii zapasowej: {0}1Bd podczas zapisywania migrowanego pliku: {0}4Pomylnie utworzono kopi zapasow pliku jako {0}Nie przeprowadzono migracjiIMigracja nie jest wymagana. Te projekty zostan otwarte bez modyfikacji.2Migracja rozwizania zostaa wykonana pomylnie&Plik rozwizania nie wymaga migracji.Nazwa projektu.(Nazwa)XNie mona otworzy dokumentu. Zmieniono mu nazw, zosta usunity lub przeniesiony.Rne plikiWaciwoci projektukNie mona otworzy pliku lub folderu {0}. Czy chcesz usun odwoania do niego z ostatnich list?BBiecy projekt musi zosta zapisany przed dodawaniem projektu.<Chcesz zapisa czy odrzuci zmiany w biecym projekcie??Chcesz zapisa czy odrzuci zmiany w biecym rozwizaniu?kMusisz wybra czy zapisa, czy odrzuci zmiany w biecym projekcie przed utworzeniem nowego projektu.`Aby mona byo wywietli plik {0}, naley go zapisa. Czy chcesz zapisa go teraz?Wersja wybranego rozwizania jest wysza ni wersja obsugiwana przez biece wydanie pakietu Visual Studio. Sprbuj pobra najnowszy dodatek service pack dla biecego wydania programu Visual Studio lub otwrz w nowszej wersji programu Visual Studio, jeli jest dostpna.	Nowy plik0Aplikacja dla projektu nie jest zainstalowana.
tPlik projektu lub sie Web zostay przeniesione, zmieniono im nazw lub nie znajduj si na Twoim komputerze.
Nie mona otworzy elementu {0}, poniewa jego typ projektu ({1}) nie jest obsugiwany przez t wersj aplikacji. 

Aby go otworzy, uyj wersji obsugujcej ten typ projektu.UNiektre z waciwoci skojarzonych z rozwizaniem nie mogy zosta odczytane.8Wybrany plik nie jest prawidowym plikiem rozwizania.Pliki rozwizania nie mog by otwierane z sieci Web. Wybierz rozwizanie zapisane w lokalizacji lokalnej lub na dysku UNC.aNie mona otworzy pliku projektu {0}.

Nie jest dostpna obsuga tego typu projektu.Otwrz plikfNie mona otworzy pliku. Nazwy plikw nie mog przekracza {0} znakw, w tym penej cieki.Otwrz plik z sieci Web>Wprowad adres URL serwera, z ktrego chcesz otworzy plik:nProjekt z okrelon nazw ju istnieje na dysku. Czy chcesz nadpisa istniejcy projekt nowym projektem?Rozwizanie o okrelonej nazwie ju istnieje na dysku w okrelonej lokalizacji. Czy chcesz nadpisa istniejce rozwizanie nowym?NPlik {0} ju istnieje. Czy chcesz zastpi go elementem rozwizania?GTen projekt jest niezgodny z biec edycj programu Visual Studio.^Plik projektu {0} pochodzi z poprzedniej wersji tej aplikacji i musi zosta zmigrowany.tFoldery nie mog by opuszczane lub wklejane jako elementy rozwizania. Wybierz pojedynczy dokument zamiast tego.YNie mona utworzy projektu, poniewa inny projekt ju istnieje w folderze {0}.\Nazwa pliku projektu {0} zostaa zmieniona lub nie znajduje si ju w rozwizaniu.Migracja co najmniej jednego projektu nie powioda si. Te projekty zostay teraz zwolnione i oznaczone w Eksploratorze rozwiza jako niedostpne. Zaaduj ponownie te projekty w celu ustalenia przyczyny.Program Visual Studio musi wprowadzi zmiany niefunkcjonalne w tym projekcie w celu umoliwienia otwarcia go w programach Visual Studio nowszych ni Visual Studio 2010 z dodatkiem SP1 bez wpywu na dziaanie projektw.Program Visual Studio wprowadzi zmiany niefunkcjonalne w tym projekcie w celu umoliwienia otwarcia go w programach Visual Studio nowszych ni Visual Studio 2010 z dodatkiem SP1 bez wpywu na dziaanie projektw.Eksplorator projektu!Aplikacja nie jest zainstalowana.Nie mona doda projektu {0} do rozwizania, poniewa projekt o tej samej nazwie pliku projektu ju istnieje w rozwizaniu.Trwa inicjowanie projektu.#Plik projektu jest adowany w tle.!Plik projektu zosta wykluczony.-Plik projektu jest adowany asynchronicznie.#Plik projektu zaaduje si w tle.JPlik projektu zostanie automatycznie zaadowany jeli bdzie potrzebny.5Rozwizanie zawiera ju element o nazwie {0}.eNie mona doda projektu {0} do rozwizania, poniewa jest on ju skadow rozwizania.Nie mona doda projektu {0} do rozwizania, poniewa istnieje on ju w rozwizaniu w ukrytym folderze rozwizania.sProjekt wymaga danych wprowadzonych przez uytkownika. Ponownie zaaduj projekt, aby uzyska wicej informacji.,Nie znaleziono pliku projektu lub sieci Web.,Plik projektu nie moe zosta zaadowany. Plik projektu zosta zwolniony.Projekt {0} zosta zmodyfikowany poza rodowiskiem.

Nacinij pozycj Zaaduj ponownie, aby zaadowa zaktualizowany projekt z dysku.
Nacinij pozycj Zaaduj ponownie wszystko po zakoczeniu wszystkich zewntrznych zmian i operacji, aby zaadowa ponownie wszystkie elementy z dysku.
Nacinij pozycj Ignoruj, aby zignorowa zewntrzne zmiany. Zmiany zostan uyte przy nastpnym otwarciu projektu.Rozwizanie {0} zostao zmodyfikowane poza rodowiskiem.

Przeaduj ponownie, aby zaadowa zaktualizowane rozwizanie z pliku disk.
Nacinij pozycj Ignoruj, aby zignorowa zmiany zewntrzne. Zmiany zostan uyte przy nastpnym otwarciu rozwizania.Projekt {0} zosta zmodyfikowany poza rodowiskiem i istniej niezapisane zmiany w projekcie.

Nacinij pozycj Zapisz jako, aby zapisa niezapisane zmiany i zaadowa zaktualizowany projekt z dysku.
Nacinij pozycj Odrzu, aby odrzuci niezapisane zmiany i zaadowa zaktualizowane zmiany z dysku.
Nacinij pozycj Zastp, aby zastpi zewntrzne zmiany swoimi.
Nacinij pozycj Ignoruj, aby zignorowa zewntrzne zmiany. Jeli zamkniesz i ponownie otworzysz projekt, Twoje zmiany mog zosta utracone.Rozwizanie {0} zostao zmodyfikowane poza rodowiskiem i istniej niezapisane zmiany w rozwizaniu.

Nacinij przycisk Zapisz jako, aby zapisa niezapisane zmiany i zaadowa zaktualizowane rozwizanie z dysku.
Nacinij przycisk Odrzu, aby odrzuci niezapisane zmiany i zaadowa zaktualizowane rozwizanie z dysku.
Nacinij pozycj Zastp, aby zastpi zmiany zewntrzne zmianami przeprowadzonymi przez Ciebie.
Nacinij pozycj Ignoruj, aby zignorowa zmiany zewntrzne. Twoje zmiany mog zosta utracone, jeli zamkniesz i otworzysz ponownie rozwizanie.3Zaa&duj ponownie projekty w folderze rozwizania3Trwa ponowne adowanie pliku projektu {0}...7Trwa ponowne adowanie pliku rozwizania {0}...xNie mona zaadowa pliku projektu {0}. Czy chcesz usun projekt z moliwoci zwolnienia z rozwizania?Uruchomienie instalacji wymaganego skadnika zakoczyo si bdem. Nie mona prawidowo zaadowa wybranego projektu.W co najmniej jednym z otwartych dokumentw istniej niezapisane zmiany. Czy chcesz zapisa niezatwierdzone zmiany przed kontynuowaniem pracy?Zapisz kopi jakoElementw zachowanychZapisz plik jako|Plik {0} jest otwarty w edytorze z niezapisanymi zmianami. Czy chcesz zapisa zmiany przed wywietleniem tego pliku?Kompilacja anulowanaKompilacja nie powioda siKompilacja rozpocza siKompilacja powioda siCzyszczenie anulowaneCzyszczenie nie powiodo siOczyszczanie rozpoczteCzyszczenie powiodo siWdroenie anulowaneWdroenie nie powiodo siWdraanie rozpoczteWdroenie powiodo siPublikacja anulowanaPublikacja nie powioda siPublikacja rozpocztaPublikacja powioda si&Ponownie skompiluj wszystkie anulowane%Ponowna kompilacja nie powioda si!Ponowna kompilacja rozpoczta...!Ponowna kompilacja powioda siNazwa folderu rozwizania.(Nazwa)Ostatnim razem, gdy to rozwizanie byo adowane, napotkano bd podczas otwierania powizanych dokumentw. adowanie dokumentu zostanie pominite podczas adowania rozwizania w celu uniknicia tego bdu.7Foldery rozwizania nie s obsugiwane w tej wersji. Pominita kompilacja: Projekt: !Kompilacja rozpoczta: Projekt: ~========== Kompilacja: powiodo si  {0}, nie powiodo si  {1}, zaktualizowane {2} pominito  {3} ========
z========== Kompilacja: powiodo si lub zaktualizowane  {0}, nie powiodo si {1}, pominito  {2} ========
, Konfiguracja: !Pominite czyszczenie: Projekt: "Czyszczenie rozpoczte: Projekt: i========== Czyszczenie: powiodo si  {0}, nie powiodo si  {1}, pominito  {2} ========
tWystpiy bdy kompilacji. Czy chcesz kontynuowa i uruchomi ostatni kompilacj zakoczon powodzeniem? Pominite wdroenie: Projekt: !Wdraanie rozpoczte: Projekt: h========== Wdraanie: powiodo si  {0}, nie powiodo si  {1}, pominito  {2} ========
Rozpoczto kompilacj...
Rozpoczto oczyszczanie...
%Rozpoczto ponown kompilacj...
&Ten projekt jest nieaktualny:Czy chcesz go skompilowa?Publikacja pominita: Projekt !Publikacja rozpoczta: Projekt: j========== Publikowanie: powiodo si  {0}, nie powiodo si  {1}, pominito  {2} ========
+Pominite odbudowanie wszystkiego: Projekt,Odbudowanie wszystkiego rozpoczte: Projekt|========== Ponowna kompilacja wszystkiego: powiodo si  {0}, nie powiodo si  {1}, pominito  {2} ========
MProjekt nie zosta wybrany do kompilowania dla tej konfiguracji rozwizaniaadowanie projektw jest wymagane do zakoczenia danej akcji. Po wciniciu przyciski Anuluj, adowanie projektu bdzie kontynuowane w tle i moliwe bdzie wykonanie akcji pniej.-Ponowne adowanie zaznaczonych projektw...)Wyadowywanie zaznaczonych projektw...%adowanie projektw rozwizania...Dodawanie projektu {0} z{1}:Migrowanie {0} projektu z {1}:Przygotowywanie rozwizania...adowanie {0} projektu z {1}:Usuwanie projektu {0} z {1}:Zwalnianie {0} projektu z {1}:9Aktualizowanie elementu nadrzdnego projektu {0} z{1}:ATrwa wykonywanie migracji projektw i elementw rozwizania...	NewFolderElementy rozwizaniaWaciwoci folderuPlik rozwizania {0} pochodzi z poprzedniej wersji tej aplikacji i musi zosta zmigrowany w celu skompilowania w tej wersji aplikacji. Aby przeprowadzi migracj rozwizania, otwrz rozwizanie w tej wersji aplikacji.Nie mona migrowa pliku rozwizania {0}, poniewa jest on tylko do odczytu na dysku. Aby przeprowadzi migracj rozwizania, zmie uprawnienia w pliku rozwizania, aby zezwoli na modyfikacj i otwrz je ponownie.Nie mona migrowa pliku rozwizania {0}, poniewa nie mona wyewidencjonowa rozwizania z kontroli kodu rdowego. Aby przeprowadzi migracj rozwizania, upewnij si, e plik rozwizania mona wyewidencjonowa i otworzy go ponownie.Nie mona zmigrowa pliku rozwizania {0}, poniewa nie mona go zmodyfikowa. Aby przeprowadzi migracj rozwizania, zmie uprawnienia w pliku rozwizania, aby zezwoli na modyfikacj i otwrz je ponownie.Rozwizanie {0} wymaga migracji i dlatego nie mona go doda do obecnie otwartego rozwizania.  Otwrz rozwizanie przed dodaniem go lub dodaj projekty indywidualnie do biecego rozwizania.bPlik rozwizania {0} pochodzi z poprzedniej wersji tej aplikacji i musi zosta zmigrowany.Eksplorator rozwizaWystpiy bdy konwersji znakw podczas zapisywania pliku rozwizania {0}. Zapisz plik rozwizania w formacie Unicode lub UTF-8, uywajc polecenia Zapisz jako i wybierajc format z listy Zapisz jako typ.Plik rozwizania {0} nie zosta pomylnie zapisany. Sprawd, czy lokalizacja jest dostpna, plik mona zapisa i jest wystarczajco duo miejsca na dysku.6Element rozwizania o nazwie {0} ju istnieje.6Rozwizanie {0} {1}({2}  {3} projekty)=Rozwizanie {0} {1}({2} - {3} z {4} projektw )=Rozwizanie :{0} {1}({2}  {3} z projektu {4}))Rozwizanie {0} {1}(adowanie...)(Rozwizanie {0} {1}({2} projekty)0Rozwizanie {0} {1}({2} z {3} projektw),Rozwizanie {0} {1}({2} projektu {3})Dugo nazwy dla rozwizania spowoduje, e cieka przekroczy maksymaln dugo cieki dopuszczan przez system. Musisz zredukowa dugo nazwy.kPlik rozwizania UTF-8 (*{0})
*{1}
Unicode Solution File (*{2})
*{3}
ANSI Solution File (*{4})
*{5}
Jeden lub wicej projektw w rozwizaniu nie zostay poprawnie zaadowane.
Zobacz okno Dane wyjciowe, aby uzyska szczegy.RozwizaniejAby zaadowa ponownie ten projekt, musisz zatrzyma debugowanie.

Czy chcesz zatrzyma debugowanie?{0} (zwolniony){0} (adowanie){0} (zwolniony){0} (niezgodne){0} (inicjowanie)#{0} (adowanie nie powiodo si){0} (wymaga migracji){0} (brak dostpu){0} (nie znaleziono){0} (adowanie){0} (oczekujce)Rozwizanie {0}Plik tekstowy|Ignoruj
Nie podnosi uprawnie uytkownika i kontynuuje uruchamianie tej aplikacji w ramach biecych praw uytkownika.Uruchom ponownie t aplikacj pod rnymi powiadczeniami
Zapisuje biece zmiany, a nastpnie ponownie uruchamia aplikacj. Zostanie wywietlony monit o zmian konta uytkownika.Rozwizanie lub projekt, ktry chcesz otworzy jest zlokalizowane w katalogu, w ktrym ta aplikacja nie ma uprawnienia do pracy. Jeli przyznasz uprawnienie poprzez uycie funkcji Kontroli konta uytkownika Twojego systemu operacyjnego, aplikacja bdzie w stanie zakoczy dane zadania.HCzy chcesz uruchomi ponownie aplikacj z podniesionymi uprawnieniami?DMicrosoft Visual Studio // To jest ok, aby mie Visual StudioWNie znaleziono okrelonego szablonu. Upewnij si, e pena cieka jest poprawna.ROkrelony szablon nie jest prawidowy. Uyj szablonu rozwizania lub projektu.Dodaj istniejcy projektZamknij projektZamknij rozwizanieNowy projektDugo penej cieki do rozwizania, projektu lub elementu, ktry tworzysz przekracza maksymaln dugo dopuszczaln przez system. Naley zmniejszy dugo nazwy bd lokalizacj.HNie udao si otworzy pliku projektu. Napotkano nieoczekiwany bdNieznany bd#Waciwoci zwolnionego projektu)Zwolnij pro&jekty w folderze rozwizania+Trwa zwalnianie pliku projektu {0}.../Trwa zwalnianie pliku rozwizania {0}...RozwizanieNazwa projektu.,Pena cieka do pliku projektu na dysku.DataNumer dziennikaPlik projektuRozwizaniePlik rozwizaniaGodzinaPlik opcji uytkownikaNie odnaleziono aplikacji, na ktrej jest oparty ten typ projektu. Kliknij nastpujce cze, aby uzyska wicej informacji: Nie mona ukoczy operacji. Nie mona migrowa pliku projektu {0}. Zobacz raport migracji, aby uzyska szczegowe informacje.(Nazwa)cieka plikuTemplates\ItemTemplatesTen projekt wymaga migracji.Szablony\ProjectTemplatesKompilacja zostaa anulowana.Projekty_Okrelony adres URL nie zosta znaleziony, lub nie masz wystarczajcych uprawnie dostpu.mNie mona doda programu Project jako zalenoci, co spowoduje powstanie zalenoci kompilacji cyklu
.:        lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADPtWf	M81VPq #A0IN%eQN^C!"">#G,7:=C?kAVxMVZ>MDdv}vW
Y}      ~      =   @      e  H      z   ^  C                _       j  7  8A l l R e s o u r c e s B o u n d D e s c r i p t i o n     8A l l R e s o u r c e s B o u n d D i s p l a y N a m e    LC o m p i l e D i r e c t 2 D C u s t o m E f f e c t D e s c r i p t i o n   LC o m p i l e D i r e c t 2 D C u s t o m E f f e c t D i s p l a y N a m e   >D i s a b l e O p t i m i z a t i o n s D e s c r i p t i o n   >D i s a b l e O p t i m i z a t i o n s D i s p l a y N a m e   JE n a b l e D e b u g g i n g I n f o r m a t i o n D e s c r i p t i o n   JE n a b l e D e b u g g i n g I n f o r m a t i o n D i s p l a y N a m e   HE n a b l e U n b o u n d e d D e s c r i p t o r D e s c r i p t i o n ,  HE n a b l e U n b o u n d e d D e s c r i p t o r D i s p l a y N a m e   2E n t r y p o i n t N a m e D e s c r i p t i o n )  2E n t r y p o i n t N a m e D i s p l a y N a m e s  H L S L C a t e g o r y   (H L S L F o r m a t L i s t S t r i n g   N o D i s p l a y N a m e   DP r e p r o c e s s o r D e f i n i t i o n s D e s c r i p t i o n   DP r e p r o c e s s o r D e f i n i t i o n s D i s p l a y N a m e   6S e t R o o t S i g n a t u r e D e s c r i p t i o n   6S e t R o o t S i g n a t u r e D i s p l a y N a m e   ,S h a d e r M o d e l D e s c r i p t i o n   ,S h a d e r M o d e l D i s p l a y N a m e i  >Y e s A l l R e s o u r c e s B o u n d D i s p l a y N a m e   BY e s D i s a b l e O p t i m i z a t i o n D i s p l a y N a m e   Y e s D i s p l a y N a m e   BY e s E n a b l e D e b u g g i n g I n f o D i s p l a y N a m e   XY e s E n a b l e U n b o u n d e d D e s c r i p t o r T a b l e D i s p l a y N a m e   <Y e s S e t R o o t S i g n a t u r e D i s p l a y N a m e   Kompilator przyjmie, ze wszystkie zasoby, ktre program do cieniowania moe przywoa, s powizane i w dobrym stanie podczas wykonywania programu do cieniowania (/all_resources_bound). Dostpne w przypadku modelu cieniowania 5.1 i nowszych.Wszystkie zasoby s powizaneSkompiluj niestandardowy efekt programu Direct2D, ktry zawiera cieniowanie pikseli. Nie uywaj dla efektu wierzchokw ani niestandardowego efektu obliczeniowego.DSkompiluj niestandardowy efekt cieniowania pikseli programu Direct2DWycz optymalizacje. Parametr /Od powoduje przyjcie, e podano take parametr /Gfp, lecz dane wyjciowe mog nie by dokadnie takie same jak w przypadku uycia parametrw /Od i /Gfp.Wycz optymalizacjeWcz informacje debugowania.Wcz informacje debugowaniaPoinformuj kompilator, e program do cieniowania moe zawiera deklaracj tablicy zasobw z niepowizanym zakresem (/enable_unbounded_descriptor_tables). Dostpne w przypadku modelu cieniowania 5.1 i nowszych. Wcz niepowizany deskryptorHOkrela nazw punktu wejcia dla programu do cieniowania (/E[nazwa]).Nazwa punktu wejciaHLSLPlik HLSL (*.hlsl)NieCDefiniuje symbole przetwarzania wstpnego dla pliku rdowego.Definicje preprocesoraDocz sygnatur gwn do kodu bajtowego programu do cieniowania (/setrootsignature). Dostpne w przypadku modelu cieniowania 5.0 i nowszych.Ustaw sygnatur gwnOkrela model programu do cieniowania. Niektrych typw programw do cieniowania mona uy tylko z najnowszymi modelami programw do cieniowania (/T[typ]_[model]).Model programu do cieniowaniaTak (/all_resources_bound)	Tak (/Od)Tak	Tak (/Zi))Tak (/enable_unbounded_descriptor_tables)Tak (/setrootsignature)y        lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADP	'*V
2{=v9                  4A n c h o r T i t l e A t t a c h T o P r o c e s s     DA n c h o r T i t l e M u l t i p l e S t a r t u p P r o j e c t s    >A n c h o r T i t l e S i n g l e S t a r t u p P r o j e c t )   2A n c h o r T i t l e S t a r t D e b u g g i n g I   BA n c h o r T i t l e S t a r t D e b u g g i n g O n T a r g e t U   Docz...Ustaw projekty startowe...Waciwoci debugowania {0}
Rozpocznij{0}        lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADP7       S e r v i c e N o t F o u n d     !Nie mona znale usugi {0}.        lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADPmW      V0 d 3 9 e 9 e 0 - b a 0 e - 4 e 2 0 - 9 c 7 c - 3 d e 2 7 1 c d 2 3 7 8 . C T M E N U      k  CFCT           l&   07  Tv	
  


	 yx
xx  	



  	 	 	 

	 
  	 
 
 		whx
 
      	     u       f   
 pU
f
 pg  g   
  
                                    g7g,4$:>IUi:,*7#oSU[q/m39N{Z;&cVw|5>[Xm6N^=m;AOki1}_&w8KuzJ	`S~sSfs@b}#Mu]sd1,OqoV|-l[w~/-F_EGW.as Ez!%<Qp!DBtRGI|>2p'T)RI`FZ
+cHBrYQS!tl7er$AS,xX|N>(~*3`K)r,Bf$R`V|i{("!B@8C@ C4
4P<|@h!$!0%$+JR*;)fi"B:__1Qn#LZy7+0`v$)L uNGb([/TM7'L:j,`)TOHA>z

/D	2:B	V]0T 	Y %sn6SRpi#Z		
  d`z]0}T
M LXT+bejO)r
"ioaT#h  UJ%2/_aw|D(vSje2(i/[eWCB!#r9L!r0HrRXH=,!2g-(5+9b RrrK~I5@qqeAP[YI+B>U'\H& 8U D HG+D
H9NSGO,)<@2EgH8

@{3cT<A,-C@6 7y7x0yivpaj! <<cp Q SCO`y2k.)pgd-08h`L"4L&8 88(FSX#*G0@z-"Uz`@:0  `m  L+&Uy/x?H~B?j hcA+1iyl                            lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet          PADPADP8zCTc
CjI`*jlu      O  !        X  zp e r f o r m a n c e r e p o r t i n g / s e t t i n g s / b u i l d p e r f o p t i o n p a g e c o n t r o l . b a m l     tp r o j e c t c o m p a t i b i l i t y d l g / p r o j e c t c o m p a t i b i l i t y d l g w i n d o w . b a m l /  Rs o l u t i o n f i l t e r s / s o l u t i o n f i l t e r d i a l o g . b a m l &  Rs o l u t i o n f i l t e r s / s o l u t i o n f i l t e r w i d g e t . b a m l 53  vt r a c k p r o j e c t r e t a r g e t i n g / u i / p r o j e c t r e t a r g e t i n g d l g w i n d o w . b a m l &P  Nv s s e t t i n g s / p r o f i l e s e t t i n g s t r e e v i e w . b a m l {  !*     M S B A M L   `   `   `   h  dMicrosoft.VisualStudio.CommonIDE, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aS.clr-namespace:Microsoft.VisualStudio.CommonIDE Microsoft.VisualStudio.CommonIDE  Lclr-namespace:Microsoft.VisualStudio.CommonIDE.PerformanceReporting.Settings>Microsoft.VisualStudio.CommonIDE.PerformanceReporting.Settings  _    YMicrosoft.VisualStudio.CommonIDE.PerformanceReporting.Settings.BuildPerfOptionPageControl   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  4r.clr-namespace:Microsoft.VisualStudio.CommonIDE  UbaseLclr-namespace:Microsoft.VisualStudio.CommonIDE.PerformanceReporting.Settings  . $
Auto=. .+ BuildPerformanceGroupBox9  3Microsoft.VisualStudio.CommonIDE.CommonIDEResources%    BuildPerformanceGroupBox_Title#Z  .   Orientation$ Vertical=.+ -    Name$ BuildPerformanceSettingGeneral_BuildPerformance!   BuildPerformanceItemSource#Z $0q!"     M S B A M L   `   `   `   i  eMicrosoft.VisualStudio.Shell.15.0, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0!Microsoft.VisualStudio.PlatformUI  h dMicrosoft.VisualStudio.CommonIDE, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a_4clr-namespace:Microsoft.VisualStudio.CommonIDE.Utils&Microsoft.VisualStudio.CommonIDE.Utils Fclr-namespace:Microsoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg8Microsoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg \   VMicrosoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg.ProjectCompatibilityDlgWindow   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  auiZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0  >utils4clr-namespace:Microsoft.VisualStudio.CommonIDE.Utils  NpcdFclr-namespace:Microsoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg  -   $ProjectCompatibilityDlgProjectCompatibilityDlg   Title$-  'Przegld zmian projektu i rozwizania$	700$	640$	500$	350  SizeToContent$ Height=  
ResizeMode$ 	CanResize=8   2Microsoft.VisualStudio.PlatformUI.DialogWindowBase   HasHelpButton .   WindowStartupLocation$ CenterOwner=  ShowInTaskbar .    	Resources     BooleanToVisibilityConverterI CMicrosoft.VisualStudio.CommonIDE.Utils.GroupHeaderFontSizeConverter   GroupHeaderFontSizeConverterl  fMicrosoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg.ProjectCompatibilityGroupDescriptionConverter 1 -ProjectCompatibilityGroupDescriptionConverterl  fMicrosoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg.ProjectCompatibilityGroupDisplayNameConverter 1 -ProjectCompatibilityGroupDisplayNameConvertert  nMicrosoft.VisualStudio.CommonIDE.ProjectCompatibilityDlg.ProjectCompatibilityDialogGroupHeaderTemplateSelector 9 5ProjectCompatibilityDialogGroupHeaderTemplateSelector  hyperLinkStyle  
TargetType  Property9   3Microsoft.VisualStudio.PlatformUI.EnvironmentColors	   ControlLinkTextBrushKey
  Value  Triggers P Property P Value#   ControlLinkTextHoverBrushKey  DialogButtonStyle  DialogTextBlockStyle  ListBoxStyle"   ControlEditHintTextBrushKey  	 CollapsedGridViewHeaderStyle 
 GroupContainerStyle  GroupHeaderTemplate1  RowDefinitions  ColumnDefinitions  Path  	Converter  ElementName  ConverterParameter  GroupHeaderTemplate2  ListBoxContainerTemplate  
TargetType Name J SnapsToDevicePixels  Padding Name  Triggers  
TargetName1   *CommandBarMouseDownBackgroundBeginBrushKey&   CommandBarTextMouseDownBrushKey  ListCellTemplate ^ ShowOnDisabled   ToolTip! d 	IsChecked"  Mode#  UpdateSourceTriggerW SPresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e354  .System.Windows.Automation.AutomationProperties$   Name%z  &	        &	 (     &	 T     &	      &	      &	     &	     &	     &	     &		 D    &	
     &	     7  7  7  &	 ^    7  7  7  &	     &	     7    "BooleanToVisibilityConverter_1  &"pcd:GroupHeaderFontSizeConverter_1  73pcd:ProjectCompatibilityGroupDescriptionConverter_1  73pcd:ProjectCompatibilityGroupDisplayNameConverter_1  ?;pcd:ProjectCompatibilityDialogGroupHeaderTemplateSelector_1 HyperlinkStyle" . 
Setter_0_1  #
  	  P Trigger_0_1 @IsMouseOver . .  
Setter_0_2  #
    Style_4" . Setter_4  $
 75 Setter_5  $
 23 Style_5" . Setter_6  $
 
12,12,12,9q Setter_7  $
 WrapWithOverflow= Setter_8  $
 CharacterEllipsis= Style_6" . 	Setter_10  $
 Disabled= 	Setter_11  $
 0,1,0,1q 	Setter_12  #
    Style_7" . 	Setter_14  y$
 	Collapsed= Style_8" . 	Setter_15  $
 	-5,0,0,14q DataTemplate_1.R 
Grid_4$	14,6,12,6q  RowDefinition_6 RowDefinition_7  ColumnDefinition_6$* .+ $0$0TextBlock_1$CharacterEllipsis= $ .8    $ ProjectCompatibilityDlg$ FontSize8  $
 1.40 $1$0TextBlock_2$0,6,0,0q$
Wrap=
  $ .8   DataTemplate_3.R 
Grid_3$	14,6,12,6q  RowDefinition_8 RowDefinition_9  ColumnDefinition_9$* .+ $0$0TextBlock_3$CharacterEllipsis= $ .8    $ ProjectCompatibilityDlg$ FontSize8  $
 1.40 $1$0TextBlock_4$0,6,0,0q$
Wrap= $ .8   ControlTemplate_1" .R $ ContainerBorderContainerBorder . #z#z#z# z._ $ contentPresentercontentPresenter#z#z# z  P 	Trigger_1 @
IsSelected . .  	Setter_23$ ContainerBorder#
      	Setter_24#
     P 	Trigger_2 @
IsSelected .  .  	Setter_25$ ContainerBorder  

  P 	Trigger_3  { .  .  	Setter_27
 Z    DataTemplate_2.R 
Grid_2 .    *ProjectFullPath+  ColumnDefinition_7$
Auto  ColumnDefinition_8$* .+ -   
CheckBox_1$0.  $Center=$9,0,0,0q!  $ Status$" TwoWay=$# PropertyChanged=$  *ProjectName+y *CanUserConfigureConversion+8    TextBlock_3$1$CharacterEllipsis=$NoWrap=$Center=$9,0,0,0q *ProjectDisplayPath+. 
Grid_1  RowDefinition_1$
Auto  RowDefinition_2$*  RowDefinition_3$
Auto  RowDefinition_4$
Auto  RowDefinition_5$
Auto   ColumnDefinition_1$*  ColumnDefinition_2$
Auto  ColumnDefinition_3$
Auto .+ TextBlock_4$0$3#[ 
 	Run_1.Te projekty nie s obsugiwane lub potrzebuj modyfikacji wpywajcych na ich zachowanie, aby otworzy je w tej wersji programu Visual Studio. Projekty nie wywietlone nie wymagaj adnych zmian lub zostan automatycznie zmodyfikowane w sposb nie wpywajcy na zachowanie. Aby uzyska wicej szczegw, zobacz  -   Hyperlink_1%   	AccessKey$% F1#[ \ XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35-  'System.Windows.Input.KeyboardNavigation&   TabIndex$& 0.Wicej informacji. -   ' Name$' itemListViewitemListView$1$3$& 10#[ #[ (  SelectionMode$( Extended=)  FocusVisualStyle) Z  *
Projects+ %  '       7   Style_9" . 	Setter_16 @
IsSelected
  $ 
IsSelected$" TwoWay= 	Setter_17 @ Name
  *ProjectName+ 	Setter_18  {
  *CanUserConfigureConversion+ 	Setter_19  $	
 0,2q 	Setter_20  $
 0q 	Setter_21 @ToolTip
  *ProjectFullPath+ 	Setter_22 @^ShowOnDisabled
 .  	Setter_28  8
   *  ContextMenu*  ContextMenu_1.@m 
MenuItem_1$_Kopiuj informacje+ m Command+  **(CopyUpgradeInformationToClipboardCommand+,  
GroupStyle, (	  "System.Windows.Controls.GroupStyle	  GroupStyle_1- 	  HeaderTemplateSelector#- [ . 	  ContainerStyle#. [
  TextBlock_5$3$3$0#[ $WrapWithOverflow=$	12,9,12,9q
 	Run_2.A?Informacje zostan zapisane do pliku dziennika uaktualnienia w  Hyperlink_3#[ $& 30/  Command/  *OpenSolutionDirectoryCommand+.katalog rozwizania. Button_1$4$0#[ $
Left=$	Top=$	110$23$& 35$12,0,0,0q **(CopyUpgradeInformationToClipboardCommand+.Kopiuj informacj Button_2$4$1#[ $& 400  	IsDefault0 . $0,0,9,12q$% Wyjd *ContinueCommand+{ *IsOkEnabled+.OK Button_3$4$2#[ $& 501  IsCancel1 . $	0,0,12,12q$% Enter *CancelCommand+.Anuluj!h     M S B A M L   `   `   `   i  eMicrosoft.VisualStudio.Shell.15.0, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0!Microsoft.VisualStudio.PlatformUI  h dMicrosoft.VisualStudio.CommonIDE, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3as>clr-namespace:Microsoft.VisualStudio.CommonIDE.SolutionFilters0Microsoft.VisualStudio.CommonIDE.SolutionFilters vUclr-namespace:Microsoft.VisualStudio.Shell;assembly=Microsoft.VisualStudio.Shell.15.0Microsoft.VisualStudio.Shell  S.clr-namespace:Microsoft.VisualStudio.CommonIDE Microsoft.VisualStudio.CommonIDE K   EMicrosoft.VisualStudio.CommonIDE.SolutionFilters.SolutionFilterDialog   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  Bmc;http://schemas.openxmlformats.org/markup-compatibility/2006  8d2http://schemas.microsoft.com/expression/blend/2008  cvsuiZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0  Hlocal>clr-namespace:Microsoft.VisualStudio.CommonIDE.SolutionFilters  avsshellUclr-namespace:Microsoft.VisualStudio.Shell;assembly=Microsoft.VisualStudio.Shell.15.0  CCommonIDEPackage.clr-namespace:Microsoft.VisualStudio.CommonIDE  9   3Microsoft.VisualStudio.PlatformUI.EnvironmentColors#    ToolWindowBackgroundBrushKey#      ToolWindowTextBrushKey#    WindowStartupLocation$ CenterScreen=  WindowStyle$
 None=  
ResizeMode$ NoResize=8   2Microsoft.VisualStudio.PlatformUI.DialogWindowBase   HasDialogFrame .    ShowInTaskbar .    ShowActivated .    SizeToContent$ WidthAndHeight=$	200$	300$	200$	300$	600. WindowBorder,	   %MainWindowActiveDefaultBorderBrushKey# 	 $1q._ 
  RowDefinitions
  LayoutGridRow_1$
Auto  LayoutGridRow_2$
Auto .+ -   $CaptionLabel$0$34$8,0,8,0q$Stretch=$Stretch=$
Left=$Center=9 3Microsoft.VisualStudio.CommonIDE.CommonIDEResources   MicrosoftVisualStudio#Z *   #MainWindowActiveCaptionTextBrushKey#  &   MainWindowActiveCaptionBrushKey#  #Z#Z#Z $1$	166.+   Orientation$ Vertical=$20,20,20,10q.+ -   $
Body#     FilterDialogBody#Z $
Left=$
Wrap=$	Top= -   $
ActionText#     FilterDialogAction#Z $
Left=$
Wrap=$	Top=$0,20,0,0q  -    Name$
 Link1   +Microsoft.VisualStudio.Shell.VsResourceKeys$   ThemedDialogHyperlinkStyleKey#  .. -   $LinkText   FilterDialogLink#Z  $ 
Horizontal=$Right=$Bottom=$0,20,0,0q$RightToLeft=.+ -      FilterDialogLoadAll#Z    ButtonStyleKey#  $Right=$0,0,10,0q$Bottom=$	200 -   !   FilterDialogChooseProjects#Z #  $Right=$0,0,0,0q$Bottom=$	200  	IsDefault . !     M S B A M L   `   `   `   h  dMicrosoft.VisualStudio.CommonIDE, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3as>clr-namespace:Microsoft.VisualStudio.CommonIDE.SolutionFilters0Microsoft.VisualStudio.CommonIDE.SolutionFilters  S.clr-namespace:Microsoft.VisualStudio.CommonIDE Microsoft.VisualStudio.CommonIDE  i eMicrosoft.VisualStudio.Shell.15.0, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3avUclr-namespace:Microsoft.VisualStudio.Shell;assembly=Microsoft.VisualStudio.Shell.15.0Microsoft.VisualStudio.Shell Zclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0!Microsoft.VisualStudio.PlatformUI f bMicrosoft.VisualStudio.Imaging, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3awTclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImagingMicrosoft.VisualStudio.Imaging }Wclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Imaging!Microsoft.VisualStudio.PlatformUI h dMicrosoft.VisualStudio.Utilities, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aYclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Utilities!Microsoft.VisualStudio.PlatformUI k gMicrosoft.VisualStudio.ImageCatalog, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a|Yclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImageCatalogMicrosoft.VisualStudio.Imaging K    EMicrosoft.VisualStudio.CommonIDE.SolutionFilters.SolutionFilterWidget   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  Bmc;http://schemas.openxmlformats.org/markup-compatibility/2006  8d2http://schemas.microsoft.com/expression/blend/2008  Hlocal>clr-namespace:Microsoft.VisualStudio.CommonIDE.SolutionFilters  CCommonIDEPackage.clr-namespace:Microsoft.VisualStudio.CommonIDE  ^vsfxUclr-namespace:Microsoft.VisualStudio.Shell;assembly=Microsoft.VisualStudio.Shell.15.0  cvsuiZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0  `imagingTclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.Imaging  cthemingWclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Imaging  g	utilitiesYclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Utilities  ecatalogYclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImageCatalog     	Resources  M   GMicrosoft.VisualStudio.CommonIDE.SolutionFilters.TrueToVisibleConverter   trueToVisibleConverter=  7Microsoft.VisualStudio.PlatformUI.BrushToColorConverter  BrushToColorConverter%   &	        &	          .     	TreeArrow E IsFilled E 
StartPoint E IsClosed  Point  HeaderBorderStyle  
TargetTypeC  =Microsoft.VisualStudio.CommonIDE.SolutionFilters.BorderButton  	Resources  Key  Property  Value  BodyTextBrushKey	  StrokeDashArray
 J SnapsToDevicePixels  ToolbarBrushKey  FocusVisual  Triggers P Property P Value  ActionLinkBrushKey (	 $SectionCommandButtonFocusVisualStyle 
 ExpandCollapseToggleStyle9  3Microsoft.VisualStudio.PlatformUI.EnvironmentColors#   ToolWindowBackgroundBrushKey   ToolWindowTextBrushKey  
TargetType  Padding FName  UseLayoutRounding  Angle  CenterX  CenterY  Triggers  
TargetName6  0Microsoft.VisualStudio.PlatformUI.TreeViewColors!   SelectedItemActiveBrushKey ] 
Conditions  Property  Value  ButtonStyle<  6Microsoft.VisualStudio.PlatformUI.CommonControlsColors   ButtonHoverBrushKey    ButtonBorderHoverBrushKey"   ButtonBorderPressedBrushKey  ToggleButtonStyle   BasedOn!  Binding"  Path#  Value %7  &	       &	 R     7  7  7  7  &		     7  &	
     7  &	 {    &	     7  B D E  . $	 0 0& . @  $	 0 6& $	 6 0& "    FocusVisual .     .R ._ 8  $		 1 2R$1$2,2,2,-2q
 . .   8     $ 0,1,0,0q   $ 0,0,0,0q  @Padding$ 0,2,0,0q   | .   @FocusVisualStyle8    @J	AllowDrop .  P  @JIsMouseOver . .    8   .     .R 
 . $-1q8  $		 1 2R$1 " d.   | .     #      
     #      $	 1.5q     " d.R $Center=$Center=#z$20$ 5,0,10,0q._F $ 
ExpandPath$Center=$Center=#z#z#z8   . z $	 135Q$ 3Q$ 3Q P  @d	IsChecked$
 TrueY.  $ 
ExpandPath  z  $	 180Q$ 3Q$ 3Q #     P  @JIsMouseOver . .  #     ]    @JIsMouseOver .   @d	IsChecked$
 TrueY./ #      " .   #      
     $	 1.5q     " .R $	1.5q#z._  P  @JIsMouseOver . .  #      #     P    . .  #      " 8      !  $" IsShowingAllProjects$
# True.a   #   $  RowDefinitions$  $
Auto  $* .+  ._ %  ColumnDefinitions%  $
Auto  $*  $
Auto $  $
Auto  $
Auto  $
Auto .+d -   & dName$& expanderButton$0$0#[
 ' d 	IsChecked$
' TrueY(  ToolTip(  $" ExpandPanelTooltipText $1$0#  $SemiBold"$0,3,0,0q $" 
HeaderText -   $	myButtons$0$2$0,3,0,0q .R )  Orientation$) 
Horizontal=.@ -   * Name$* showAllProjectsButton#[ $0,0,5,0q(  $&"  ShowAllProjectsButtonTooltipText=  7Microsoft.VisualStudio.PlatformUI.ImageThemingUtilities+   ImageBackgroundColor+  $" 
Background,  RelativeSource,  *Self+-  	Converter#- [ ./  )Microsoft.VisualStudio.Imaging.CrispImage  -   $ShowAllProjects$18$182	  ,Microsoft.VisualStudio.Imaging.KnownMonikers. 	  DocumentCollection/   Moniker#/ Z.  -   #[ $0,0,5,0q+  $" 
Background,  *Self+#- [ .  -   $Ellipsis$18$180 	  Ellipsis#/ Z0  $1$1y $" 
IsExpanded#- [  .+ #  9
  3Microsoft.VisualStudio.CommonIDE.CommonIDEResources1 
  SelectProjectsToLoad#Z1 $0, 0, 0, 10q  -   2 Name$2 loadSelectedProjectsLink1  +Microsoft.VisualStudio.Shell.VsResourceKeys$3   ThemedDialogHyperlinkStyleKey# 3 .. -   $"loadSelectedProjectsLinkText4 
  LoadSelectedProjects#Z4   -	   $&2  loadSelectedProjectsWithDepsLink# 3 .. -
   $*$loadSelectedProjectsWithDepsLinkText+5 
  $LoadSelectedProjectsWithDependencies#Z5  $2$0$3$
0, 8, 0, 3q!+     M S B A M L   `   `   `   i  eMicrosoft.VisualStudio.Shell.15.0, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0!Microsoft.VisualStudio.PlatformUI  h dMicrosoft.VisualStudio.CommonIDE, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a_4clr-namespace:Microsoft.VisualStudio.CommonIDE.Utils&Microsoft.VisualStudio.CommonIDE.Utils f bMicrosoft.VisualStudio.Imaging, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3awTclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImagingMicrosoft.VisualStudio.Imaging k gMicrosoft.VisualStudio.ImageCatalog, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a|Yclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImageCatalogMicrosoft.VisualStudio.Imaging }Wclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Imaging!Microsoft.VisualStudio.PlatformUI Dclr-namespace:Microsoft.VisualStudio.CommonIDE.ProjectRetargeting.UI6Microsoft.VisualStudio.CommonIDE.ProjectRetargeting.UI h dMicrosoft.VisualStudio.Utilities, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3aYclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Utilities!Microsoft.VisualStudio.PlatformUI X   RMicrosoft.VisualStudio.CommonIDE.ProjectRetargeting.UI.ProjectRetargetingDlgWindow   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  auiZclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Shell.15.0  >utils4clr-namespace:Microsoft.VisualStudio.CommonIDE.Utils  `imagingTclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.Imaging  jvsimgcatalogYclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImageCatalog  cthemingWclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Imaging  MpruiDclr-namespace:Microsoft.VisualStudio.CommonIDE.ProjectRetargeting.UI  dvsutilYclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Utilities  -   $ProjectRetargetingDlgProjectRetargetingDlg$	550$	700$	550$	375$	545$	300   SizeToContent$  Height=  
ResizeMode$ 	CanResize=8   2Microsoft.VisualStudio.PlatformUI.DialogWindowBase   HasHelpButton .    WindowStartupLocation$ CenterOwner=  ShowInTaskbar .    Title  *	Caption+W SPresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e354  .System.Windows.Automation.AutomationProperties   Name  *	Caption+=  7Microsoft.VisualStudio.PlatformUI.ImageThemingUtilities   ImageBackgroundColor    Path$ 
Background	  RelativeSource	  *Self+   BrushToColorConverter
  	Converter#
 [    	Resources    BooleanToVisibilityConverterI CMicrosoft.VisualStudio.CommonIDE.Utils.GroupHeaderFontSizeConverter   GroupHeaderFontSizeConverterh bMicrosoft.VisualStudio.CommonIDE.ProjectRetargeting.UI.ProjectRetargetingGroupDescriptionConverter / +ProjectRetargetingGroupDescriptionConverter=  7Microsoft.VisualStudio.PlatformUI.BrushToColorConverter  hyperLinkStyle  
TargetType  Property9   3Microsoft.VisualStudio.PlatformUI.EnvironmentColors   ControlLinkTextBrushKey  Value  Triggers P Property P Value#   ControlLinkTextHoverBrushKey  DialogButtonStyle  DialogTextBlockStyle  ListBoxStyle"   ControlEditHintTextBrushKey   CollapsedGridViewHeaderStyle 	 GroupContainerStyle 
 GroupHeaderTemplate  RowDefinitions  ColumnDefinitions  ElementName  IsSharedSizeScope z SharedSizeGroup Name
  Tag  Target  SelectedIndex  Mode   	LabeledBy  ListBoxContainerTemplate   
TargetType! Name" J SnapsToDevicePixels#  Padding$ Name%  Triggers&  
TargetName1'   *CommandBarMouseDownBackgroundBeginBrushKey&(   CommandBarTextMouseDownBrushKey  ListCellTemplate) ^ ShowOnDisabled*  ToolTip+ d 	IsChecked,  UpdateSourceTrigger%6  &	       &	 (     &	 V     &	       &	      &	 2    &	     &	 8    &	     &		 J    &	
     7  7  &	     &	     7   "BooleanToVisibilityConverter_1  ($utils:GroupHeaderFontSizeConverter_1  40prui:ProjectRetargetingGroupDescriptionConverter   HyperlinkStyle" . 
Setter_0_1  #    P Trigger_0_1 @IsMouseOver . .  
Setter_0_2  #    Style_4" . Setter_4  $ 75 Setter_5  $ 23 Style_5" . Setter_6  $ 
12,12,12,9q Setter_7  $ WrapWithOverflow= Setter_8  $ CharacterEllipsis= Style_6" . 	Setter_10  $ Disabled= 	Setter_11  $ 0,0,0,0q 	Setter_12  #    	Setter_30 @ Name  $ Name.DisplayName Style_7" . 	Setter_14  y$ 	Collapsed= Style_8" . 	Setter_15  $ 	-5,0,0,14q 	Setter_31 @ Name  $ Name.DisplayName 	Setter_33 @ HelpText  $ Name.GroupHelpText DataTemplate_4.R 
Grid_4$
17,12,12,8q  RowDefinition_6 RowDefinition_7 RowDefinition_8 RowDefinition_9 RowDefinition_10  ColumnDefinition_6$* .+ $0$0TextBlock_1$CharacterEllipsis=$
Bold" $ Name.DisplayName $ ProjectRetargetingDlg$ FontSize -   $1$0TextBlock_2$0,14,0,0q$
Wrap= $ Name.Description $2$0$5,10,0,0q
 $0q$0q . |.   $ Name.Dependencies .R $0,0,0,12q   .+ $0$0$CharacterEllipsis=$
Bold" $ DisplayName $ ProjectRetargetingDlg$ FontSize $1$0$0,14,0,0q$
Wrap= $ Description $3$0TextBlock_3$0,8,0,0q$
Wrap=y $# Name.ShowSecondaryDescription8
    $ Name.SecondaryDescription $4$0
ListView_1$	-5,14,0,0q
 $0q$0q . |.  y $ Name.IsComboBoxEnabled8
  { $ Name.IsComboBoxEnabled $ Name.Properties .R 
Grid_5$0,0,0,12q  ColumnDefinition_7$ 
LabelWidth ColumnDefinition_8$ 
ComboWidth.+ $ ComboBoxLabel$0$0TextBlock_4$
Auto$Center= $ DisplayName  $
 Name  $ 
ComboBox_1 $
ComboBox_1$0$1
ComboBox_1$
Left=$Center=$2,0,0,0q$23|.  $ Values  *SelectedIndex+$ TwoWay=  $ ComboBoxLabel " .  @ Name  $ DisplayName  @ 	LabeledBy  $ ComboBoxLabel .R TextBlock_5 $ DisplayName  $ DisplayName  $ Value ControlTemplate_1"  .R $! ContainerBorderContainerBorder" . #z#z#z## z._ $$ contentPresentercontentPresenter#z#z#" z" % P  @JIsKeyboardFocusWithin . .   @
IsSelected . P 	Trigger_1 @
IsSelected . .  	Setter_23$& ContainerBorder#  '    	Setter_24#  (   P 	Trigger_2 @
IsSelected .  .  	Setter_25$& ContainerBorder  
  P 	Trigger_3  { .  .  	Setter_27 Z    DataTemplate_2.R 
Grid_2) . *  *	ToolTip+  ColumnDefinition_7$
Auto  ColumnDefinition_8$* .+ -   
CheckBox_1$0$Center=$9,0,0,0q+  $ 	IsChecked$ TwoWay=$, PropertyChanged=  *DisplayName+y *IsCheckable+8
    TextBlock_6$1$CharacterEllipsis=$NoWrap=$Center=$9,0,0,0q *DisplayName+. 
Grid_1
   RowDefinition_2$*  RowDefinition_5$
Auto   ColumnDefinition_1$*  ColumnDefinition_2$
Auto  ColumnDefinition_3$
Auto .+V  PMicrosoft.VisualStudio.CommonIDE.ProjectRetargeting.UI.ProjectRetargetingListBox  -   -  Name$- itemListView.   PreviewKeyUp. OnListViewPreviewKeyUp/   PreviewKeyDown/ OnListViewPreviewKeyDownitemListView$0$3$0,0,0,14q\ XPresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35-	  'System.Windows.Input.KeyboardNavigation0 	  TabNavigation$0 Continue=1 	  TabIndex$1 10#[ #[ 2  SelectionMode$2 Extended=|.  3  FocusVisualStyle3 Z  *
Projects+ %  '       7  7   Style_9" .-    Setter_ListBoxItem_tabStop @	 	IsTabStop .   	Setter_16 @
IsSelected  $ 
IsSelected$ TwoWay= 	Setter_17 @ Name  *ProjectName+ 	Setter_19  $ 0,2,0,2q 	Setter_20  $ 0q 	Setter_21 @ToolTip  *	ToolTip+ 	Setter_22 @^ShowOnDisabled .  	Setter_28  8    	Setter_29  y  $ 	IsVisible8
  4  
GroupStyle4 (
  "System.Windows.Controls.GroupStyle
  GroupStyle_15 
  ContainerStyle#5 [	 6 
  HeaderTemplate#6 [
  WarningColumnStackPanel7  Orientation$7 
Horizontal=$1$0y *ShowVSCloseReopenWarning+#
 [ .+/  )Microsoft.VisualStudio.Imaging.CrispImage  -   8  Name$8 InfoTipIconInfoTipIcon$
Left=$Bottom=$9, 0, 8, 20q$16$162  ,Microsoft.VisualStudio.Imaging.KnownMonikers9   StatusWarning:   Moniker#: Z9 5   /Microsoft.VisualStudio.PlatformUI.LiveTextBlock  -   ;  Name$; WarningTextBlockWarningTextBlock$0, 0, 0, 20q$
Left=$Bottom=$	260$NoWrap=$CharacterEllipsis=<  TextAlignment$
< Left=:   4Microsoft.VisualStudio.PlatformUI.TextToolTipService"=   AutoShowToolTipWhenObscured= .  *WarningText+  *WarningText+>   ToolTipText>  *WarningText+ -   Button_2$1$1#[ $1 40?  	IsDefault? . $	0,12,9,12q@   	AccessKey$@ Enter *OKText+y *ShowOKButton+#
 [  Button_3$1$2#[ $1 50A  IsCancelA . $
0,12,12,12q$@ Wyjd *
CancelText+y *IsAnyTargetInAdvertiseMode+#
 [ !     M S B A M L   `   `   `   h  dMicrosoft.VisualStudio.CommonIDE, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3ai9clr-namespace:Microsoft.VisualStudio.CommonIDE.VsSettings+Microsoft.VisualStudio.CommonIDE.VsSettings  f bMicrosoft.VisualStudio.Imaging, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3awTclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImagingMicrosoft.VisualStudio.Imaging k gMicrosoft.VisualStudio.ImageCatalog, Version=17.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a|Yclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImageCatalogMicrosoft.VisualStudio.Imaging }Wclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Imaging!Microsoft.VisualStudio.PlatformUI I    CMicrosoft.VisualStudio.CommonIDE.VsSettings.ProfileSettingsTreeView   > 9http://schemas.microsoft.com/winfx/2006/xaml/presentation  2x,http://schemas.microsoft.com/winfx/2006/xaml  Bmc;http://schemas.openxmlformats.org/markup-compatibility/2006  8d2http://schemas.microsoft.com/expression/blend/2008  Clocal9clr-namespace:Microsoft.VisualStudio.CommonIDE.VsSettings  `imagingTclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.Imaging  ecatalogYclr-namespace:Microsoft.VisualStudio.Imaging;assembly=Microsoft.VisualStudio.ImageCatalog  himagingThemeWclr-namespace:Microsoft.VisualStudio.PlatformUI;assembly=Microsoft.VisualStudio.Imaging  .N   HMicrosoft.VisualStudio.CommonIDE.VsSettings.ImportExportSettingsTreeView  -      Name$"  ImportExportSettingsTreeView *SortedChildren+=  7Microsoft.VisualStudio.PlatformUI.ImageThemingUtilities   ImageBackgroundColor    Path$ 
Background  RelativeSource  *Self+   BrushToColorConverter  	Converter# [     
TargetType" Q.   Property @Q
IsSelected  Value  *
IsSelected+  Mode$ TwoWay=  @Q
IsExpanded  *
IsExpanded+$ TwoWay=-    	  ItemsSource	  *SortedChildren+.R 
  Orientation$
 
Horizontal=.+ $_CheckBox_Item|.  $Center= d 	IsChecked  *	IsChecked+$ TwoWay=/  )Microsoft.VisualStudio.Imaging.CrispImage    Name$ SecurityWarningImageSecurityWarningImage2  ,Microsoft.VisualStudio.Imaging.KnownMonikers   StatusWarning   Moniker# Z $16$16 "    Triggers ^  ^ 
Conditions    Binding  $ SecurityWarning  Value$
 True   $ 
IsExpanded$ False.0   y$ Visible=   Binding  $ SecurityWarning  Value$ False.a   y$ Hidden=   $ 
IsExpanded$
 True.a   y$ Hidden= |.  $Center=$2,2,2,2q *GeneratedDisplayName+$ OneWay=QHv`{~8sd1>~WjY edZbn_LL 4.|hJqsX'iE%;c_F155, BSJB         v4.0.30319     l     #~    4  #Strings    0	     #US 8	     #GUID   H	     #Blob               %3                                              
 5        8        t   ,                     -       v  :                   [         y            <                x            _  0              8          V  ;            K    3      u        Y         <Module> Microsoft.VisualStudio.CommonIDE.resources pl Microsoft.VisualStudio.CommonIDE.Resources.DummyProject.xml Microsoft.VisualStudio.CommonIDE.SetupDrivers.Vs.Resources.setuptemplate.xml Microsoft.VisualStudio.CommonIDE.pl.resources Microsoft.VisualStudio.CommonIDE.MSBuild.Strings.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.VsSettingsUtils.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.VsSettingsPackage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.SettingsWizardForm.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.SettingsProgressPage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.SettingsAction.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.SaveFileControlManager.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.SaveCurrentPage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.ResetChooseFilePage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.MainPage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.ImportChooseFilePage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.FileListView.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.ExportChooseFilePage.pl.resources Microsoft.VisualStudio.CommonIDE.VsSettings.ChooseSettingsPage.pl.resources VSPackage.pl.resources Microsoft.VisualStudio.CommonIDE.TemplateWiz.TemplateWiz.pl.resources Microsoft.VisualStudio.CommonIDE.VsCredentials.pl.resources Microsoft.VisualStudio.CommonIDE.Solutions.Resources.SolutionStrings.pl.resources Microsoft.VisualStudio.CommonIDE.HlslExtender.HlslExtenderStrings.pl.resources Microsoft.VisualStudio.CommonIDE.DebugHandlerStrings.pl.resources Microsoft.VisualStudio.CommonIDE.BuildManagerStrings.pl.resources _EmptyResource.pl.resources Microsoft.VisualStudio.CommonIDE.g.pl.resources Microsoft.VisualStudio.CommonIDE.resources.dll          6 h[IAH;$  $          $  RSA1     W.jvlL;6!r<wwO)2!d\L(]b,e,=t]o-~^=&Ce m4MZ @         ^                         P               _CorDllMain mscoree.dll     %  @                                                                                                                                                                                                                                                                                                                                                                                                                                                   0                 	  H   X           4   V S _ V E R S I O N _ I N F O           $   $                         D    V a r F i l e I n f o     $    T r a n s l a t i o n     \   S t r i n g F i l e I n f o   8   0 4 1 5 0 4 b 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   j !  F i l e D e s c r i p t i o n     M i c r o s o f t . V i s u a l S t u d i o . C o m m o n I D E     <   F i l e V e r s i o n     1 7 . 3 . 3 2 8 0 4 . 2 4   ~ /  I n t e r n a l N a m e   M i c r o s o f t . V i s u a l S t u d i o . C o m m o n I D E . r e s o u r c e s . d l l      5  L e g a l C o p y r i g h t      M i c r o s o f t   C o r p o r a t i o n .   W s z e l k i e   p r a w a   z a s t r z e |o n e .      /  O r i g i n a l F i l e n a m e   M i c r o s o f t . V i s u a l S t u d i o . C o m m o n I D E . r e s o u r c e s . d l l     T   P r o d u c t N a m e     M i c r o s o f t    V i s u a l   S t u d i o    @   P r o d u c t V e r s i o n   1 7 . 3 . 3 2 8 0 4 . 2 4                                                                                                                                                                                                                                                                                                                                                                                                                                                    p2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      '    0'	*H'r0'n10	`He 0\
+7N0L0
+70	  010	`He  O 9#=#>@Zdd003  N    0	*H 0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110220512204601Z230511204601Z0t10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Corporation0"0	*H  0
 MnwO8tVn4@X" hmB6}JWJP ;cB#lUvM+HuQ61t1z0R,GIVe2br-]"e}_(s:qv0$af`>3yd(4EVp.YVPa]rml s3G(cT5&-{ ~0z0U%0
+7L+0UG2"3j}u0PUI0GE0C1)0'U Microsoft Operations Puerto Rico10U230012+4705290U#0HndP77"mu0TUM0K0IGEChttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a+U0S0Q+0Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0U0 0	*H  xKL^Q_]<<9sWb5,'cY3%Aa!w'sU\xUbx]#(wd&v0S]foE)Awr8]1,udm'8vlS;Gq8GX'N/~*'fDk@%/yW0TasC[*06^=Z+[^%'iFu@o<I`>^?tDcuNui!HRAFBrtK	T%;:QloUDiyh?'@yZs"S-TWCMv15(),kUwp+h/Y6H?z6uabvvZXO+80z0b
a     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20110110708205909Z260708210909Z0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110"0	*H  0
 r.nM4X!B*kZP8I7k891Byd~`$lIh^S
,+z	Y`fv2R&/PD].uhm:\F8dnd5xc-@\yI)w=+ZMV(zr:I^C{{>]O/Y;-3X>2=8~,NV!5%9ndS#_R!t%_('(8%9J6|#faj(I_%]!K>RW?$z[/#p]QFw _UK9#ID|Erzr$FWMI0[f{KI)(}gbx_/W\w((m(,@7OD	LC/tnx X,]`>O3NFl 00	+7 0UHndP77"mu0	+7
 S u b C A0U0U00U#0r-:1CN1#40ZUS0Q0OMKIhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^+R0P0N+0Bhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0U 00	+7.00?+3http://www.microsoft.com/pkiops/docs/primarycps.htm0@+042  L e g a l _ p o l i c y _ s t a t e m e n t . 0	*H  gTy.tg"cB}ye_.,>rm?
;Gic"5]e}FPU|K<BRk>.)=w9dD=xz#}t&F*hh.*?*kXIc	inZF+;5n%'(M=2-[I9

QEX82q'',: iYhnot@*(>?MfMo}Ev@*e]Rbc6']cA[>wuaaA(e/\ FY	KH )?Ew5zz"HG#kKux7yK#hui;0Lumc=VNOW"x2!zA
?]WqVNHEBv[
HkymmjRszP1s0o00~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20113  N    0	`He 0	*H	1
+70
+710
+70/	*H	1" A+/KKaf=x0B
+71402 M i c r o s o f thttp://www.microsoft.com0	*H  l|"Ac/[]"zY]"EF>DEL21jS<:x'
V3|DEE` _Q
_HsN-u9'JczJ$Jx><rZ>k-'{FyGpB/YR[Y7OWHf\/w.:J*-)5<JYp{mI?&0
+710	*H010	`He 0Q*H	@<08
+Y
010	`He  m5o@I=ba#b\R20220804105038.893Z0010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:3E7A-E359-A25D1%0#UMicrosoft Time-Stamp ServiceT003  z   0	*H 0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100211202190523Z230228190523Z010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:3E7A-E359-A25D1%0#UMicrosoft Time-Stamp Service0"0	*H  0
 hq ba#P*
>8|A/4,ua0kmG_'Vs7	4PWc?yE6^&\wQWre=D.G)k,iMK@p&E$?jH[Y9on^1v$fgEIa[! J^g5fg#NrP}4l~|:|OP?f/DxMYA Bm0	{jOBh9GH*Hl/{Ktzm'`WG{gHnqeO/C'B3e
]>9G,p^x@y({6#H0/:lsh"nB{.EdRjI+J".t/)
@Oh$ Txcj\|^gi 6020Ur.P)Nl/Da0U#0] ^b]eS5r0_UX0V0TRPNhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l+`0^0\+0Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0U0 0U%0
+0	*H  1}	m*@i/.D'&1,Z(+]t5~7XGehMber/]>&a *EQts 9mKQ3
Q]}JaS|!\(+	LV|8rU?HCW1ozv;	XMVN\2g^DMYu?]3>UoML7VbGb7ip$[jz3xZz 1Y"Bw
*WW	QL{|fa+CE#05@$%7 rPttLxx}/N5 tPUk2{%>[J{uffyc3'TDR#/jc~V	M9&jp[Ao:<NRb)N,X%MN/#Q,&|(h<Y0q0Y3   kI     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100210930182225Z300930183225Z0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100"0	*H  0
 Lr!y$ylNu5WlJ>`3\OfSqZ~JZ6gF#w2`}jRDFkvPDq\Q17
8n&S|9azri65&d;{3[~Rb%j]SVM9,Qpi6-p15($~TUmh;Fz)7EFn20\O,bJq[g`= s}AFu_4 }~Er/}_~66L+nQsM7t4G|?L^s=CN39LBh.QFjZasg^(v3r 
co6d[!]_0tPa65Gk\RQ]%PzlrR<7?xE^ri{>j. 00	+7 0#	+7*Rd<F5)/0U] ^b]eS5r0\U U0S0Q+7L}0A0?+3http://www.microsoft.com/pkiops/Docs/Repository.htm0U%0
+0	+7
 S u b C A0U0U00U#0V\bh=[0VUO0M0KIGEhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*H  U}*,g1$[rKo\>NGdx=139q6?dl|u9m1l"fg:SMx6.V i	{jo)n?Humm#TxSu$W=heV(U'$@]='@8)TBjBRu6as.,k{n?,	x[It=J>f;O2tLrou04zP
X@<TmctH,NG-qd$sm	WITds[DZk(g($8Kn!TkjEG^OLvWT	iD~|als
Af=iAI~~;>1Q{p(6L
4$5g+"'B=%tt[j>~13}{8pD::bpcSMmqjU3Xpf040010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:3E7A-E359-A25D1%0#UMicrosoft Time-Stamp Service#
0+ hqS'I0~0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100	*H  0"20220803210858Z20220804210858Z0t0:
+Y
1,0*0
  0 
0 0
 Cj 06
+Y
1(0&0
+Y

0  
0 0	*H  c6-8\&tToh6BAeq0;PUi4
f>?pknw3zAc
#5])YE>Kh10	00|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20103  z   0	`He J0	*H	1*H	0/	*H	1" \\O {Zugpx5"Z0*H	/1000 /G<he"-/>hR=00~0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20103  z   0" ;(-Mt]D@7L;C+4j~A0	*H  &v?mq;VP4*y[miV3S+a_F0dD	gG@6rRwuZaC:S@b5	'fyQZJ23W7u"'$"5[eifJWFne+E|
)
Xvs*`u~bznJ)DOntv'R)2:_67M_YLJ,1J\HNgI.,ufMmJlQu<45~({4yX+n<8Vc3hR9HCM	1U,[B0/:y%`WntSc\!wv1hV)?mZ9x9nQEj[E}^WF6+H!4%1yZieM_=i %M8 ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   MZ                @                                       	!L!This program cannot be run in DOS mode.
$       PE  L F         " 0                                               b  @                           @ O                 (       $                                                              H           .text                            `.rsrc                        @  @.reloc                        @  B                t     H     P   T  	       %                                        BSJB         v4.0.30319     l   0  #~      #Strings         #US      #GUID       #Blob           	   3      
      	   	                     a  a  N     6  6 D 6 a 6  6 - 6           	 H  H  H
 ) H 1 H 9 H A H I H Q H .   .   .   . #  . + . 3 @. ; S. C . K                         
                 <Module> System.Runtime DebuggableAttribute AssemblyTitleAttribute AssemblyFileVersionAttribute AssemblyInformationalVersionAttribute CompilationRelaxationsAttribute AssemblyProductAttribute AssemblyCopyrightAttribute AssemblyCompanyAttribute RuntimeCompatibilityAttribute PresentationFramework.resources.dll System.Reflection .ctor System.Diagnostics System.Runtime.CompilerServices PresentationFramework.resources FxResources.PresentationFramework.SR.zh-Hans.resources DebuggingModes zh-Hans      yDe      ?_
: $          $  RSA1     gw:8e `Y>e??13`!g-1/%}oY5L9EC;&=oGP\dEk*+Ge+]        TWrapNonExceptionThrows       Microsoft Corporation  3 . Microsoft Corporation. All rights reserved.   6.0.922.42004  E @6.0.9-servicing.22420.4+a97bb2af3c7d400dfe8aca3fa3d47ba83d925d6c   PresentationFramework         lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet         PADPADPmZ!|"@AzY!{w=J0~\T70HDy}oP 
/7b% )PSFb3lj8<?^w>.9w2*75XdO :;#)xAeS%Zn4%BV6+NWu7:\8Z[`#^VyQ"Gs+&cT0T/[_d_pt55555555550{=OjWmxyWB-8>@dt>~.m=>zx>aGqatT%V|2c6z6L[2#+De>]4Xw\NNQ7_v	_J!j&fUha^6te%b@#HVfX-Z3WHh4(wfNuO^?Dqm+Cc17O75@+AKQ-,Ru>RZKfn|)T)p%5k	6mCFrINttY<J NU-kRR%VM9c @]$Y=P-q x&&h>jH\p3Y^S[bx6QDwB6*cq+6NY#JU$C.Z
aTY
fP+V }4+[Bhce|X8
k2!95MQSm><,Cd3s3f)mXmo$m}+b>h5o*~&`4"ekLRTeR W4w'{wJ]$8{P7w	 d!4:\[P!@;xN 3J|&rFca4U ?#MmkW
6AkHblne{k`.GB`!J }P0LoVz G"I1tL9&Gk+{pA Q)TW<_PmP@_u!418B6tRos=eSO}^&RU""p q-7 0!h"&B>'qa	}b-ZVF4bq|"O_Tp93*;~md3!RhKkWn-
$f[q;
l9qH6+8l}[vm>NjZb.X=F]<MRtj\?GKG1[h1g^apYC\ !0BQka>kzsx|_n@ ",!UF?k[qaM
<7bY&/_QFXcmiyR9LS_#p*=N#HI=$SZ6jbJy}OH{jBI9zACqRH7
YS4y	*OMdu#!!axrv0 cz=0l0bG2^1A=W6  $r)rRR	p[~OV ,i z%i]LqW0B^|on[rp&~.X??RyhDIM	ex2<zdFE*Z4]77 `>zB-O_3.0]<7}eouEWr#^|RAl<F8RiM.qFU% c7; 	d { 0 iYx0_8%R. LCENZR45@,>k43A c	q=	f@	0	
|S
g/!Bq!,p,pA@b`'diXe! #i$kY*R+kM6_
Hgj)3FfgB	=!{/\ _JcC6Q UY
 ca0'A2!=]*2Z]^PuR(>J!Cwi7JTE]	h hm(E `Y`$m(1Or1u?s!'MIX#y43*(eN21S7|?EE<%>B%;[Zj m !![!#!M!\!o"kY"p"X""l##tD#!$ L$]$gq$$5%%>7%n%&{%}% %V&nd&Cp&S&i&%'B.'`''j''}'_'0>(?(W([(uc(	e(((+4)Wx)8)>)sf)N)B)3)
**I*)**)S+"+*+>+#++3_,V,",[-w-1-M-!-@-.. 0.wq.....~./|Z///~/	#0#'0-0P0T0J009 0<1w12y[2}t222=Q2d2z3u]3CD3C3344w6>5fZ5Z5Wj5gt5!6M6 6N7E75#7,07b7 8G8Nv\8E8]888M8I%9/&909Z}9l~99@9N9'9#2:::A:qn ;<)`<R{q<<F0X=N_=Sr=)=*>N>>v,>>?D-?@?W??4?M!@`W%@@:A_AOAAnA'B{rBHB@fCCCoD(D/D0iDuE?(E=E!MEE7aEtE.8E
E*E)FFRFF GG*2G\G)`G
G,H[u<HdiHiHHuHH	rII5I}I1fJUJJL
K
0K4K	eKyKLRULhsL|WLL%L| M`MMMN`NpN7Nu8NmNOL%OhQ(O,fOOZO~)OPP3PrPDPy&QNQQ5QnQDQbR3RJYRy+R/8R{CRbbRRoRXSS6SS^S]S T`
TnT}T TT8TTpTtU5 U6U?c;U~ ~UeUUY;U6VgVVVVAWXyX"YYTZ+rZ+ZFZQP[.[N[~[ \'\;'\\u\\],y]4]x4]XN]^ci^6.^^L^^:^#___6_t_F_	?8` al'a)aa]aab0b.b`cm`c#	bcc$O-dKDdwdd9ddhdd`ez:eefG!fc\QfCfRf<pghB%hhMhiO]iiia4j=;j;x|jUjqjj7jj3kQ*ka^6kkk\l
\l6llD[lmFMmjmmnne-nZnooYHpHp(a}p^p pGq$q~$qIqd[qq?8qLrmZrprTrrOGss##t?=t[BAtgbCt/cWtttJuY#uGulsuuunu.upuX+uvGSvGvq3w?JwuPwY^ww(wPtxxx;Vx+xyqsyYzYzCzM(z,{|{{o{rp{y{\{C|9|d|h|o|~|n|~{|f||}H}>}#j}o}\	}p~~=~~1>s;;1      n7      9     $          B0    U  d`    i  W  G<    % [+ e. 
  I  J"    Y!     % V  $.  6$ GW  xL  9    h    ,  g    x=            . I  
8      &   O    2  } sK      {8  -~  d  !q      E  ,  4     4 <  j  )  + |d            @      84   S_  ,_  _  ^  _  _  _  z_  =`  `  fc  i        N  8 c    ,    W  [  P          n         +0  Q    z r  A  /    n           B  y3  `   a  ,      )  Q    $  o  L  p  ]2 ea  X  @- _  p  \H      Fx  me  v  4f  I:    >{    a  q    F  z  i      C  J3     #    z  +     t     N    Q  V  * u#    b  ? N  	 L  zj    ]$ w  E  CA    s    }  )g  Z      = H  %       t    k  v*  g  p  2@    t        ! e5 Y        \  $E  >  m  E9  0  |  t  Q  	  k    \t    - ]   0  H  J,  B     s     	         {  R  \ _  i      #m  .  l$     F    X  m  ay  )       H  Y   =     7t    A  ZM  \        gI  (       R' )[  T  >  o  o  x  k  c  '   %3 =  ,        %    q.    j  )  2          (   O  7  V n  v  Z  d  I  #    `& j    !    ! ;" ) .  x          " @  N    c    n  , #/  >  ~  l     9    x      V    y  ) 0 w  fg  Y    H    	    -     8  "e  U
     2     D  ^  l  - % @    	    D   t9       O    xz        |    M     I      )  \   U* r  }  o      &  u  qs  ^      y  s    eG  [  G  = E) }Y    Y      D]    w,  (    "    r  )  #      <1    
   	n  k  . J  0  c  N  :  65  $S  2v  kE   r      j/  9   g- =  & \  q  .. n  F  x  =  |      Y  w      . G  [ Rh  b  9  1d    )  Mz      (    r    f  #    %    d  +     4(  - K      	 F6  I    m  ?    I    9   / w      -R    _  U# #   s(   T9 b  Q    e% OQ  v  @4  Z    r"   -         ?  5  
  \  \  e  _  9    , :	   3   Hw  w 5      H  +  k   v      #         `  y5  O?  =     `  I   ^  &   U  <    NP  g    
 b  6    L    *  Q^  >            S    @n    t  y  H	  9  g  g          T      `}  :  ^l  3*    ]B      <X    [Z  z    { P  V      `  -    \)  5  *       O  6  e  @  _  w    s	  g    Wk  >  `b    '   D      a4 $+  :  ?J  m    h~  A p  ]  j B;  v    5 =  b, S    ]    ~  g     q  .    7  & 7|  
 &     2   {  &        &2     Q  4    ( =    7     r  V  ' on  v  w   s  >    $   ^      7      m  S  B  a   K  H Rq  t   8    l! V  !  
  / m  W  7   Ao    Y  V'  y  0     T    63  >  4    eS  8  %/      `  K    1 % M   e    t       ]  #O  b  "  * a  R  Y  ,  U  g  >  , B7   X  J    A      P  *  hN    g8   r0   |       ;         {  h  5  |1 A  U  R  U    }    
%  6    RO  ;  6  B   \  B  [    A  l  C  ,C  1D  C  T        x  ~F  M  )      B  R      6    a        !c    J\  b           '  3 <  @  G    i  u +  -  8    r    w4  f/ *   ?  N  "!  H  ) (k      P  P      !        =V  s  J  2  =   A  z  2 +K    '  f  l  f         "   2  c-    	    n  g   S1 P  m  ww  ?      J        4    Z  #"       F  &  |        
       + [(  t  n    3  
    i  9  ,    "    o                8B     f  Ci      o      U  ^  5&   !  Kj      h  4 :  r  (  F#      -   d      U    
      I  !  IU  Z      &  ]f          S  j  
 &y  I     b
  R  M  L    Br  g  V        4 f  E        ! <        l    d    :  M  - =    ^ Y R      lJ  }2    Y     u  m@    ^  J&  8  #6 9u  - 	0 3    D       q  m  #   W      a  L  6  [        	 -     N .  C  {  M  S    F>  h  1 + ?  a  B( r  &  &     +    g  W  U 
     
  *  +    )  L   M    VK    XR  +
  0    #  K !    b 9  6       w    -$  8  zi  q    +  ~  ~*  T  z      K  i%          l  u    :  $     /T      Ds  /          CL      k     %  Q    Qp    # A  `m  	    O  9  I  "  Y  }"      G  f) B ,  #       q  `    6 c A X N o h W n d     *A b s o l u t e U r i N o t A l l o w e d V   A b s o l u t e U r i O n l y q   :A c c e s s C o l l e c t i o n A f t e r S h u t D o w n    8A d d A n n o t a t i o n s N o t I m p l e m e n t e d    &A d d e d I t e m N o t A t I n d e x    0A d d e d I t e m N o t I n C o l l e c t i o n '  ,A d o r n e d E l e m e n t N o t F o u n d [  RA d o r n e d E l e m e n t P l a c e h o l d e r M u s t B e I n T e m p l a t e   A d o r n e r N o t F o u n d   (A f f e c t e d B y M s C t f I s s u e   2A l r e a d y H a s L o g i c a l C h i l d r e n    A l r e a d y H a s P a r e n t *  :A n i m a t i o n _ C h i l d M u s t B e K e y F r a m e S  `A n i m a t i o n _ I n v a l i d A n i m a t i o n U s i n g K e y F r a m e s D u r a t i o n   4A n i m a t i o n _ I n v a l i d B a s e V a l u e   BA n i m a t i o n _ I n v a l i d R e s o l v e d K e y T i m e s V  8A n i m a t i o n _ I n v a l i d T i m e K e y T i m e   <A n i m a t i o n _ I n v a l i d _ D e f a u l t V a l u e   0A n i m a t i o n _ N o T e x t C h i l d r e n   <A n n o t a t i o n A d o r n e r _ N o t U I E l e m e n t   >A n n o t a t i o n A l r e a d y E x i s t I n S e r v i c e 7  .A n n o t a t i o n A l r e a d y E x i s t s c   A n n o t a t i o n I s N u l l   <A n n o t a t i o n S e r v i c e A l r e a d y E x i s t s   BA n n o t a t i o n S e r v i c e I s A l r e a d y E n a b l e d   6A n n o t a t i o n S e r v i c e N o t E n a b l e d 	  ,A p p A c t i v a t i o n E x c e p t i o n .	  2A p p l i c a t i o n A l r e a d y R u n n i n g u	  .A p p l i c a t i o n S h u t t i n g D o w n 	  ,A r g u m e n t L e n g t h M i s m a t c h 	  :A r g u m e n t P r o p e r t y M u s t N o t B e N u l l 	  ,A r g u m e n t _ I n v a l i d O f f L e n #
  0A r r a n g e R e e n t r a n c y I n v a l i d 
  $A s s e m b l y I d N e g a t i v e 
  .A s s e m b l y I d O u t O f S e q u e n c e   $A s s e m b l y T a g M i s s i n g H  4A t t a c h a b l e P r o p e r t y N o t F o u n d   :A u d i o V i d e o _ C a n n o t C o n t r o l M e d i a   DA u d i o V i d e o _ I n v a l i d D e p e n d e n c y O b j e c t   8A u d i o V i d e o _ I n v a l i d M e d i a S t a t e #  bA u x i l i a r y F i l t e r R e t u r n e d A n o m a l o u s C o u n t O f C h a r a c t e r s I  &A x N o C o n n e c t i o n P o i n t   8A x N o C o n n e c t i o n P o i n t C o n t a i n e r   $A x N o E v e n t I n t e r f a c e   A x N o S i n k A d v i s e "  ,A x N o S i n k I m p l e m e n t a t i o n ]  2A x R e q u i r e s A p a r t m e n t T h r e a d   &A x W i n d o w l e s s C o n t r o l   B a d D i s t a n c e =  (B a d F i x e d T e x t P o s i t i o n o  B a d T a r g e t A r r a y   (B a d T e x t P o s i t i o n O r d e r   ,B a m l A s s e m b l y I d N o t F o u n d   *B a m l B a d E x t e n s i o n V a l u e   ^B a m l I s N o t S u p p o r t e d O u t s i d e O f A p p l i c a t i o n R e s o u r c e s b   B a m l R e a d e r C l o s e d   *B a m l R e a d e r N o O w n e r T y p e   B a m l S c o p e E r r o r 8  $B a m l T y p e I d N o t F o u n d   *B a m l W r i t e r B a d A s s e m b l y   $B a m l W r i t e r B a d S c o p e   &B a m l W r i t e r B a d S t r e a m B  $B a m l W r i t e r B a d X m l n s    B a m l W r i t e r C l o s e d   *B a m l W r i t e r N o I n E l e m e n t   $B a m l W r i t e r S t a r t D o c ]  @B a m l W r i t e r U n k n o w n M a r k u p E x t e n s i o n   FB i n d i n g C o l l e c t i o n C o n t a i n s N o n B i n d i n g   B i n d i n g C o n f l i c t (  6B i n d i n g E x p r e s s i o n I s D e t a c h e d [  <B i n d i n g E x p r e s s i o n S t a t u s C h a n g e d   >B i n d i n g G r o u p _ C a n n o t C h a n g e G r o u p s   (B i n d i n g G r o u p _ N o E n t r y ?  :B i n d i n g G r o u p _ V a l u e U n a v a i l a b l e   FB i n d i n g L i s t C a n O n l y S o r t B y O n e P r o p e r t y   :B i n d i n g L i s t C a n n o t C u s t o m F i l t e r H  4B r o w s e r H o s t i n g N o t S u p p o r t e d ~  (B u f f e r O f f s e t N e g a t i v e   B u f f e r T o o S m a l l   BB y t e R a n g e D o w n l o a d e r N o t I n i t i a l i z e d   TC a l e n d a r A u t o m a t i o n P e e r _ B l a c k o u t D a y H e l p T e x t >  rC a l e n d a r A u t o m a t i o n P e e r _ C a l e n d a r B u t t o n L o c a l i z e d C o n t r o l T y p e O  hC a l e n d a r A u t o m a t i o n P e e r _ D a y B u t t o n L o c a l i z e d C o n t r o l T y p e ]  BC a l e n d a r A u t o m a t i o n P e e r _ D e c a d e M o d e h  @C a l e n d a r A u t o m a t i o n P e e r _ M o n t h M o d e m  >C a l e n d a r A u t o m a t i o n P e e r _ Y e a r M o d e r  xC a l e n d a r C o l l e c t i o n _ M u l t i T h r e a d e d C o l l e c t i o n C h a n g e N o t S u p p o r t e d w  BC a l e n d a r N a m e P r o p e r t y V a l u e N o t V a l i d   XC a l e n d a r _ C h e c k S e l e c t i o n M o d e _ I n v a l i d O p e r a t i o n 5  .C a l e n d a r _ N e x t B u t t o n N a m e   dC a l e n d a r _ O n D i s p l a y M o d e P r o p e r t y C h a n g e d _ I n v a l i d V a l u e   ZC a l e n d a r _ O n F i r s t D a y O f W e e k C h a n g e d _ I n v a l i d V a l u e   ^C a l e n d a r _ O n S e l e c t e d D a t e C h a n g e d _ I n v a l i d O p e r a t i o n   VC a l e n d a r _ O n S e l e c t e d D a t e C h a n g e d _ I n v a l i d V a l u e A  XC a l e n d a r _ O n S e l e c t i o n M o d e C h a n g e d _ I n v a l i d V a l u e \  6C a l e n d a r _ P r e v i o u s B u t t o n N a m e x  4C a l e n d a r _ U n S e l e c t a b l e D a t e s   &C a n O n l y H a v e O n e C h i l d   ,C a n c e l E d i t N o t S u p p o r t e d   C a n c e l l e d T e x t !  C a n c e l l e d T i t l e A  &C a n n o t B e I n s i d e P o p u p ^  $C a n n o t B e S e l f P a r e n t   BC a n n o t C a l l R u n F r o m B r o w s e r H o s t e d A p p   4C a n n o t C a l l R u n M u l t i p l e T i m e s   .C a n n o t C h a n g e A f t e r S e a l e d   .C a n n o t C h a n g e L i v e S h a p i n g [  >C a n n o t C h a n g e M a i n W i n d o w I n B r o w s e r   2C a n n o t C o n v e r t S t r i n g T o T y p e   "C a n n o t C o n v e r t T y p e   XC a n n o t D e t e r m i n e S o r t B y P r o p e r t i e s F o r C o l l e c t i o n G  *C a n n o t E d i t P l a c e h o l d e r    C a n n o t F i l t e r V i e w   *C a n n o t F i n d R e m o v e d I t e m   C a n n o t G r o u p V i e w   FC a n n o t H a v e E v e n t H a n d l e r s I n T h e m e S t y l e $  VC a n n o t H a v e O v e r r i d e s D e f a u l t S t y l e I n T h e m e S t y l e Z  2C a n n o t H a v e P r o p e r t y I n S t y l e   8C a n n o t H a v e P r o p e r t y I n T e m p l a t e   &C a n n o t H o o k u p F C E R o o t   $C a n n o t I n v o k e S c r i p t i  RC a n n o t M o d i f y L o g i c a l C h i l d r e n D u r i n g T r e e W a l k   :C a n n o t M o d i f y R e a d O n l y C o n t a i n e r   6C a n n o t M o v e T o U n k n o w n P o s i t i o n   C a n n o t P a r s e I d   .C a n n o t P r o c e s s I n k C o m m a n d 9  `C a n n o t Q u e r y P r o p e r t i e s W h e n P a g e N o t I n T r e e W i t h W i n d o w   <C a n n o t R e c y l e H e t e r o g e n e o u s T y p e s   6C a n n o t R e m o v e U n r e a l i z e d I t e m s   NC a n n o t R e t r i e v e P a r t s O f W r i t e O n l y C o n t a i n e r   :C a n n o t S e l e c t N o t S e l e c t a b l e I t e m %   <C a n n o t S e r i a l i z e I n v a l i d I n s t a n c e 6   2C a n n o t S e t N e g a t i v e P o s i t i o n    ,C a n n o t S e t O w n e r T o I t s e l f    C a n n o t S o r t V i e w    (C a n n o t U s e I t e m s S o u r c e !  *C a n n o t W r i t e T o R e a d O n l y O!  C a n t S e t I n M a r k u p !  <C a n t S e t O w n e r A f t e r D i a l o g I s S h o w n "  4C a n t S e t O w n e r T o C l o s e d W i n d o w 8"  @C a n t S e t O w n e r W h o s H w n d I s N o t C r e a t e d o"  4C a n t S h o w M B S e r v i c e W i t h O w n e r "  :C a n t S h o w M o d a l O n N o n I n t e r a c t i v e "  2C a n t S h o w O n D i f f e r e n t T h r e a d 7#  NC a n t S w i t c h V i r t u a l i z a t i o n M o d e P o s t M e a s u r e l#  2C h a n g e N o t A l l o w e d A f t e r S h o w #  &C h a n g e S e a l e d B i n d i n g C$  <C h a n g i n g C o l l e c t i o n N o t S u p p o r t e d i$  (C h a n g i n g I d N o t A l l o w e d $  ,C h a n g i n g T y p e N o t A l l o w e d $  "C h i l d H a s W r o n g T y p e )%  .C h i l d N a m e M u s t B e N o n E m p t y \%  8C h i l d N a m e N a m e P a t t e r n R e s e r v e d %  BC h i l d T e m p l a t e I n s t a n c e D o e s N o t E x i s t %  @C h i l d W i n d o w M u s t H a v e C o r r e c t P a r e n t %  *C h i l d W i n d o w N o t C r e a t e d 0&  $C i r c u l a r O w n e r C h i l d i&  C l e a r H i g h l i g h t &  0C l i p T o B o u n d s N o t S u p p o r t e d &  4C l i p b o a r d C o p y M o d e _ D i s a b l e d &  :C o l l e c t i o n A d d E v e n t M i s s i n g I t e m '  >C o l l e c t i o n C h a n g e I n d e x O u t O f R a n g e '  VC o l l e c t i o n C o n t a i n e r M u s t B e U n i q u e F o r C o m p o s i t e 7(  ZC o l l e c t i o n N u m b e r O f E l e m e n t s M u s t B e L e s s O r E q u a l T o }(  8C o l l e c t i o n V i e w T y p e I s I n i t O n l y (  ZC o l l e c t i o n V i e w _ M i s s i n g S y n c h r o n i z a t i o n C a l l b a c k (  @C o l l e c t i o n V i e w _ N a m e T y p e D u p l i c i t y h)  FC o l l e c t i o n V i e w _ V i e w T y p e I n s u f f i c i e n t )  0C o l l e c t i o n V i e w _ W r o n g T y p e *  $C o l l e c t i o n _ B a d T y p e ?*  ^C o l l e c t i o n _ C o p y T o _ A r r a y C a n n o t B e M u l t i d i m e n s i o n a l *  lC o l l e c t i o n _ C o p y T o _ I n d e x G r e a t e r T h a n O r E q u a l T o A r r a y L e n g t h *  hC o l l e c t i o n _ C o p y T o _ N u m b e r O f E l e m e n t s E x c e e d s A r r a y L e n g t h %+  "C o l l e c t i o n _ N o N u l l ~+  TC o l o r C o n v e r t e d B i t m a p E x t e n s i o n N o S o u r c e I m a g e +  XC o l o r C o n v e r t e d B i t m a p E x t e n s i o n N o S o u r c e P r o f i l e +  FC o l o r C o n v e r t e d B i t m a p E x t e n s i o n S y n t a x ,  <C o m p a t i b i l i t y P r e f e r e n c e s S e a l e d ?,  JC o m p o n e n t A l r e a d y I n P r e s e n t a t i o n C o n t e x t w,  BC o m p o n e n t N o t I n P r e s e n t a t i o n C o n t e x t ,  FC o m p o s i t e C o l l e c t i o n R e s e t O n l y O n C l e a r ,  PC o n d i t i o n C a n n o t U s e B o t h P r o p e r t y A n d B i n d i n g <-  LC o n d i t i o n V a l u e O f E x p r e s s i o n N o t S u p p o r t e d n-  VC o n d i t i o n V a l u e O f M a r k u p E x t e n s i o n N o t S u p p o r t e d -  NC o n t e n t C o n t r o l C a n n o t H a v e M u l t i p l e C o n t e n t -  .C o n t e n t T y p e N o t S u p p o r t e d -  @C o n t e x t M e n u I n D i f f e r e n t D i s p a t c h e r .  (C o p y T o N o t E n o u g h S p a c e I.  VC o r e P r o p e r t y E n u m e r a t o r P o s i t i o n e d O u t O f B o u n d s .  C r e a t e H i g h l i g h t .  C r e a t e I n k N o t e .  JC r e a t e R o o t P o p u p _ C h i l d H a s L o g i c a l P a r e n t .  HC r e a t e R o o t P o p u p _ C h i l d H a s V i s u a l P a r e n t K/  C r e a t e T e x t N o t e /  NC r o s s T h r e a d A c c e s s O f U n s h a r e a b l e F r e e z a b l e /  HC u s t o m C o n t e n t S t a t e M u s t B e S e r i a l i z a b l e 0  RC u s t o m D i c t i o n a r y F a i l e d T o L o a d D i c t i o n a r y U r i <0  VC u s t o m D i c t i o n a r y F a i l e d T o U n L o a d D i c t i o n a r y U r i m0  BC u s t o m D i c t i o n a r y I t e m A l r e a d y E x i s t s 0  0C u s t o m D i c t i o n a r y N u l l I t e m 0  JC u s t o m D i c t i o n a r y S o u r c e s U n s u p p o r t e d U R I 0  8C y c l i c S t y l e R e f e r e n c e D e t e c t e d 1  BC y c l i c T h e m e S t y l e R e f e r e n c e D e t e c t e d _1  fD a t a G r i d C e l l I t e m A u t o m a t i o n P e e r _ L o c a l i z e d C o n t r o l T y p e 1  ZD a t a G r i d C e l l I t e m A u t o m a t i o n P e e r _ N a m e C o r e F o r m a t 1  jD a t a G r i d C o l u m n H e a d e r I t e m A u t o m a t i o n P e e r _ N a m e C o r e F o r m a t 1  dD a t a G r i d C o l u m n H e a d e r I t e m A u t o m a t i o n P e e r _ U n r e s i z a b l e 1  dD a t a G r i d C o l u m n H e a d e r I t e m A u t o m a t i o n P e e r _ U n s u p p o r t e d 2  .D a t a G r i d L e n g t h _ I n f i n i t y K2  4D a t a G r i d L e n g t h _ I n v a l i d T y p e e2  HD a t a G r i d R o w _ C a n n o t S e l e c t R o w W h e n C e l l s v2  >D a t a G r i d _ A u t o m a t i o n I n v o k e F a i l e d 2  2D a t a G r i d _ C a n n o t S e l e c t C e l l )3  JD a t a G r i d _ C o l u m n D i s p l a y I n d e x O u t O f R a n g e i3  <D a t a G r i d _ C o l u m n I n d e x O u t O f R a n g e 3  2D a t a G r i d _ C o l u m n I s R e a d O n l y g4  >D a t a G r i d _ D i s p l a y I n d e x O u t O f R a n g e 4  <D a t a G r i d _ D u p l i c a t e D i s p l a y I n d e x 5  6D a t a G r i d _ I n v a l i d C o l u m n R e u s e _5  >D a t a G r i d _ I n v a l i d S o r t D e s c r i p t i o n 5  JD a t a G r i d _ N e w C o l u m n I n v a l i d D i s p l a y I n d e x 6  &D a t a G r i d _ N u l l C o l u m n 7  ND a t a G r i d _ P r o b a b l e I n v a l i d S o r t D e s c r i p t i o n :7  BD a t a G r i d _ R e a d o n l y C e l l s I t e m s S o u r c e 98  ,D a t a T y p e C a n n o t B e O b j e c t n8  ZD a t e P i c k e r A u t o m a t i o n P e e r _ L o c a l i z e d C o n t r o l T y p e 8  LD a t e P i c k e r T e x t B o x _ D e f a u l t W a t e r m a r k T e x t 8  ^D a t e P i c k e r T e x t B o x _ T e m p l a t e P a r t I s O f I n c o r r e c t T y p e 8  :D a t e P i c k e r _ D r o p D o w n B u t t o n N a m e 8  fD a t e P i c k e r _ O n S e l e c t e d D a t e F o r m a t C h a n g e d _ I n v a l i d V a l u e 9  0D a t e P i c k e r _ W a t e r m a r k T e x t !9  (D e f e r S e l e c t i o n A c t i v e /9  .D e f e r S e l e c t i o n N o t A c t i v e d9  0D e f e r r i n g L o a d e r N o C o n t e x t 9  *D e f e r r i n g L o a d e r N o S a v e 9  "D e l e t e A n n o t a t i o n s :  D e l e t e N o t e s ?:  D e p l o y T e x t Q:  D e p l o y T i t l e :  ZD e s i g n e r M e t a d a t a _ C u s t o m C a t e g o r y _ A c c e s s i b i l i t y :  ND e s i g n e r M e t a d a t a _ C u s t o m C a t e g o r y _ C o n t e n t :  TD e s i g n e r M e t a d a t a _ C u s t o m C a t e g o r y _ N a v i g a t i o n :  HD i a l o g R e s u l t M u s t B e S e t A f t e r S h o w D i a l o g :  ND i s p l a y M e m b e r P a t h A n d I t e m T e m p l a t e D e f i n e d ,;  ^D i s p l a y M e m b e r P a t h A n d I t e m T e m p l a t e S e l e c t o r D e f i n e d f;  JD o c u m e n t A p p l i c a t i o n C a n n o t I n i t i a l i z e U I ;  fD o c u m e n t A p p l i c a t i o n C o n t e x t M e n u F i r s t P a g e I n p u t G e s t u r e 
<  dD o c u m e n t A p p l i c a t i o n C o n t e x t M e n u L a s t P a g e I n p u t G e s t u r e <  XD o c u m e n t A p p l i c a t i o n C o n t e x t M e n u N e x t P a g e H e a d e r <  dD o c u m e n t A p p l i c a t i o n C o n t e x t M e n u N e x t P a g e I n p u t G e s t u r e *<  `D o c u m e n t A p p l i c a t i o n C o n t e x t M e n u P r e v i o u s P a g e H e a d e r :<  lD o c u m e n t A p p l i c a t i o n C o n t e x t M e n u P r e v i o u s P a g e I n p u t G e s t u r e E<  BD o c u m e n t A p p l i c a t i o n N o t I n F u l l T r u s t S<  LD o c u m e n t A p p l i c a t i o n R e g i s t r y K e y N o t F o u n d <  >D o c u m e n t A p p l i c a t i o n S t a t u s L o a d e d <  ND o c u m e n t A p p l i c a t i o n U n a b l e T o O p e n D o c u m e n t <  HD o c u m e n t A p p l i c a t i o n U n k n o w n F i l e F o r m a t <  6D o c u m e n t G r i d I n v a l i d V i e w M o d e =  jD o c u m e n t G r i d V i s u a l T r e e C o n t a i n s N o n B o r d e r A s F i r s t E l e m e n t S=  bD o c u m e n t G r i d V i s u a l T r e e C o n t a i n s N o n D o c u m e n t G r i d P a g e =  TD o c u m e n t G r i d V i s u a l T r e e C o n t a i n s N o n U I E l e m e n t =  >D o c u m e n t G r i d V i s u a l T r e e O u t O f S y n c >  TD o c u m e n t P a g e V i e w _ P a r e n t N o t D o c u m e n t P a g e H o s t <>   D o c u m e n t R e a d O n l y t>  FD o c u m e n t R e f e r e n c e H a s I n v a l i d D o c u m e n t >  2D o c u m e n t R e f e r e n c e N o t F o u n d >  HD o c u m e n t R e f e r e n c e U n s u p p o r t e d M i m e T y p e ?  RD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 1 L?  RD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 2 ?  RD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 4 ?  RD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 6 <@  FD o c u m e n t V i e w e r A r g u m e n t M u s t B e I n t e g e r @  LD o c u m e n t V i e w e r A r g u m e n t M u s t B e P e r c e n t a g e @  BD o c u m e n t V i e w e r C a n H a v e O n l y O n e C h i l d 5A  pD o c u m e n t V i e w e r C h i l d M u s t I m p l e m e n t I D o c u m e n t P a g i n a t o r S o u r c e dA  6D o c u m e n t V i e w e r O n e M a s t e r P a g e A  ^D o c u m e n t V i e w e r O n l y S u p p o r t s F i x e d D o c u m e n t S e q u e n c e B  LD o c u m e n t V i e w e r P a g e V i e w s C o l l e c t i o n E m p t y MB  BD o c u m e n t V i e w e r S e a r c h C o m p l e t e T i t l e B  JD o c u m e n t V i e w e r S e a r c h D o w n C o m p l e t e L a b e l B  FD o c u m e n t V i e w e r S e a r c h U p C o m p l e t e L a b e l B  RD o c u m e n t V i e w e r S t y l e M u s t I n c l u d e C o n t e n t H o s t B  PD o c u m e n t V i e w e r V i e w F i t T o H e i g h t C o m m a n d T e x t UC  `D o c u m e n t V i e w e r V i e w F i t T o M a x P a g e s A c r o s s C o m m a n d T e x t ]C  ND o c u m e n t V i e w e r V i e w F i t T o W i d t h C o m m a n d T e x t hC  ND o c u m e n t V i e w e r V i e w T h u m b n a i l s C o m m a n d T e x t pC  D o w n l o a d T e x t C  D o w n l o a d T i t l e C  D r a g M o v e F a i l 	D  .D u p l i c a t e d C o m p a t i b l e U r i >D  D u p l i c a t e d U r i wD  (D u p l i c a t e s N o t A l l o w e d D  (E l e m e n t M u s t B e I n P o p u p D  6E l e m e n t M u s t B e l o n g T o T e m p l a t e E  4E m p t y S e l e c t i o n N o t S u p p o r t e d 2E  FE n d I n i t W i t h o u t B e g i n I n i t N o t S u p p o r t e d dE  &E n t r y A s s e m b l y I s N u l l E  E n u m _ I n v a l i d TF  8E n u m e r a t o r C o l l e c t i o n D i s p o s e d qF  4E n u m e r a t o r I n v a l i d O p e r a t i o n F  (E n u m e r a t o r N o t S t a r t e d F  (E n u m e r a t o r R e a c h e d E n d "G  0E n u m e r a t o r V e r s i o n C h a n g e d 6G  0E n u m e r a t o r _ V e r i f y C o n t e x t kG  *E v e n t T r i g g e r B a d A c t i o n G  <E v e n t T r i g g e r D o N o t S e t P r o p e r t i e s G  8E v e n t T r i g g e r D o e s N o t E n t e r E x i t H  :E v e n t T r i g g e r E v e n t U n r e s o l v a b l e AH  *E v e n t T r i g g e r N e e d E v e n t rH  RE v e n t T r i g g e r O n S t y l e N o t A l l o w e d T o H a v e T a r g e t H  DE v e n t T r i g g e r T a r g e t N a m e U n r e s o l v a b l e H  $E x c e p t i o n I n G e t P a g e /I  VE x c e p t i o n V a l i d a t i o n R u l e V a l i d a t e N o t S u p p o r t e d OI  2E x p e c t e d B a m l S c h e m a C o n t e x t I  *E x p e c t e d B i n a r y C o n t e n t `J  @E x p e c t e d R e s o u r c e D i c t i o n a r y T a r g e t J  4F a i l T o L a u n c h D e f a u l t B r o w s e r J  DF a i l T o N a v i g a t e U s i n g H y p e r l i n k T a r g e t K  0F a i l e d R e s u m e P a g e F u n c t i o n CK  .F a i l e d T o C o n v e r t R e s o u r c e K  0F i l e D i a l o g B u f f e r T o o S m a l l K  ,F i l e D i a l o g C r e a t e P r o m p t L  ,F i l e D i a l o g F i l e N o t F o u n d @L  2F i l e D i a l o g I n v a l i d F i l e N a m e zL  .F i l e D i a l o g I n v a l i d F i l t e r L  8F i l e D i a l o g I n v a l i d F i l t e r I n d e x M  2F i l e D i a l o g O v e r w r i t e P r o m p t M  2F i l e D i a l o g S u b C l a s s F a i l u r e $N  &F i l e F o r m a t E x c e p t i o n wN  >F i l e F o r m a t E x c e p t i o n W i t h F i l e N a m e N  *F i l e N a m e M u s t N o t B e N u l l N  &F i l e N a m e N u l l O r E m p t y 4O  *F i l e T o F i l t e r N o t L o a d e d WO  <F i l t e r B i n d R e g i o n N o t I m p l e m e n t e d wO  "F i l t e r E n d O f C h u n k s O  ,F i l t e r G e t C h u n k N o S t r e a m O  6F i l t e r G e t T e x t B u f f e r O v e r f l o w  P  2F i l t e r G e t T e x t N o t S u p p o r t e d UP  RF i l t e r G e t V a l u e A l r e a d y C a l l e d O n C u r r e n t C h u n k P  HF i l t e r G e t V a l u e M u s t B e S t r i n g O r D a t e T i m e P  4F i l t e r G e t V a l u e N o t S u p p o r t e d P  8F i l t e r I P e r s i s t F i l e I s R e a d O n l y Q  <F i l t e r I P e r s i s t S t r e a m I s R e a d O n l y OQ  6F i l t e r I n i t I n v a l i d A t t r i b u t e s Q  2F i l t e r L o a d I n v a l i d M o d e F l a g Q  <F i l t e r N u l l G e t T e x t B u f f e r P o i n t e r Q  DF i l t e r P r o p S p e c U n k n o w n U n i o n S e l e c t o r %R  HF i x e d D o c u m e n t E x p e c t s D e p e n d e n c y O b j e c t LR  *F i x e d D o c u m e n t R e a d o n l y R  @F l o w D o c u m e n t F o r m a t t i n g R e e n t r a n c y R  @F l o w D o c u m e n t I n v a l i d C o n t n e t C h a n g e R  \F l o w D o c u m e n t P a g e V i e w e r O n l y S u p p o r t s F l o w D o c u m e n t #S  JF l o w D o c u m e n t R e a d e r C a n H a v e O n l y O n e C h i l d bS  \F l o w D o c u m e n t R e a d e r C a n n o t D i s a b l e A l l V i e w i n g M o d e s S  ~F l o w D o c u m e n t R e a d e r D e c o r a t o r M a r k e d A s C o n t e n t H o s t M u s t H a v e N o C o n t e n t S  XF l o w D o c u m e n t R e a d e r V i e w i n g M o d e E n a b l e d C o n f l i c t S  hF l o w D o c u m e n t R e a d e r _ M u l t i p l e V i e w P r o v i d e r _ P a g e V i e w N a m e NT  lF l o w D o c u m e n t R e a d e r _ M u l t i p l e V i e w P r o v i d e r _ S c r o l l V i e w N a m e VT  nF l o w D o c u m e n t R e a d e r _ M u l t i p l e V i e w P r o v i d e r _ T w o P a g e V i e w N a m e ^T  VF l o w D o c u m e n t S c r o l l V i e w e r C a n H a v e O n l y O n e C h i l d fT  F l o w D o c u m e n t S c r o l l V i e w e r D o c u m e n t B e l o n g s T o A n o t h e r F l o w D o c u m e n t S c r o l l V i e w e r A l r e a d y T  xF l o w D o c u m e n t S c r o l l V i e w e r M a r k e d A s C o n t e n t H o s t M u s t H a v e N o C o n t e n t T  4F o r m a t R e s t r i c t i o n s E x c e e d e d U  F r a m e N o A d d C h i l d ^U  LF r a m e w o r k E l e m e n t F a c t o r y A l r e a d y P a r e n t e d U  HF r a m e w o r k E l e m e n t F a c t o r y C a n n o t A d d T e x t U  FF r a m e w o r k E l e m e n t F a c t o r y M u s t B e S e a l e d U  ,F r e e z a b l e _ C a n t B e F r o z e n 8V  (G e n e r a t i o n I n P r o g r e s s V  .G e n e r a t i o n N o t I n P r o g r e s s V  ,G e n e r a t o r _ C o u n t I s W r o n g V  ,G e n e r a t o r _ I n c o n s i s t e n t W  *G e n e r a t o r _ I t e m I s W r o n g W  (G e n e r a t o r _ M o r e E r r o r s MX  "G e n e r a t o r _ R e a d m e 0 kX  "G e n e r a t o r _ R e a d m e 1 X  "G e n e r a t o r _ R e a d m e 2 kY  "G e n e r a t o r _ R e a d m e 3 Y  "G e n e r a t o r _ R e a d m e 4 Y  "G e n e r a t o r _ R e a d m e 5 Y  "G e n e r a t o r _ R e a d m e 6 Z  "G e n e r a t o r _ R e a d m e 7 [  "G e n e r a t o r _ R e a d m e 8 [  "G e n e r a t o r _ R e a d m e 9 \  "G e n e r a t o r _ U n n a m e d \  "G e t R e s p o n s e F a i l e d \  G e t S t r e a m F a i l e d \  DG l y p h s A d v a n c e W i d t h C a n n o t B e N e g a t i v e ]  BG l y p h s C a r e t S t o p s C o n t a i n s H e x D i g i t s (]  `G l y p h s C a r e t S t o p s L e n g t h C o r r e s p o n d s T o U n i c o d e S t r i n g _]  NG l y p h s C l u s t e r B a d C h a r a c t e r s B e f o r e B r a c k e t ]  >G l y p h s C l u s t e r M i s p l a c e d S e p a r a t o r ]  <G l y p h s C l u s t e r N o M a t c h i n g B r a c k e t &^  :G l y p h s C l u s t e r N o N e s t e d C l u s t e r s `^  <G l y p h s I n d e x R e q u i r e d I f N o U n i c o d e ^  @G l y p h s I n d e x R e q u i r e d W i t h i n C l u s t e r ^  &G l y p h s T o o M a n y C o m m a s _  \G l y p h s U n i c o d e S t r i n g A n d I n d i c e s C a n n o t B o t h B e E m p t y -_  :G l y p h s U n i c o d e S t r i n g I s T o o S h o r t i_  FG r i d C o l l e c t i o n _ C a n n o t M o d i f y R e a d O n l y _  JG r i d C o l l e c t i o n _ D e s t A r r a y I n v a l i d L e n g t h _  RG r i d C o l l e c t i o n _ D e s t A r r a y I n v a l i d L o w e r B o u n d `  FG r i d C o l l e c t i o n _ D e s t A r r a y I n v a l i d R a n k $`  @G r i d C o l l e c t i o n _ I n O t h e r C o l l e c t i o n _`  @G r i d C o l l e c t i o n _ M u s t B e C e r t a i n T y p e `  8G r i d _ U n e x p e c t e d P a r a m e t e r T y p e `  $H a n d l e r T y p e I l l e g a l `   H a s L o g i c a l P a r e n t 	a  <H o s t e d W i n d o w M u s t B e A C h i l d W i n d o w ba  ,H o s t i n g S t a t u s C a n c e l l e d a  0H o s t i n g S t a t u s D o w n l o a d A p p a  8H o s t i n g S t a t u s D o w n l o a d A p p I n f o a  &H o s t i n g S t a t u s F a i l e d a  6H o s t i n g S t a t u s P r e p a r i n g T o R u n a  ,H o s t i n g S t a t u s V e r i f y i n g b  PH w n d H o s t D o e s N o t S u p p o r t C h i l d K e y b o a r d S i n k s 6b  .H y p e r L i n k T a r g e t N o t F o u n d b  $H y p h e n a t o r D i s p o s e d b  2I D P I n v a l i d C o n t e n t P o s i t i o n b  *I D P N e g a t i v e P a g e N u m b e r c  *I c o n M u s t B e B i t m a p F r a m e +c  2I l l e g a l T r e e C h a n g e D e t e c t e d `c  FI l l e g a l T r e e C h a n g e D e t e c t e d P o s t A c t i o n c  BI l l e g a l _ I n h e r i t a n c e B e h a v i o r S e t t o r c  :I m p l e m e n t O t h e r M e m b e r s W i t h S o r t Kd  *I n D i f f e r e n t P a r a g r a p h s d   I n D i f f e r e n t S c o p e d  2I n D i f f e r e n t T e x t C o n t a i n e r s 'e  "I n a v a l i d S t a r t I t e m be  &I n c o m p a t i b l e C L R T e x t we  *I n c o m p a t i b l e W i n F X T e x t e  .I n c o n s i s t e n t B i n d i n g L i s t qf  *I n c o r r e c t A n c h o r L e n g t h &g  ,I n c o r r e c t F l o w D i r e c t i o n Zg  0I n c o r r e c t L o c a t o r P a r t T y p e ~g  :I n d e x e d P r o p D e s c N o t I m p l e m e n t e d g  BI n k C a n v a s D e s e l e c t K e y D i s p l a y S t r i n g g  BI n p u t S c o p e A t t r i b u t e _ E _ O U T O F M E M O R Y g  2I n p u t S t r e a m M u s t B e R e a d a b l e g  8I n s e r t I n D e f e r S e l e c t i o n A c t i v e h  FI n t e g e r C o l l e c t i o n L e n g t h L e s s T h a n Z e r o `h  *I n v a l i d A n c h o r P o s i t i o n h  *I n v a l i d A t t a c h e d A n c h o r h  2I n v a l i d A t t a c h e d A n n o t a t i o n h  *I n v a l i d A t t r i b u t e V a l u e h  "I n v a l i d B y t e R a n g e s i  ,I n v a l i d C l i p b o a r d F o r m a t 'i  0I n v a l i d C o m p o s i t i o n T a r g e t Ui  @I n v a l i d C o n t r o l T e m p l a t e T a r g e t T y p e i  <I n v a l i d C t o r P a r a m e t e r N o I n f i n i t y (j  2I n v a l i d C t o r P a r a m e t e r N o N a N Nj  <I n v a l i d C t o r P a r a m e t e r N o N e g a t i v e oj  RI n v a l i d C t o r P a r a m e t e r U n k n o w n F i g u r e U n i t T y p e j  NI n v a l i d C t o r P a r a m e t e r U n k n o w n G r i d U n i t T y p e 3k  xI n v a l i d C t o r P a r a m e t e r U n k n o w n V i r t u a l i z a t i o n C a c h e L e n g t h U n i t T y p e k  ,I n v a l i d C u s t o m S e r i a l i z e l  (I n v a l i d D S C o n t e n t T y p e Gl  $I n v a l i d D e S e r i a l i z e yl  "I n v a l i d D e p l o y T e x t l  $I n v a l i d D e p l o y T i t l e 
m  I n v a l i d D i a m e t e r 'm  "I n v a l i d E m p t y A r r a y ;m  8I n v a l i d E m p t y S t r o k e C o l l e c t i o n [m   I n v a l i d E n d O f B a m l m  $I n v a l i d E v e n t H a n d l e m  I n v a l i d G u i d m  *I n v a l i d H i g h l i g h t C o l o r n  (I n v a l i d I n k F o r e g r o u n d Xn  (I n v a l i d I t e m C o n t a i n e r n  .I n v a l i d L o c C o m m e n t T a r g e t o  ,I n v a l i d L o c C o m m e n t V a l u e Co  4I n v a l i d L o c a l i z a b i l i t y V a l u e o  $I n v a l i d L o c a t o r P a r t o   I n v a l i d N a m e s p a c e p  :I n v a l i d O p e r a t i o n D u r i n g C l o s i n g 5p  LI n v a l i d O p e r a t i o n _ A d d B a c k E n t r y N o C o n t e n t p  HI n v a l i d O p e r a t i o n _ C a n n o t C l e a r F w d S t a c k p  TI n v a l i d O p e r a t i o n _ C a n n o t R e e n t e r P a g e F u n c t i o n 2q  VI n v a l i d O p e r a t i o n _ C a n t C h a n g e J o u r n a l O w n e r s h i p kq  @I n v a l i d O p e r a t i o n _ I C o m p a r e r F a i l e d q  jI n v a l i d O p e r a t i o n _ M u s t I m p l e m e n t I P C C S O r H a n d l e N a v i g a t i n g q  4I n v a l i d O p e r a t i o n _ N o J o u r n a l ur  .I n v a l i d P a g e F u n c t i o n T y p e r  6I n v a l i d P e r m i s s i o n S t a t e V a l u e r  *I n v a l i d P e r m i s s i o n T y p e 's  I n v a l i d P o i n t Ps  (I n v a l i d P r o p e r t y V a l u e hs  (I n v a l i d S F C o n t e n t T y p e s  *I n v a l i d S e l e c t i o n P a g e s s  $I n v a l i d S e t t e r V a l u e s  @I n v a l i d S t a r t N o d e F o r T e x t S e l e c t i o n 6t  $I n v a l i d S t a r t O f B a m l }t  6I n v a l i d S t i c k y N o t e A n n o t a t i o n t  2I n v a l i d S t i c k y N o t e T e m p l a t e u  6I n v a l i d S t o r y F r a g m e n t s M a r k u p u  2I n v a l i d S t r i n g C o r n e r R a d i u s u  ,I n v a l i d S t r i n g T h i c k n e s s u  LI n v a l i d S t r i n g V i r t u a l i z a t i o n C a c h e L e n g t h Fv  .I n v a l i d S u b T r e e P r o c e s s o r v  &I n v a l i d T e m p F i l e N a m e v  ,I n v a l i d V a l u e F o r T o p L e f t v  *I n v a l i d V a l u e S p e c i f i e d w  "I n v a l i d X m l C o n t e n t %w  :I t e m C o l l e c t i o n H a s N o C o l l e c t i o n Nw  LI t e m C o l l e c t i o n R e m o v e A r g u m e n t O u t O f R a n g e w  HI t e m C o l l e c t i o n S h o u l d U s e I n n e r S y n c R o o t x  VI t e m T e m p l a t e S e l e c t o r B r e a k s D i s p l a y M e m b e r P a t h x  LI t e m s C o n t r o l _ P a r e n t N o t F r a m e w o r k E l e m e n t %y  &I t e m s P a n e l N o t A P a n e l Yy  .I t e m s P a n e l N o t S i n g l e N o d e y   I t e m s S o u r c e I n U s e y  PJ u m p I t e m s R e j e c t e d E v e n t A r g s _ C o u n t M i s m a t c h Nz  <J u m p L i s t _ C a n t A p p l y U n t i l E n d I n i t z  DJ u m p L i s t _ C a n t C a l l U n b a l a n c e d E n d I n i t z  >J u m p L i s t _ C a n t N e s t B e g i n I n i t C a l l s {  6K e y A l i g n C e n t e r D i s p l a y S t r i n g n{  8K e y A l i g n J u s t i f y D i s p l a y S t r i n g v{  2K e y A l i g n L e f t D i s p l a y S t r i n g ~{  4K e y A l i g n R i g h t D i s p l a y S t r i n g {  .K e y A l t U n d o D i s p l a y S t r i n g {  $K e y A p p l y B a c k g r o u n d {  >K e y A p p l y B a c k g r o u n d D i s p l a y S t r i n g {  @K e y A p p l y D o u b l e S p a c e D i s p l a y S t r i n g {  $K e y A p p l y F o n t F a m i l y {  >K e y A p p l y F o n t F a m i l y D i s p l a y S t r i n g {   K e y A p p l y F o n t S i z e {  :K e y A p p l y F o n t S i z e D i s p l a y S t r i n g {  $K e y A p p l y F o r e g r o u n d {  >K e y A p p l y F o r e g r o u n d D i s p l a y S t r i n g {  JK e y A p p l y O n e A n d A H a l f S p a c e D i s p l a y S t r i n g {  @K e y A p p l y S i n g l e S p a c e D i s p l a y S t r i n g {  2K e y B a c k s p a c e D i s p l a y S t r i n g {  4K e y C o l l e c t i o n H a s I n v a l i d K e y {  (K e y C o p y D i s p l a y S t r i n g |  4K e y C o p y F o r m a t D i s p l a y S t r i n g |  "K e y C o r r e c t i o n L i s t %|  <K e y C o r r e c t i o n L i s t D i s p l a y S t r i n g '|  4K e y C t r l I n s e r t D i s p l a y S t r i n g )|  &K e y C u t D i s p l a y S t r i n g 6|  @K e y D e c r e a s e F o n t S i z e D i s p l a y S t r i n g >|  FK e y D e c r e a s e I n d e n t a t i o n D i s p l a y S t r i n g T|  :K e y D e l e t e C o l u m n s D i s p l a y S t r i n g b|  ,K e y D e l e t e D i s p l a y S t r i n g t|  <K e y D e l e t e N e x t W o r d D i s p l a y S t r i n g ||  DK e y D e l e t e P r e v i o u s W o r d D i s p l a y S t r i n g |  K e y D e l e t e R o w s |  4K e y D e l e t e R o w s D i s p l a y S t r i n g |  <K e y E n t e r L i n e B r e a k D i s p l a y S t r i n g |  FK e y E n t e r P a r a g r a p h B r e a k D i s p l a y S t r i n g |  @K e y I n c r e a s e F o n t S i z e D i s p l a y S t r i n g |  FK e y I n c r e a s e I n d e n t a t i o n D i s p l a y S t r i n g |  :K e y I n s e r t C o l u m n s D i s p l a y S t r i n g |  4K e y I n s e r t R o w s D i s p l a y S t r i n g |  6K e y I n s e r t T a b l e D i s p l a y S t r i n g |  4K e y M e r g e C e l l s D i s p l a y S t r i n g }  <K e y M o v e D o w n B y L i n e D i s p l a y S t r i n g }  <K e y M o v e D o w n B y P a g e D i s p l a y S t r i n g !}  FK e y M o v e D o w n B y P a r a g r a p h D i s p l a y S t r i n g +}  FK e y M o v e L e f t B y C h a r a c t e r D i s p l a y S t r i n g ;}  <K e y M o v e L e f t B y W o r d D i s p l a y S t r i n g C}  HK e y M o v e R i g h t B y C h a r a c t e r D i s p l a y S t r i n g S}  >K e y M o v e R i g h t B y W o r d D i s p l a y S t r i n g [}  >K e y M o v e T o C o l u m n E n d D i s p l a y S t r i n g k}  BK e y M o v e T o C o l u m n S t a r t D i s p l a y S t r i n g y}  BK e y M o v e T o D o c u m e n t E n d D i s p l a y S t r i n g }  FK e y M o v e T o D o c u m e n t S t a r t D i s p l a y S t r i n g }  :K e y M o v e T o L i n e E n d D i s p l a y S t r i n g }  >K e y M o v e T o L i n e S t a r t D i s p l a y S t r i n g }  DK e y M o v e T o W i n d o w B o t t o m D i s p l a y S t r i n g }  >K e y M o v e T o W i n d o w T o p D i s p l a y S t r i n g }  8K e y M o v e U p B y L i n e D i s p l a y S t r i n g }  8K e y M o v e U p B y P a g e D i s p l a y S t r i n g }  BK e y M o v e U p B y P a r a g r a p h D i s p l a y S t r i n g }  6K e y P a s t e F o r m a t D i s p l a y S t r i n g }  (K e y R e d o D i s p l a y S t r i n g }  BK e y R e m o v e L i s t M a r k e r s D i s p l a y S t r i n g ~  6K e y R e s e t F o r m a t D i s p l a y S t r i n g ~  2K e y S e l e c t A l l D i s p l a y S t r i n g "~  @K e y S e l e c t D o w n B y L i n e D i s p l a y S t r i n g *~  @K e y S e l e c t D o w n B y P a g e D i s p l a y S t r i n g ;~  JK e y S e l e c t D o w n B y P a r a g r a p h D i s p l a y S t r i n g K~  JK e y S e l e c t L e f t B y C h a r a c t e r D i s p l a y S t r i n g a~  @K e y S e l e c t L e f t B y W o r d D i s p l a y S t r i n g r~  LK e y S e l e c t R i g h t B y C h a r a c t e r D i s p l a y S t r i n g ~  BK e y S e l e c t R i g h t B y W o r d D i s p l a y S t r i n g ~  BK e y S e l e c t T o C o l u m n E n d D i s p l a y S t r i n g ~  FK e y S e l e c t T o C o l u m n S t a r t D i s p l a y S t r i n g ~  FK e y S e l e c t T o D o c u m e n t E n d D i s p l a y S t r i n g ~  JK e y S e l e c t T o D o c u m e n t S t a r t D i s p l a y S t r i n g ~  >K e y S e l e c t T o L i n e E n d D i s p l a y S t r i n g ~  BK e y S e l e c t T o L i n e S t a r t D i s p l a y S t r i n g   HK e y S e l e c t T o W i n d o w B o t t o m D i s p l a y S t r i n g   BK e y S e l e c t T o W i n d o w T o p D i s p l a y S t r i n g &  <K e y S e l e c t U p B y L i n e D i s p l a y S t r i n g =  <K e y S e l e c t U p B y P a g e D i s p l a y S t r i n g N  FK e y S e l e c t U p B y P a r a g r a p h D i s p l a y S t r i n g \  <K e y S h i f t B a c k s p a c e D i s p l a y S t r i n g r  6K e y S h i f t D e l e t e D i s p l a y S t r i n g   6K e y S h i f t I n s e r t D i s p l a y S t r i n g   4K e y S h i f t S p a c e D i s p l a y S t r i n g   *K e y S p a c e D i s p l a y S t r i n g   2K e y S p l i t C e l l D i s p l a y S t r i n g   BK e y S w i t c h V i e w i n g M o d e D i s p l a y S t r i n g   6K e y T a b B a c k w a r d D i s p l a y S t r i n g   4K e y T a b F o r w a r d D i s p l a y S t r i n g   4K e y T o g g l e B o l d D i s p l a y S t r i n g   :K e y T o g g l e B u l l e t s D i s p l a y S t r i n g   8K e y T o g g l e I n s e r t D i s p l a y S t r i n g   8K e y T o g g l e I t a l i c D i s p l a y S t r i n g   >K e y T o g g l e N u m b e r i n g D i s p l a y S t r i n g   &K e y T o g g l e S p e l l C h e c k   @K e y T o g g l e S p e l l C h e c k D i s p l a y S t r i n g   >K e y T o g g l e S u b s c r i p t D i s p l a y S t r i n g    BK e y T o g g l e S u p e r s c r i p t D i s p l a y S t r i n g .  >K e y T o g g l e U n d e r l i n e D i s p l a y S t r i n g B  (K e y U n d o D i s p l a y S t r i n g J  .K i l l B i t E n f o r c e d S h u t d o w n R  &K n o w n T y p e I d N e g a t i v e   "L e n g t h F o r m a t E r r o r   0L i s t B o x I n v a l i d A n c h o r I t e m !  @L i s t B o x S e l e c t A l l K e y D i s p l a y S t r i n g `  :L i s t B o x S e l e c t A l l S e l e c t i o n M o d e h  (L i s t B o x S e l e c t A l l T e x t   <L i s t E l e m e n t I t e m N o t A C h i l d O f L i s t   VL i s t V i e w _ G r i d V i e w C o l u m n C o l l e c t i o n I s R e a d O n l y   8L i s t V i e w _ I l l e g a l C h i l d r e n T y p e '  PL i s t V i e w _ M i s s i n g P a r a m e t e r l e s s C o n s t r u c t o r c  bL i s t V i e w _ N o t A l l o w S h a r e C o l u m n T o T w o C o l u m n C o l l e c t i o n   6L i s t V i e w _ V i e w C a n n o t B e S h a r e d   L o g i c a l T r e e L o o p   L o o p D e t e c t e d   0M a r k u p E x t e n s i o n B a d S t a t i c )  VM a r k u p E x t e n s i o n D y n a m i c O r B i n d i n g I n C o l l e c t i o n   PM a r k u p E x t e n s i o n D y n a m i c O r B i n d i n g O n C l r P r o p   0M a r k u p E x t e n s i o n N o C o n t e x t   .M a r k u p E x t e n s i o n P r o p e r t y   4M a r k u p E x t e n s i o n R e s o u r c e K e y /  >M a r k u p E x t e n s i o n R e s o u r c e N o t F o u n d   6M a r k u p E x t e n s i o n S t a t i c M e m b e r   NM a r k u p W r i t e r _ C a n n o t S e r i a l i z e G e n e r i c t y p e   XM a r k u p W r i t e r _ C a n n o t S e r i a l i z e N e s t e d P u b l i c t y p e %  RM a r k u p W r i t e r _ C a n n o t S e r i a l i z e N o n P u b l i c t y p e W  4M a x L e n g t h E x c e e d s B u f f e r S i z e   .M a x i m u m N o t e S i z e E x c e e d e d   0M e a s u r e R e e n t r a n c y I n v a l i d   nM e d i a E l e m e n t _ C a n n o t S e t S o u r c e O n M e d i a E l e m e n t D r i v e n B y C l o c k ?  >M e m b e r N o t A l l o w e d D u r i n g A d d O r E d i t y  BM e m b e r N o t A l l o w e d D u r i n g T r a n s a c t i o n   .M e m b e r N o t A l l o w e d F o r V i e w   >M i s s i n g A n n o t a t i o n H i g h l i g h t L a y e r   (M i s s i n g C o n t e n t S o u r c e <  *M i s s i n g T a g I n N a m e s p a c e   ,M i s s i n g T r i g g e r P r o p e r t y   *M i s s i n g V a l u e C o n v e r t e r   >M o d i f i c a t i o n E a r l i e r T h a n C r e a t i o n   VM o d i f y i n g L o g i c a l T r e e V i a S t y l e s N o t I m p l e m e n t e d 4  :M o r e T h a n O n e A t t a c h e d A n n o t a t i o n   0M o r e T h a n O n e S t a r t i n g P a r t s   4M o v e I n D e f e r S e l e c t i o n A c t i v e   4M u l t i B i n d i n g H a s N o C o n v e r t e r $  ,M u l t i S e l e c t o r S e l e c t A l l k  M u l t i S i n g l e t o n   RM u l t i T h r e a d e d C o l l e c t i o n C h a n g e N o t S u p p o r t e d   .M u l t i p l e A s s e m b l y M a t c h e s n  4M u s t B a s e O n S t y l e O f A B a s e T y p e   M u s t B e C o n d i t i o n   ,M u s t B e F r a m e w o r k D e r i v e d B  4M u s t B e F r a m e w o r k O r 3 D D e r i v e d   M u s t B e O f T y p e   &M u s t B e T r i g g e r A c t i o n   $M u s t B e T y p e O r S t r i n g \  0M u s t I m p l e m e n t I U r i C o n t e x t   DM u s t N o t T e m p l a t e U n a s s o c i a t e d C o n t r o l   ,M u s t U s e W i n d o w S t y l e N o n e z  $N a m e N o t E m p t y S t r i n g   N a m e N o t F o u n d   BN a m e S c o p e D u p l i c a t e N a m e s N o t A l l o w e d 0  <N a m e S c o p e I n v a l i d I d e n t i f i e r N a m e g  6N a m e S c o p e N a m e N o t E m p t y S t r i n g   *N a m e S c o p e N a m e N o t F o u n d   "N a m e S c o p e N o t F o u n d   BN a m e d O b j e c t M u s t B e F r a m e w o r k E l e m e n t   RN a m e s N o t S u p p o r t e d I n s i d e R e s o u r c e D i c t i o n a r y 9  0N a v W i n d o w M e n u C u r r e n t P a g e l  $N e e d T o B e C o m V i s i b l e w  N e g a t i v e V a l u e   6N e s t e d B e g i n I n i t N o t S u p p o r t e d    N o A d d C h i l d =  8N o A t t a c h e d A n n o t a t i o n T o M o d i f y u  N o B a c k E n t r y   6N o C h e c k O r C h a n g e W h e n D e f e r r e d   8N o D e f a u l t U p d a t e S o u r c e T r i g g e r 4  N o E l e m e n t   N o E l e m e n t O b j e c t   N o F o r w a r d E n t r y *  &N o M u l t i c a s t H a n d l e r s k  HN o P r e s e n t a t i o n C o n t e x t F o r G i v e n E l e m e n t   6N o P r o c e s s o r F o r S e l e c t i o n T y p e    N o S c o p i n g E l e m e n t   dN o U p d a t e S o u r c e T r i g g e r F o r I n n e r B i n d i n g O f M u l t i B i n d i n g 9  N o n C L S E x c e p t i o n   2N o n C l s A c t i v a t i o n E x c e p t i o n   >N o n P a c k A p p A b s o l u t e U r i N o t A l l o w e d   >N o n P a c k S o o A b s o l u t e U r i N o t A l l o w e d   ,N o n W h i t e S p a c e I n A d d T e x t   (N o t A l l o w e d B e f o r e S h o w .  4N o t H i g h l i g h t A n n o t a t i o n T y p e l  0N o t I n A s s o c i a t e d C o n t a i n e r   &N o t I n A s s o c i a t e d T r e e   N o t I n T h i s T r e e   N o t S u p p o r t e d 5  *N o t S u p p o r t e d I n B r o w s e r o  N u l l P a r e n t N o d e   &N u l l P r o p e r t y I l l e g a l   N u l l T y p e I l l e g a l   N u l l U r i   LO b j e c t D a t a P r o v i d e r C a n H a v e O n l y O n e S o u r c e M  :O b j e c t D a t a P r o v i d e r H a s N o S o u r c e   BO b j e c t D a t a P r o v i d e r N o n C L S E x c e p t i o n   NO b j e c t D a t a P r o v i d e r N o n C L S E x c e p t i o n I n v o k e /  ^O b j e c t D a t a P r o v i d e r P a r a m e t e r C o l l e c t i o n I s N o t I n U s e   4O b j e c t D i s p o s e d _ S t o r e C l o s e d   2O n l y F l o w A n d F i x e d S u p p o r t e d !  ,O n l y F l o w F i x e d S u p p o r t e d m  P T S E r r o r    P T S I n v a l i d H a n d l e   .P a g e C a c h e S i z e N o t A l l o w e d 5  :P a g e C a n n o t H a v e M u l t i p l e C o n t e n t   &P a g e C o n t e n t N o t F o u n d   <P a g e C o n t e n t U n s u p p o r t e d M i m e T y p e   <P a g e C o n t e n t U n s u p p o r t e d P a g e T y p e X  &P a n e l I s N o t I t e m s H o s t   6P a n e l _ B o u n d P a n e l _ N o C h i l d r e n   4P a n e l _ I t e m s C o n t r o l N o t F o u n d S  (P a n e l _ N o N u l l C h i l d r e n   0P a n e l _ N o N u l l V i s u a l P a r e n t    2P a r a m e t e r C a n n o t B e N e g a t i v e L  4P a r a m e t e r M u s t B e L o g i c a l N o d e o  >P a r e n t O f P a g e M u s t B e W i n d o w O r F r a m e   @P a r s e r A b a n d o n e d T y p e C o n v e r t e r T e x t   "P a r s e r A s y n c O n R o o t k  <P a r s e r A t t a c h e d P r o p I n h e r i t E r r o r   ,P a r s e r A t t r i b u t e A r g s L o w   @P a r s e r A t t r i b u t e N a m e s p a c e M i s M a t c h   *P a r s e r B a d A s s e m b l y N a m e X  *P a r s e r B a d A s s e m b l y P a t h   P a r s e r B a d C h i l d   4P a r s e r B a d C o n s t r u c t o r P a r a m s %  "P a r s e r B a d E n c o d i n g l  P a r s e r B a d K e y   0P a r s e r B a d M e m b e r R e f e r e n c e @  P a r s e r B a d N a m e   *P a r s e r B a d N u l l a b l e T y p e   P a r s e r B a d S t r i n g f  "P a r s e r B a d S y n c M o d e   8P a r s e r B a d T y p e I n A r r a y P r o p e r t y   (P a r s e r B a d U i d O r N a m e M E W  P a r s e r B a m l E v e n t   "P a r s e r B a m l V e r s i o n   2P a r s e r C a n O n l y H a v e O n e C h i l d F  4P a r s e r C a n n o t A d d A n y C h i l d r e n   6P a r s e r C a n n o t A d d A n y C h i l d r e n 2   (P a r s e r C a n n o t A d d C h i l d   JP a r s e r C a n n o t C o n v e r t I n i t i a l i z a t i o n T e x t D  @P a r s e r C a n n o t C o n v e r t P r o p e r t y V a l u e |  LP a r s e r C a n n o t C o n v e r t P r o p e r t y V a l u e S t r i n g   2P a r s e r C a n n o t C o n v e r t S t r i n g   6P a r s e r C a n n o t R e u s e X a m l R e a d e r W  (P a r s e r C a n n o t S e t V a l u e   0P a r s e r C a n t C r e a t e D e l e g a t e   8P a r s e r C a n t C r e a t e I n s t a n c e T y p e t  >P a r s e r C a n t C r e a t e T e x t C o m p l e x P r o p   &P a r s e r C a n t G e t D P O r P i   *P a r s e r C a n t G e t P r o p e r t y   ,P a r s e r C a n t S e t A t t r i b u t e    8P a r s e r C a n t S e t C o n t e n t P r o p e r t y M  :P a r s e r C a n t S e t T r i g g e r C o n d i t i o n   *P a r s e r C o m p a t D u p l i c a t e ;  :P a r s e r C o n t e n t M u s t B e C o n t i g u o u s   :P a r s e r D e f S h a r e d O n l y I n C o m p i l e d 2  P a r s e r D e f T a g   :P a r s e r D e f a u l t C o n v e r t e r E l e m e n t )  <P a r s e r D e f a u l t C o n v e r t e r P r o p e r t y {  .P a r s e r D e f e r C o n t e n t A s y n c   ,P a r s e r D i c t i o n a r y S e a l e d #  ,P a r s e r D u p D i c t i o n a r y K e y W  LP a r s e r D u p l i c a t e M a r k u p E x t e n s i o n P r o p e r t y   0P a r s e r D u p l i c a t e P r o p e r t y 1   0P a r s e r D u p l i c a t e P r o p e r t y 2   ,P a r s e r E m p t y C o m p l e x P r o p a  *P a r s e r E n t i t y R e f e r e n c e   .P a r s e r E r r o r C o n t e x t _ F i l e   8P a r s e r E r r o r C o n t e x t _ F i l e _ L i n e   .P a r s e r E r r o r C o n t e x t _ L i n e 4  .P a r s e r E r r o r C o n t e x t _ T y p e U  8P a r s e r E r r o r C o n t e x t _ T y p e _ F i l e u  BP a r s e r E r r o r C o n t e x t _ T y p e _ F i l e _ L i n e   8P a r s e r E r r o r C o n t e x t _ T y p e _ L i n e   6P a r s e r E r r o r C r e a t i n g I n s t a n c e %  0P a r s e r E r r o r P a r s i n g A t t r i b i  8P a r s e r E r r o r P a r s i n g A t t r i b T y p e   HP a r s e r E v e n t D e l e g a t e T y p e N o t A c c e s s i b l e   $P a r s e r F a i l F i n d T y p e   &P a r s e r F a i l e d E n d I n i t   FP a r s e r F a i l e d T o C r e a t e F r o m C o n s t r u c t o r J  hP a r s e r F i l t e r X m l R e a d e r N o D e f i n i t i o n P r e f i x C h a n g e A l l o w e d j  VP a r s e r F i l t e r X m l R e a d e r N o I n d e x A t t r i b u t e A c c e s s   &P a r s e r I A d d C h i l d T e x t +  4P a r s e r I E n u m e r a b l e I A d d C h i l d l  JP a r s e r I n v a l i d C o n t e n t P r o p e r t y A t t r i b u t e   6P a r s e r I n v a l i d I d e n t i f i e r N a m e   2P a r s e r I n v a l i d S t a t i c M e m b e r ;  :P a r s e r K e y O n E x p l i c i t D i c t i o n a r y v  (P a r s e r K e y s A r e S t r i n g s   &P a r s e r L i n e A n d O f f s e t   4P a r s e r M a p P I M i s s i n g A s s e m b l y 7  *P a r s e r M a p P I M i s s i n g K e y   .P a r s e r M a p p i n g U r i I n v a l i d   PP a r s e r M a r k u p E x t e n s i o n B a d C o n s t r u c t o r P a r a m $  BP a r s e r M a r k u p E x t e n s i o n B a d D e l i m i t e r n  dP a r s e r M a r k u p E x t e n s i o n D e l i m i t e r B e f o r e F i r s t A t t r i b u t e   fP a r s e r M a r k u p E x t e n s i o n I n v a l i d C l o s i n g B r a c k e t C h a r a c e r s   \P a r s e r M a r k u p E x t e n s i o n M a l f o r m e d B r a c k e t C h a r a c e r s   @P a r s e r M a r k u p E x t e n s i o n N o E n d C u r l i e w  @P a r s e r M a r k u p E x t e n s i o n N o N a m e V a l u e   FP a r s e r M a r k u p E x t e n s i o n N o Q u o t e s I n N a m e 1  HP a r s e r M a r k u p E x t e n s i o n T r a i l i n g G a r b a g e   @P a r s e r M a r k u p E x t e n s i o n U n k n o w n A t t r   6P a r s e r M e t r o U n k n o w n A t t r i b u t e !   P a r s e r M u l t i B a m l s   P a r s e r M u l t i R o o t   .P a r s e r N e s t e d C o m p l e x P r o p   "P a r s e r N o A t t r A r r a y 6  &P a r s e r N o C h i l d r e n T a g `  (P a r s e r N o C o m p l e x M u l t i   "P a r s e r N o D P O n O w n e r   4P a r s e r N o D e f a u l t C o n s t r u c t o r |  <P a r s e r N o D e f a u l t P r o p C o n s t r u c t o r   *P a r s e r N o D i c t i o n a r y K e y   ,P a r s e r N o D i c t i o n a r y N a m e   $P a r s e r N o D i g i t E n u m s \  ,P a r s e r N o E l e m e n t C r e a t e 2    P a r s e r N o E v e n t T a g 3  P a r s e r N o E v e n t s w  *P a r s e r N o M a t c h i n g A r r a y   6P a r s e r N o M a t c h i n g I D i c t i o n a r y   *P a r s e r N o M a t c h i n g I L i s t n  $P a r s e r N o N a m e O n T y p e   HP a r s e r N o N a m e U n d e r D e f i n i t i o n S c o p e T y p e )  "P a r s e r N o N a m e s p a c e   8P a r s e r N o N e s t e d X m l D a t a I s l a n d s   2P a r s e r N o P r o p O n C o m p l e x P r o p    P a r s e r N o P r o p T y p e @   P a r s e r N o R e s o u r c e i  $P a r s e r N o S e r i a l i z e r   &P a r s e r N o S e t t e r C h i l d    P a r s e r N o T y p e E   P a r s e r N o T y p e C o n v   8P a r s e r N o t A l l o w e d I n t e r n a l T y p e   *P a r s e r N o t M a r k e d P u b l i c   0P a r s e r N o t M a r k u p E x t e n s i o n L  8P a r s e r N u l l P r o p e r t y C o l l e c t i o n   $P a r s e r N u l l R e t u r n e d   8P a r s e r O w n e r E v e n t M u s t B e P u b l i c   P a r s e r P a r e n t D O   *P a r s e r P r e f i x N S E l e m e n t =  ,P a r s e r P r e f i x N S P r o p e r t y   "P a r s e r P r o p N o V a l u e   <P a r s e r P r o p e r t y C o l l e c t i o n C l o s e d "  8P a r s e r P r o v i d e V a l u e C a n t S e t U r i    P a r s e r P u b l i c T y p e   4P a r s e r R e a d O n l y N u l l P r o p e r t y   $P a r s e r R e a d O n l y P r o p q  *P a r s e r R e s o u r c e K e y T y p e    P a r s e r S y n c O n R o o t   .P a r s e r T e x t I n C o m p l e x P r o p   HP a r s e r T e x t I n v a l i d I n A r r a y O r D i c t i o n a r y d  .P a r s e r T o o M a n y A s s e m b l i e s   LP a r s e r T y p e C o n v e r t e r T e x t N e e d s E n d E l e m e n t   >P a r s e r T y p e C o n v e r t e r T e x t U n u s a b l e %  $P a r s e r U n d e c l a r e d N S   "P a r s e r U n e x p I n B A M L   ,P a r s e r U n e x p e c t e d E n d E l e    ,P a r s e r U n k n o w n A t t r i b u t e c  "P a r s e r U n k n o w n B a m l   2P a r s e r U n k n o w n D e f A t t r i b u t e   BP a r s e r U n k n o w n D e f A t t r i b u t e C o m p i l e r w  RP a r s e r U n k n o w n P r e s e n t a t i o n O p t i o n s A t t r i b u t e    P a r s e r U n k n o w n T a g P  (P a r s e r U n k n o w n X m l T y p e   *P a r s e r W r i t e r N o S e e k E n d   2P a r s e r W r i t e r U n k n o w n O r i g i n   ,P a r s e r X m l I s l a n d M i s s i n g ,  2P a r s e r X m l I s l a n d U n e x p e c t e d   BP a r s e r X m l L a n g P r o p e r t y V a l u e I n v a l i d   2P a r s e r X m l R e a d e r N o L i n e I n f o /  HP a r t i a l T r u s t P r i n t D i a l o g M u s t B e I n v o k e d   >P a s s w o r d B o x I n v a l i d T e x t C o n t a i n e r   &P a t h P a r a m e t e r I s N u l l   :P a t h P a r a m e t e r s I n d e x O u t O f R a n g e G  P a t h S y n t a x   0P l a t f o r m R e q u i r e m e n t T i t l e   0P o p u p R e o p e n i n g N o t A l l o w e d   <P o s i t i o n a l A r g u m e n t s W r o n g L e n g t h +  JP r e v o i u s P a r t i a l P a g e C o n t e n t O u t s t a n d i n g q  bP r e v o i u s U n i n i t i a l i z e d D o c u m e n t R e f e r e n c e O u t s t a n d i n g   JP r i n t D i a l o g I n s t a l l P r i n t S u p p o r t C a p t i o n 	  PP r i n t D i a l o g I n s t a l l P r i n t S u p p o r t M e s s a g e B o x   6P r i n t D i a l o g I n v a l i d P a g e R a n g e   (P r i n t D i a l o g P a g e R a n g e   2P r i n t D i a l o g Z e r o N o t A l l o w e d   &P r i n t J o b D e s c r i p t i o n   &P r o g r e s s B a r R e a d O n l y   @P r o p e r t y F o u n d O u t s i d e S t a r t E l e m e n t 1  .P r o p e r t y I d O u t O f S e q u e n c e y  &P r o p e r t y I s I m m u t a b l e   0P r o p e r t y I s I n i t i a l i z e O n l y    *P r o p e r t y M u s t H a v e V a l u e G  &P r o p e r t y N o t B i n d a b l e    P r o p e r t y N o t F o u n d   (P r o p e r t y N o t S u p p o r t e d   $P r o p e r t y O u t O f O r d e r /  4P r o p e r t y P a t h I n d e x W r o n g T y p e ^  6P r o p e r t y P a t h I n v a l i d A c c e s s o r   .P r o p e r t y P a t h N o O w n e r T y p e ;  ,P r o p e r t y P a t h N o P r o p e r t y s  .P r o p e r t y P a t h S y n t a x E r r o r   <P r o p e r t y T o S o r t B y N o t F o u n d O n T y p e   8P r o p e r t y T r i g g e r C y c l e D e t e c t e d ?  BP r o p e r t y T r i g g e r L a y e r L i m i t E x c e e d e d   0R a n g e A c t i o n s N o t S u p p o r t e d   "R e a d C o u n t N e g a t i v e    R e a d N o t S u p p o r t e d %  4R e a d O n l y P r o p e r t y N o t A l l o w e d <   R e c o r d O u t O f O r d e r w  FR e c t _ W i d t h A n d H e i g h t C a n n o t B e N e g a t i v e   DR e l a t i v e S o u r c e I n v a l i d A n c e s t o r L e v e l   2R e l a t i v e S o u r c e M o d e I n v a l i d %  :R e l a t i v e S o u r c e M o d e I s I m m u t a b l e O  >R e l a t i v e S o u r c e N e e d s A n c e s t o r T y p e   .R e l a t i v e S o u r c e N e e d s M o d e 3  FR e l a t i v e S o u r c e N o t I n F i n d A n c e s t o r M o d e \  0R e m o v e R e q u i r e s O f f s e t Z e r o   6R e m o v e R e q u i r e s P o s i t i v e C o u n t   &R e m o v e d I t e m N o t F o u n d   &R e m o v i n g P l a c e h o l d e r F  2R e p a r e n t M o d e l C h i l d I l l e g a l l  NR e q u e s t N a v i g a t e E v e n t M u s t H a v e R o u t e d E v e n t   0R e q u i r e d A t t r i b u t e M i s s i n g   .R e q u i r e s E x p l i c i t C u l t u r e D  6R e q u i r e s X m l N a m e s p a c e M a p p i n g   <R e q u i r e s X m l N a m e s p a c e M a p p i n g U r i A   R e s h o w N o t A l l o w e d   PR e s o u r c e D i c t i o n a r y D e f e r r e d C o n t e n t F a i l u r e   TR e s o u r c e D i c t i o n a r y D u p l i c a t e D e f e r r e d C o n t e n t j  RR e s o u r c e D i c t i o n a r y I n v a l i d M e r g e d D i c t i o n a r y   8R e s o u r c e D i c t i o n a r y I s R e a d O n l y A  BR e s o u r c e D i c t i o n a r y L o a d F r o m F a i l u r e t  HR e t u r n E v e n t H a n d l e r M u s t B e O n P a r e n t P a g e   XR i c h T e x t B o x _ C a n t S e t D o c u m e n t I n s i d e C h a n g e B l o c k   lR i c h T e x t B o x _ D o c u m e n t B e l o n g s T o A n o t h e r R i c h T e x t B o x A l r e a d y n  HR i c h T e x t B o x _ P o i n t e r N o t I n S a m e D o c u m e n t   JR o w C a c h e C a n n o t M o d i f y N o n E x i s t e n t L a y o u t   (R o w C a c h e P a g e N o t F o u n d   :R o w C a c h e R e c a l c W i t h N o P a g e C a c h e 4  &R u n t i m e T y p e R e q u i r e d h  8S c r o l l B a r _ C o n t e x t M e n u _ B o t t o m   <S c r o l l B a r _ C o n t e x t M e n u _ L e f t E d g e   <S c r o l l B a r _ C o n t e x t M e n u _ P a g e D o w n   <S c r o l l B a r _ C o n t e x t M e n u _ P a g e L e f t   >S c r o l l B a r _ C o n t e x t M e n u _ P a g e R i g h t   8S c r o l l B a r _ C o n t e x t M e n u _ P a g e U p   >S c r o l l B a r _ C o n t e x t M e n u _ R i g h t E d g e    @S c r o l l B a r _ C o n t e x t M e n u _ S c r o l l D o w n   @S c r o l l B a r _ C o n t e x t M e n u _ S c r o l l H e r e   @S c r o l l B a r _ C o n t e x t M e n u _ S c r o l l L e f t '  BS c r o l l B a r _ C o n t e x t M e n u _ S c r o l l R i g h t 5  <S c r o l l B a r _ C o n t e x t M e n u _ S c r o l l U p C  2S c r o l l B a r _ C o n t e x t M e n u _ T o p Q  0S c r o l l V i e w e r _ C a n n o t B e N a N V  .S c r o l l V i e w e r _ O u t O f R a n g e z  `S e c u r i t y E x c e p t i o n F o r S e t t i n g S a n d b o x E x t e r n a l T o T r u e   S e e k F a i l e d   S e e k N e g a t i v e 9   S e e k N o t S u p p o r t e d h  JS e l e c t e d C e l l s C o l l e c t i o n _ D u p l i c a t e I t e m ~  FS e l e c t e d C e l l s C o l l e c t i o n _ I n v a l i d I t e m   *S e l e c t i o n C h a n g e A c t i v e   0S e l e c t i o n C h a n g e N o t A c t i v e   <S e l e c t i o n D o e s N o t R e s o l v e T o A P a g e &  <S e l e c t i o n M u s t B e S e r v i c e P r o v i d e r \  FS e r i a l i z e r P r o v i d e r A l r e a d y R e g i s t e r e d   8S e r i a l i z e r P r o v i d e r C a n n o t L o a d   TS e r i a l i z e r P r o v i d e r D e f a u l t F i l e E x t e n s i o n N u l l   BS e r i a l i z e r P r o v i d e r D i s p l a y N a m e N u l l N  LS e r i a l i z e r P r o v i d e r M a n u f a c t u r e r N a m e N u l l   RS e r i a l i z e r P r o v i d e r M a n u f a c t u r e r W e b s i t e N u l l   >S e r i a l i z e r P r o v i d e r N o t R e g i s t e r e d   FS e r i a l i z e r P r o v i d e r U n k n o w n S e r i a l i z e r J  <S e r i a l i z e r P r o v i d e r W r o n g V e r s i o n |  S e t F o c u s F a i l e d   2S e t I n D e f e r S e l e c t i o n A c t i v e   *S e t L e n g t h N o t S u p p o r t e d <  .S e t P o s i t i o n N o t S u p p o r t e d [  FS e t t e r O n S t y l e N o t A l l o w e d T o H a v e T a r g e t   0S e t t e r V a l u e C a n n o t B e U n s e t   PS e t t e r V a l u e O f M a r k u p E x t e n s i o n N o t S u p p o r t e d   4S h a r e d A t t r i b u t e I n L o o s e X a m l   "S h o w D i a l o g O n M o d a l 
  &S h o w D i a l o g O n V i s i b l e 2  8S h o w N o n A c t i v a t e d A n d M a x i m i z e d `  6S h u t d o w n M o d e W h e n A p p S h u t d o w n   JS o u r c e N a m e N o t S u p p o r t e d F o r D a t a T r i g g e r s   LS o u r c e N a m e N o t S u p p o r t e d F o r S t y l e T r i g g e r s F  <S t a c k _ V i s u a l I n D i f f e r e n t S u b T r e e   6S t a r t I n d e x E x c e e d s B u f f e r S i z e   TS t a r t N o d e M u s t B e D o c u m e n t P a g e V i e w O r F i x e d P a g e Q  :S t a r t N o d e M u s t B e F i x e d P a g e P r o x y   0S t a t i c R e s o u r c e I n X a m l O n l y   8S t o r y b o a r d _ A n i m a t i o n M i s m a t c h   LS t o r y b o a r d _ B e g i n S t o r y b o a r d N a m e N o t F o u n d O  LS t o r y b o a r d _ B e g i n S t o r y b o a r d N a m e R e q u i r e d   LS t o r y b o a r d _ B e g i n S t o r y b o a r d N o S t o r y b o a r d   DS t o r y b o a r d _ C o m p l e x P a t h N o t S u p p o r t e d   LS t o r y b o a r d _ I m m u t a b l e T a r g e t N o t S u p p o r t e d   >S t o r y b o a r d _ M e d i a E l e m e n t N o t F o u n d   >S t o r y b o a r d _ M e d i a E l e m e n t R e q u i r e d 5  .S t o r y b o a r d _ N a m e N o t F o u n d   .S t o r y b o a r d _ N e v e r A p p l i e d   ,S t o r y b o a r d _ N o N a m e S c o p e /  &S t o r y b o a r d _ N o T a r g e t j  8S t o r y b o a r d _ P r o p e r t y P a t h E m p t y   PS t o r y b o a r d _ P r o p e r t y P a t h F r o z e n C h e c k F a i l e d   hS t o r y b o a r d _ P r o p e r t y P a t h I n c l u d e s N o n A n i m a t a b l e P r o p e r t y   dS t o r y b o a r d _ P r o p e r t y P a t h M u s t P o i n t T o D e p e n d e n c y O b j e c t R  hS t o r y b o a r d _ P r o p e r t y P a t h M u s t P o i n t T o D e p e n d e n c y P r o p e r t y   JS t o r y b o a r d _ P r o p e r t y P a t h O b j e c t N o t F o u n d   NS t o r y b o a r d _ P r o p e r t y P a t h P r o p e r t y N o t F o u n d   PS t o r y b o a r d _ P r o p e r t y P a t h S e a l e d C h e c k F a i l e d   BS t o r y b o a r d _ P r o p e r t y P a t h U n r e s o l v e d   LS t o r y b o a r d _ S t o r y b o a r d R e f e r e n c e R e q u i r e d   LS t o r y b o a r d _ T a r g e t N a m e N o t A l l o w e d I n S t y l e T  PS t o r y b o a r d _ T a r g e t N a m e N o t D e p e n d e n c y O b j e c t   BS t o r y b o a r d _ T a r g e t P r o p e r t y R e q u i r e d   2S t o r y b o a r d _ U n a b l e T o F r e e z e )  LS t o r y b o a r d _ U n r e c o g n i z e d H a n d o f f B e h a v i o r g  JS t o r y b o a r d _ U n r e c o g n i z e d T i m e S e e k O r i g i n   *S t r e a m C a n n o t B e W r i t t e n   0S t r e a m D o e s N o t S u p p o r t S e e k   2S t r e a m D o e s N o t S u p p o r t W r i t e   S t r e a m N o t S e t   (S t r e a m O b j e c t D i s p o s e d ,  S t r i n g E m p t y |  *S t r i n g I d O u t O f S e q u e n c e   &S t y l e B a s e d O n H a s L o o p   0S t y l e C a n n o t B e B a s e d O n S e l f !  DS t y l e D a t a T r i g g e r B i n d i n g H a s B a d V a l u e A  <S t y l e D a t a T r i g g e r B i n d i n g M i s s i n g ~  "S t y l e F o r W r o n g T y p e   .S t y l e H a s T o o M a n y E l e m e n t s   <S t y l e I m p l i e d A n d C o m p l e x C h i l d r e n    ,S t y l e I n v a l i d E l e m e n t T a g   4S t y l e K n o w n T a g W r o n g L o c a t i o n   S t y l e N o C l r E v e n t $  S t y l e N o D e f   (S t y l e N o D i c t i o n a r y K e y   &S t y l e N o E v e n t S e t t e r s   $S t y l e N o P r o p O r E v e n t a  *S t y l e N o S e t t e r R e s o u r c e   S t y l e N o T a r g e t   8S t y l e N o T e m p l a t e B i n d I n S e t t e r s B  DS t y l e N o T e m p l a t e B i n d I n V i s u a l T r i g g e r   ,S t y l e N o T o p L e v e l E l e m e n t   6S t y l e P r o p T r i g g e r P r o p M i s s i n g T  &S t y l e P r o p e r t y C u s t o m   <S t y l e P r o p e r t y I n S t y l e N o t A l l o w e d   6S t y l e P r o p e r t y S e t t e r M i n A t t r s   ,S t y l e S e t t e r U n k n o w n P r o p ;  (S t y l e T a g N o t S u p p o r t e d   DS t y l e T a r g e t T y p e M i s m a t c h W i t h E l e m e n t   *S t y l e T e x t N o t S u p p o r t e d >  HS t y l e T r i g g e r s C a n n o t T a r g e t T h e T e m p l a t e w   S t y l e U n k n o w n P r o p   &S t y l e U n k n o w n T r i g g e r S  DS t y l e V a l u e O f E x p r e s s i o n N o t S u p p o r t e d   >S y s t e m R e s o u r c e F o r T y p e I s N o t S t y l e   BT a b l e C o l l e c t i o n C o u n t N e e d N o n N e g N u m   DT a b l e C o l l e c t i o n E l e m e n t T y p e E x p e c t e d   @T a b l e C o l l e c t i o n I n O t h e r C o l l e c t i o n ,  8T a b l e C o l l e c t i o n I n v a l i d O f f L e n I  @T a b l e C o l l e c t i o n N o t E n o u g h C a p a c i t y f  2T a b l e C o l l e c t i o n O u t O f R a n g e   LT a b l e C o l l e c t i o n O u t O f R a n g e N e e d N o n N e g N u m   <T a b l e C o l l e c t i o n R a n g e O u t O f R a n g e   NT a b l e C o l l e c t i o n R a n k M u l t i D i m N o t S u p p o r t e d   >T a b l e C o l l e c t i o n W r o n g P r o x y P a r e n t  4T a b l e I n v a l i d P a r e n t N o d e T y p e 5 $T a r g e t N a m e N o t F o u n d V JT a r g e t N a m e N o t S u p p o r t e d F o r S t y l e S e t t e r s  &T e m p l a t e 3 D V a l u e O n l y  0T e m p l a t e B a d D i c t i o n a r y K e y 1 ~T e m p l a t e C a n n o t H a v e N e s t e d C o n t e n t P r e s e n t e r A n d G r i d V i e w R o w P r e s e n t e r p 8T e m p l a t e C h i l d I n d e x O u t O f R a n g e  <T e m p l a t e C i r c u l a r R e f e r e n c e F o u n d  .T e m p l a t e C o n t e n t S e t T w i c e { T e m p l a t e D u p N a m e  @T e m p l a t e F i n d N a m e I n I n v a l i d E l e m e n t  4T e m p l a t e H a s N e s t e d N a m e S c o p e  2T e m p l a t e I n v a l i d B a m l R e c o r d  :T e m p l a t e I n v a l i d R o o t E l e m e n t T a g  :T e m p l a t e K n o w n T a g W r o n g L o c a t i o n H  T e m p l a t e M u s t B e F E  .T e m p l a t e N o M u l t i p l e R o o t s  T e m p l a t e N o P r o p '  T e m p l a t e N o T a r g e t b JT e m p l a t e N o T e m p l a t e B i n d I n V i s u a l T r i g g e r  .T e m p l a t e N o T r i g g e r T a r g e t 6 *T e m p l a t e N o t T a r g e t T y p e  .T e m p l a t e T a g N o t S u p p o r t e d  4T e m p l a t e T a r g e t T y p e M i s m a t c h + 0T e m p l a t e T e x t N o t S u p p o r t e d x &T e m p l a t e U n k n o w n P r o p  bT e x t B o x B a s e _ C a n t S e t I s U n d o E n a b l e d I n s i d e C h a n g e B l o c k  <T e x t B o x B a s e _ U n m a t c h e d E n d C h a n g e \	 nT e x t B o x D e c o r a t o r M a r k e d A s T e x t B o x C o n t e n t M u s t H a v e N o C o n t e n t 	 &T e x t B o x I n v a l i d C h i l d 	 6T e x t B o x I n v a l i d T e x t C o n t a i n e r ,
 4T e x t B o x M i n M a x L i n e s M i s m a t c h v
 tT e x t B o x S c r o l l V i e w e r M a r k e d A s T e x t B o x C o n t e n t M u s t H a v e N o C o n t e n t 
 0T e x t B o x _ C o n t e x t M e n u _ C o p y 
 .T e x t B o x _ C o n t e x t M e n u _ C u t 
 RT e x t B o x _ C o n t e x t M e n u _ D e s c r i p t i o n _ D B C S S p a c e  RT e x t B o x _ C o n t e x t M e n u _ D e s c r i p t i o n _ S B C S S p a c e  :T e x t B o x _ C o n t e x t M e n u _ I g n o r e A l l % 0T e x t B o x _ C o n t e x t M e n u _ M o r e 7 RT e x t B o x _ C o n t e x t M e n u _ N o S p e l l i n g S u g g e s t i o n s F 2T e x t B o x _ C o n t e x t M e n u _ P a s t e Y LT e x t C o n t a i n e r C h a n g i n g R e e n t r a n c y I n v a l i d e DT e x t C o n t a i n e r D o e s N o t C o n t a i n E l e m e n t  XT e x t C o n t a i n e r _ U n d o M a n a g e r C r e a t e d M o r e T h a n O n c e  LT e x t E d i t o r C a n N o t R e g i s t e r C o m m a n d H a n d l e r  fT e x t E d i t o r C o p y P a s t e _ E n t r y P a r t I s M i s s i n g I n X a m l P a c k a g e N dT e x t E d i t o r P r o p e r t y I s N o t A p p l i c a b l e F o r T e x t F o r m a t t i n g v NT e x t E d i t o r S p e l l e r I n t e r o p H a s B e e n D i s p o s e d  |T e x t E d i t o r T y p e O f P a r a m e t e r I s N o t A p p r o p r i a t e F o r F o r m a t t i n g P r o p e r t y  tT e x t E l e m e n t C o l l e c t i o n _ C a n n o t C o p y T o A r r a y N o t S u f f i c i e n t M e m o r y  JT e x t E l e m e n t C o l l e c t i o n _ I n d e x O u t O f R a n g e j VT e x t E l e m e n t C o l l e c t i o n _ I t e m H a s U n e x p e c t e d T y p e  |T e x t E l e m e n t C o l l e c t i o n _ N e x t S i b l i n g D o e s N o t B e l o n g T o T h i s C o l l e c t i o n  DT e x t E l e m e n t C o l l e c t i o n _ N o E n u m e r a t o r  T e x t E l e m e n t C o l l e c t i o n _ P r e v i o u s S i b l i n g D o e s N o t B e l o n g T o T h i s C o l l e c t i o n 3 ZT e x t E l e m e n t C o l l e c t i o n _ T e x t E l e m e n t T y p e E x p e c t e d s >T e x t E l e m e n t _ U n m a t c h e d E n d P o i n t e r  HT e x t P a n e l I l l e g a l P a r a T y p e F o r I A d d C h i l d  T e x t P o i n t e r _ C a n n o t I n s e r t T e x t E l e m e n t B e c a u s e I t B e l o n g s T o A n o t h e r T r e e . (T e x t P o s i t i o n I s F r o z e n i @T e x t P r o v i d e r _ I n v a l i d C h i l d E l e m e n t  2T e x t P r o v i d e r _ I n v a l i d P o i n t  LT e x t P r o v i d e r _ T e x t S e l e c t i o n N o t S u p p o r t e d  XT e x t R a n g e E d i t _ I n v a l i d S t r u c t u r a l P r o p e r t y A p p l y  LT e x t R a n g e P r o v i d e r _ E m p t y S t r i n g P a r a m e t e r e NT e x t R a n g e P r o v i d e r _ I n v a l i d P a r a m e t e r V a l u e  @T e x t R a n g e P r o v i d e r _ W r o n g T e x t R a n g e  >T e x t R a n g e _ I n v a l i d P a r a m e t e r V a l u e  dT e x t R a n g e _ P r o p e r t y C a n n o t B e I n c r e m e n t e d O r D e c r e m e n t e d  VT e x t R a n g e _ U n r e c o g n i z e d S t r u c t u r e I n D a t a F o r m a t  >T e x t R a n g e _ U n s u p p o r t e d D a t a F o r m a t O XT e x t S c h e m a _ C a n n o t I n s e r t C o n t e n t I n T h i s P o s i t i o n r :T e x t S c h e m a _ C a n n o t S p l i t E l e m e n t  :T e x t S c h e m a _ C h i l d T y p e I s I n v a l i d  2T e x t S c h e m a _ I l l e g a l E l e m e n t  @T e x t S c h e m a _ I l l e g a l H y p e r l i n k C h i l d F 6T e x t S c h e m a _ T e x t I s N o t A l l o w e d  PT e x t S c h e m a _ T e x t I s N o t A l l o w e d I n T h i s C o n t e x t  jT e x t S c h e m a _ T h e C h i l d E l e m e n t B e l o n g s T o A n o t h e r T r e e A l r e a d y  pT e x t S c h e m a _ T h i s B l o c k U I C o n t a i n e r H a s A C h i l d U I E l e m e n t A l r e a d y 2 rT e x t S c h e m a _ T h i s I n l i n e U I C o n t a i n e r H a s A C h i l d U I E l e m e n t A l r e a d y  XT e x t S c h e m a _ U I E l e m e n t N o t A l l o w e d I n T h i s P o s i t i o n  4T e x t S e g m e n t s M u s t N o t O v e r l a p  4T e x t S t o r e _ B a d I M E C h a r O f f s e t Q ,T e x t S t o r e _ B a d L o c k F l a g s  BT e x t S t o r e _ C O N N E C T _ E _ C A N N O T C O N N E C T  @T e x t S t o r e _ C O N N E C T _ E _ N O C O N N E C T I O N  :T e x t S t o r e _ C o m p o s i t i o n R e j e c t e d  .T e x t S t o r e _ E _ N O I N T E R F A C E ! &T e x t S t o r e _ E _ N O T I M P L N  T e x t S t o r e _ N o S i n k b <T e x t S t o r e _ R e e n t r a n t R e q u e s t L o c k  *T e x t S t o r e _ T S _ E _ F O R M A T  6T e x t S t o r e _ T S _ E _ I N V A L I D P O I N T " .T e x t S t o r e _ T S _ E _ N O L A Y O U T ? .T e x t S t o r e _ T S _ E _ R E A D O N L Y _ *T e x t V i e w I n v a l i d L a y o u t s :T h e m e D i c t i o n a r y E x t e n s i o n _ N a m e  >T h e m e D i c t i o n a r y E x t e n s i o n _ S o u r c e  8T o S t r i n g F o r m a t S t r i n g _ C o n t r o l a :T o S t r i n g F o r m a t S t r i n g _ G r i d V i e w k FT o S t r i n g F o r m a t S t r i n g _ G r i d V i e w C o l u m n  RT o S t r i n g F o r m a t S t r i n g _ G r i d V i e w R o w P r e s e n t e r  ZT o S t r i n g F o r m a t S t r i n g _ G r i d V i e w R o w P r e s e n t e r B a s e  VT o S t r i n g F o r m a t S t r i n g _ H e a d e r e d C o n t e n t C o n t r o l  RT o S t r i n g F o r m a t S t r i n g _ H e a d e r e d I t e m s C o n t r o l  BT o S t r i n g F o r m a t S t r i n g _ I t e m s C o n t r o l  <T o S t r i n g F o r m a t S t r i n g _ R a n g e B a s e  BT o S t r i n g F o r m a t S t r i n g _ T o g g l e B u t t o n D 2T o k e n i z e r H e l p e r E m p t y T o k e n b FT o k e n i z e r H e l p e r E x t r a D a t a E n c o u n t e r e d  <T o k e n i z e r H e l p e r M i s s i n g E n d Q u o t e  RT o k e n i z e r H e l p e r P r e m a t u r e S t r i n g T e r m i n a t i o n  RT o o l B a r _ I n v a l i d S t y l e _ T o o l B a r O v e r f l o w P a n e l C BT o o l B a r _ I n v a l i d S t y l e _ T o o l B a r P a n e l  >T o o l T i p S t a y s O p e n F a l s e N o t A l l o w e d # "T r a c k _ S a m e B u t t o n s ~ *T r a n s f o r m N o t S u p p o r t e d  4T r i g g e r A c t i o n A l r e a d y S e a l e d  NT r i g g e r A c t i o n M u s t B e l o n g T o A S i n g l e T r i g g e r , HT r i g g e r O n S t y l e N o t A l l o w e d T o H a v e S o u r c e ~ BT r i g g e r s S u p p o r t s E v e n t T r i g g e r s O n l y  &T r u s t N o t G r a n t e d T e x t  (T r u s t N o t G r a n t e d T i t l e Q ,T w o W a y B i n d i n g N e e d s P a t h b &T y p e I d O u t O f S e q u e n c e  @T y p e M e t a d a t a C a n n o t C h a n g e A f t e r U s e  4T y p e M u s t I m p l e m e n t I A d d C h i l d 	 .T y p e N a m e M u s t B e S p e c i f i e d d <T y p e V a l u e S e r i a l i z e r U n a v a i l a b l e  <U I A _ O p e r a t i o n C a n n o t B e P e r f o r m e d  HU i L e s s P a g e F u n c t i o n N o t C a l l i n g O n R e t u r n  0U n R e c o g n i z e d B a m l N o d e T y p e Z (U n a b l e T o C o n v e r t I n t 3 2 } ,U n a b l e T o L o c a t e R e s o u r c e  0U n d e f i n e d H i g h l i g h t A n c h o r  2U n d o C o n t a i n e r T y p e M i s m a t c h  4U n d o M a n a g e r A l r e a d y A t t a c h e d  (U n d o N o O p e n P a r e n t U n i t I U n d o N o O p e n U n i t  (U n d o N o t I n N o r m a l S t a t e  &U n d o S e r v i c e D i s a b l e d #  &U n d o U n i t A l r e a d y O p e n \  0U n d o U n i t C a n t B e A d d e d T w i c e   2U n d o U n i t C a n t B e O p e n e d T w i c e   U n d o U n i t L o c k e d !  U n d o U n i t N o t F o u n d 0! .U n d o U n i t N o t O n T o p O f S t a c k ! U n d o U n i t O p e n ! &U n e x p e c t e d A t t r i b u t e " @U n e x p e c t e d C o l l e c t i o n C h a n g e A c t i o n 5" .U n e x p e c t e d P a r a m e t e r T y p e [" $U n e x p e c t e d P r o p e r t y " U n e x p e c t e d T y p e " >U n e x p e c t e d V a l u e T y p e F o r C o n d i t i o n " BU n e x p e c t e d V a l u e T y p e F o r D a t a T r i g g e r # \U n e x p e c t e d X m l N o d e I n X m l F i x e d P a g e I n f o C o n s t r u c t o r G# "U n k n o w n B a m l R e c o r d # ,U n k n o w n C o n t a i n e r F o r m a t #  U n k n o w n E r r o r T e x t # "U n k n o w n E r r o r T i t l e H$  U n k n o w n I n d e x T y p e V$  U n m a t c h e d B r a c k e t $ &U n m a t c h e d L o c C o m m e n t $ U n m a t c h e d P a r e n $ ,U n s e r i a l i z a b l e K e y V a l u e % 2U n s u p p o r t e d T r i g g e r I n S t y l e t% 8U n s u p p o r t e d T r i g g e r I n T e m p l a t e % U n t i t l e d % 6U n t i t l e d P r i n t J o b D e s c r i p t i o n % .U r i N o t M a t c h W i t h R o o t T y p e % <V a l i d a t i o n R u l e _ U n e x p e c t e d V a l u e )& 4V a l i d a t i o n R u l e _ U n k n o w n S t e p & 6V a l i d a t i o n _ C o n v e r s i o n F a i l e d & *V a l u e M u s t B e X a m l R e a d e r & 4V a l u e N o t B e t w e e n I n t 3 2 M i n M a x *' BV a l u e S e r i a l i z e r C o n t e x t U n a v a i l a b l e ' pV i r t u a l i z e d C e l l I n f o C o l l e c t i o n _ D o e s N o t S u p p o r t I n d e x C h a n g e s ' PV i r t u a l i z e d C e l l I n f o C o l l e c t i o n _ I s R e a d O n l y !( $V i r t u a l i z e d E l e m e n t 8( @V i s u a l T r e e R o o t I s F r a m e w o r k E l e m e n t ( `V i s u a l T r i g g e r S e t t e r s I n c l u d e U n s u p p o r t e d S e t t e r T y p e m) 2V i s u a l _ A r g u m e n t O u t O f R a n g e ) <W e b B r o w s e r N o C a s t T o I W e b B r o w s e r 2 @* "W e b B r o w s e r O v e r l a p v* 0W e b R e q u e s t C r e a t i o n F a i l e d * &W i n d o w A l r e a d y C l o s e d *  W i n d o w M u s t B e R o o t 7+ NW i n d o w P a s s e d S h o u l d B e O n A p p l i c a t i o n T h r e a d + :W p f P a y l o a d _ I n v a l i d I m a g e S o u r c e + "W r i t e N o t S u p p o r t e d , 0W r o n g N a v i g a t e R o o t E l e m e n t *, $W r o n g S e l e c t i o n T y p e V, 2X a m l F i l t e r N e s t e d F i x e d P a g e , 6X m l G l y p h R u n I n f o I s N o n G r a p h i c , &X m l N o d e A l r e a d y O w n e d , bX p s V a l i d a t i n g L o a d e r D i s c a r d C o n t r o l H a s I n c o r r e c t T y p e !- JX p s V a l i d a t i n g L o a d e r D u p l i c a t e R e f e r e n c e j- jX p s V a l i d a t i n g L o a d e r M o r e T h a n O n e D i s c a r d C o n t r o l I n P a c k a g e - ZX p s V a l i d a t i n g L o a d e r M o r e T h a n O n e P r i n t T i c k e t P a r t - `X p s V a l i d a t i n g L o a d e r M o r e T h a n O n e T h u m b n a i l I n P a c k a g e - VX p s V a l i d a t i n g L o a d e r M o r e T h a n O n e T h u m b n a i l P a r t '. \X p s V a l i d a t i n g L o a d e r P r i n t T i c k e t H a s I n c o r r e c t T y p e X. bX p s V a l i d a t i n g L o a d e r R e s t r i c t e d F o n t H a s I n c o r r e c t T y p e . XX p s V a l i d a t i n g L o a d e r T h u m b n a i l H a s I n c o r r e c t T y p e . FX p s V a l i d a t i n g L o a d e r U n l i s t e d R e s o u r c e #/ LX p s V a l i d a t i n g L o a d e r U n s u p p o r t e d E n c o d i n g / LX p s V a l i d a t i n g L o a d e r U n s u p p o r t e d M i m e T y p e / \X p s V a l i d a t i n g L o a d e r U n s u p p o r t e d R o o t N a m e s p a c e U r i 0 LX p s V a l i d a t i n g L o a d e r U r i N o t I n S a m e P a c k a g e 90 T{0} ActiveX  URI URI;{0} AccessCollection<{0}2 Add 6F AdornedElementPlaceholder  Template ; AdornerLayer \n {0}\n\nI{0} Style 'KXAML  KeyFrameAnimation  KeyFrame{0} Duration  TimeSpan KeyFrame  KeyTime  TimeSpan{0} Duration {1} KeyFrame  KeyTime {2} KeyTime{0}{2}{1} {1}  KeyTime  {4}  KeyTimeKeyFrames[{1}]  KeyTime{2} {3}KeyFrames[{4}]  KeyTime{5} {6} KeyTime {0} Begin  Duration  KeyTime  Duration {0} {1} {2}KeyTime  Duration {3}2{0}{2} {1} ?KeyFrameAnimation  UIElement*( ID 3AttachedAnnotation  Annotation  Null* AnnotationService AnnotationService AnnotationServiceE*!) {1}.{2}  {0} 2{0}{1} NULLl-C BAML : assemblyId A ID {0} ID <;  = {0}URI {1}& {0}.{1}V LoadedBehavior  UnloadedBehavior  Manual$H GetText 0{0}/ IConnectionPointContainer*{0}9{0} Advise({1})9{0}] ActiveX {0}DActiveX  ActiveX 0:{0} TextContainer  TextPosition"CopyTo '{1}{0}BAML AssemblyId {0} I MarkupExtension BAML / BAML5BamlReader l{1}{0}P{0}{1}BAML BAML TypeId {0} > GAC {0}[ ={0} ={1}? BamlWriter 7{0} xmlns 6 BamlWriter.Close g WriteStartElement {0}{1}[WriteStartDocument  BamlWriter 'CBindingCollection  {0}  Binding1 Binding.{1}  Binding.{0}*^:  WPF  BindingExpressionV BindingGroup BindingGroupE{0}{1}{0}{1}()+IBindingList 4 CollectionView ; WPF $0)HTTP  - {0}	` Collection  Dispatcher  SourceCollection Zvalue DateTimestartAfter| SelectedDates  SelectedDateDisplayMode FirstDayOfWeek > None  SelectedDate SelectedDate SelectionMode Z{0}{1}{0}& CancelEdit, WebBrowser$J Application.Run {0};{0}()@{1} false {0}> MainWindow9{0}{1}-{0}{1}O