.
    /// </param>
    texture(const Concurrency::extent<_Rank>& _Ext, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(_Ext)
    {
        _Initialize(_Av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture from extents, specified bits per scalar element and number of mipmap levels
    /// </summary>
    /// <param name="_Ext">
    ///     An extent that describes the shape of the texture.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Mipmap_levels">
    ///     Number of mipmap levels in the underlying texture.
    ///     If 0 is specified, the texture will have full range of mipmap levels down to smallest possible size for the given extent.
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(const Concurrency::extent<_Rank>& _Ext, unsigned int _Bits_per_scalar_element, unsigned int _Mipmap_levels, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(_Ext, _Mipmap_levels)
    {
        _Initialize(_Av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture from extents and specified bits per scalar element, bound to a
    ///     specific accelerator_view and an associated accelerator_view that is the preferred location
    ///     for copying to/from this texture.
    /// </summary>
    /// <param name="_Ext">
    ///     An extent that describes the shape of the texture.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(const Concurrency::extent<_Rank>& _Ext, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(_Ext)
    {
        _Initialize(_Av, _Associated_av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T, 1&gt; with integer _E0 and specified bits per scalar element, bound to a specific accelerator.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(int _E0, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0))
    {
        static_assert(_Rank == 1, "texture(int, unsigned int, accelerator_view) is only permissible on texture<value_type, 1>.");
        _Initialize(_Av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture&lt;T, 1&gt; with integer _E0 and specified bits per scalar element,
    ///     bound to a specific accelerator and an associated accelerator_view that is the preferred location
    ///     for copying to/from this texture.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(int _E0, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0))
    {
        static_assert(_Rank == 1, "texture(int, unsigned int, accelerator_view, accelerator_view) is only permissible on texture<value_type, 1>.");
        _Initialize(_Av, _Associated_av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T,2&gt; with two integers and specified bits per scalar element, bound to a specific accelerator.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(int _E0, int _E1, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1))
    {
        static_assert(_Rank == 2, "texture(int, int, unsigned int, accelerator_view) is only permissible on texture<value_type, 2>.");
        _Initialize(_Av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture&lt;T,2&gt; with two integers and specified bits per scalar element,
    ///     bound to a specific accelerator and an associated accelerator_view that is the preferred location
    ///     for copying to/from this texture.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(int _E0, int _E1, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1))
    {
        static_assert(_Rank == 2, "texture(int, int, unsigned int, accelerator_view, accelerator_view) is only permissible on texture<value_type, 2>.");
        _Initialize(_Av, _Associated_av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T,3&gt; with three integers and specified bits per scalar element, bound to a specific accelerator.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (depth).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E2">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(int _E0, int _E1, int _E2, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1, _E2))
    {
        static_assert(_Rank == 3, "texture(int, int, int, unsigned int, accelerator_view) is only permissible on texture<value_type, 3>.");
        _Initialize(_Av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture&lt;T,3&gt; with three integers and specified bits per scalar element,
    ///     bound to a specific accelerator and an associated accelerator_view that is the preferred location
    ///     for copying to/from this texture.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (depth).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E2">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(int _E0, int _E1, int _E2, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1, _E2))
    {
        static_assert(_Rank == 3, "texture(int, int, int, unsigned int, accelerator_view, accelerator_view) is only permissible on texture<value_type, 3>.");
        _Initialize(_Av, _Associated_av, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture from extents and specified bits per scalar element, initialized from a host buffer.
    /// </summary>
    /// <param name="_Ext">
    ///     An extent that describes the shape of the texture.
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    texture(const Concurrency::extent<_Rank>& _Ext, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element) __CPU_ONLY
        : _Texture_base(_Ext)
    {
        _Initialize(Concurrency::details::_Select_default_accelerator().default_view, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T,1&gt; with integer _E0 and specified bits per scalar element, initialized from a host buffer.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    texture(int _E0, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0))
    {
        static_assert(_Rank == 1, "texture(int, void *, unsigned int, unsigned int) is only permissible on texture<value_type, 1>.");
        _Initialize(Concurrency::details::_Select_default_accelerator().default_view, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T,2&gt; with two integers and specified bits per scalar element, initialized from a host buffer.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    texture(int _E0, int _E1, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1))
    {
        static_assert(_Rank == 2, "texture(int, int, void *, unsigned int, unsigned int) is only permissible on texture<value_type, 2>.");
        _Initialize(Concurrency::details::_Select_default_accelerator().default_view, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }


    /// <summary>
    ///     Construct a texture&lt;T,3&gt; with three integers and specified bits per scalar element, initialized from a host buffer.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (depth).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E2">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    texture(int _E0, int _E1, int _E2, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1, _E2))
    {
        static_assert(_Rank == 3, "texture(int, int, int, void *, unsigned int, unsigned int) is only permissible on texture<value_type, 3>.");
        _Initialize(Concurrency::details::_Select_default_accelerator().default_view, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture from extents and specified bits per scalar element, initialized from a host buffer,  bound to a specific accelerator_view.
    /// </summary>
    /// <param name="_Ext">
    ///     An extent that describes the shape of the texture.
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(const Concurrency::extent<_Rank>& _Ext, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(_Ext)
    {
        _Initialize(_Av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture from extents and specified bits per scalar element, initialized from a host buffer,
    ///     bound to a specific accelerator_view and an associated accelerator_view that is the preferred location for copying
    ///     to/from this texture.
    /// </summary>
    /// <param name="_Ext">
    ///     An extent that describes the shape of the texture.
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(const Concurrency::extent<_Rank>& _Ext, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(_Ext)
    {
        _Initialize(_Av, _Associated_av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T, 1&gt; with integer _E0 and specified bits per scalar element, initialized from a host buffer,  bound to a specific accelerator_view.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(int _E0, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0))
    {
        static_assert(_Rank == 1, "texture(int, void *, unsigned int, unsigned int, accelerator_view) is only permissible on texture<value_type, 1>.");
        _Initialize(_Av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture&lt;T, 1&gt; with integer _E0 and specified bits per scalar element, initialized from a host buffer,
    ///     bound to a specific accelerator_view and an associated accelerator_view that is the preferred location for copying
    ///     to/from this texture.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(int _E0, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0))
    {
        static_assert(_Rank == 1, "texture(int, void *, unsigned int, unsigned int, accelerator_view, accelerator_view) is only permissible on texture<value_type, 1>.");
        _Initialize(_Av, _Associated_av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T, 2&gt; with two integers and specified bits per scalar element, initialized from a host buffer,  bound to a specific accelerator_view.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(int _E0, int _E1, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1))
    {
        static_assert(_Rank == 2, "texture(int, int, void *, unsigned int, unsigned int, accelerator_view) is only permissible on texture<value_type, 2>.");
        _Initialize(_Av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture&lt;T, 2&gt; with two integers and specified bits per scalar element, initialized from a host buffer,
    ///     bound to a specific accelerator_view and an associated accelerator_view that is the preferred location for copying
    ///     to/from this texture.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(int _E0, int _E1, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1))
    {
        static_assert(_Rank == 2, "texture(int, int, void *, unsigned int, unsigned int, accelerator_view, accelerator_view) is only permissible on texture<value_type, 2>.");
        _Initialize(_Av, _Associated_av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture&lt;T, 3&gt; with three integers and specified bits per scalar element, initialized from a host buffer,  bound to a specific accelerator_view.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (depth).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E2">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(int _E0, int _E1, int _E2, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1, _E2))
    {
        static_assert(_Rank == 3, "texture(int, int, int, void *, unsigned int, unsigned int, accelerator_view) is only permissible on texture<value_type, 3>.");
        _Initialize(_Av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a staging texture&lt;T, 3&gt; with three integers and specified bits per scalar element, initialized from a host buffer,
    ///     bound to a specific accelerator_view and an associated accelerator_view that is the preferred location for copying
    ///     to/from this texture.
    /// </summary>
    /// <param name="_E0">
    ///     An integer that is the length of the most-significant dimension of this texture (depth).
    /// </param>
    /// <param name="_E1">
    ///     An integer that is the length of the least-significant dimension of this texture (height).
    /// </param>
    /// <param name="_E2">
    ///     An integer that is the length of the least-significant dimension of this texture (width).
    /// </param>
    /// <param name="_Source">
    ///     A pointer to a host buffer.
    /// </param>
    /// <param name="_Source_byte_size">
    ///     Number of bytes in the source buffer.
    /// </param>
    /// <param name="_Bits_per_scalar_element">
    ///     Number of bits per each scalar element in the underlying scalar type of the texture.
    ///     In general, supported value is 8, 16, 32, 64.
    ///     If 0 is specified, the number of bits picks defaulted value for the underlying scalar_type.
    ///     64 is only valid for double based textures
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(int _E0, int _E1, int _E2, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element, const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
        : _Texture_base(Concurrency::extent<_Rank>(_E0, _E1, _E2))
    {
        static_assert(_Rank == 3, "texture(int, int, int, void *, unsigned int, unsigned int, accelerator_view, accelerator_view) is only permissible on texture<value_type, 3>.");
        _Initialize(_Av, _Associated_av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    /// <summary>
    ///     Construct a texture from a texture_view. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture_view to copy from.
    /// </param>
    texture(const texture_view<_Value_type, _Rank> & _Src)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Src.accelerator_view, _Src);
    }

    /// <summary>
    ///     Construct a texture from a read-only texture_view. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The read-only texture_view to copy from.
    /// </param>
    texture(const texture_view<const _Value_type, _Rank> & _Src)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Src.accelerator_view, _Src);
    }

    /// <summary>
    ///     Construct a texture from a texture_view on another accelerator_view. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture_view to copy from.
    /// </param>
    /// <param name="_Acc_view">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(const texture_view<_Value_type, _Rank> & _Src, const Concurrency::accelerator_view & _Acc_view)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Acc_view, _Src);
    }

    /// <summary>
    ///     Construct a texture from a read-only texture_view on another accelerator_view. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The read-only texture_view to copy from.
    /// </param>
    /// <param name="_Acc_view">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(const texture_view<const _Value_type, _Rank> & _Src, const Concurrency::accelerator_view & _Acc_view)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Acc_view, _Src);
    }

    /// <summary>
    ///     Construct a staging texture from a texture_view on another accelerator_view. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture_view to copy from.
    /// </param>
    /// <param name="_Acc_view">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(const texture_view<_Value_type, _Rank> & _Src, const Concurrency::accelerator_view & _Acc_view, const Concurrency::accelerator_view& _Associated_av)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Acc_view, _Associated_av, _Src);
    }

    /// <summary>
    ///     Construct a staging texture from a read-only texture_view on another accelerator_view. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The read-only texture_view to copy from.
    /// </param>
    /// <param name="_Acc_view">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(const texture_view<const _Value_type, _Rank> & _Src, const Concurrency::accelerator_view & _Acc_view, const Concurrency::accelerator_view& _Associated_av)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Acc_view, _Associated_av, _Src);
    }

    /// <summary>
    ///     Copy constructor. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture to copy from.
    /// </param>
    texture(const texture & _Src)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Src.accelerator_view, _Src.associated_accelerator_view, _Src);
    }

    /// <summary>
    ///     Move constructor
    /// </summary>
    /// <param name="_Other">
    ///     The source texture to move from.
    /// </param>
    texture(texture && _Other)
    {
        *this = std::move(_Other);
    }

    /// <summary>
    ///     Copy constructor. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture to copy from.
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    texture(const texture & _Src, const Concurrency::accelerator_view & _Av)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Av, _Src);
    }

    /// <summary>
    ///     Copy constructor. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture to copy from.
    /// </param>
    /// <param name="_Av">
    ///     An accelerator_view where this texture resides.
    /// </param>
    /// <param name="_Associated_av">
    ///     An accelerator_view which specifies the preferred target location for copies
    ///     to/from the texture.
    /// </param>
    texture(const texture & _Src, const Concurrency::accelerator_view & _Av, const Concurrency::accelerator_view& _Associated_av)
        : _Texture_base(_Src.extent, _Src.get_mipmap_levels())
    {
        _Initialize(_Av, _Associated_av, _Src);
    }

    /// <summary>
    ///     Copy assignment operator. Deep copy
    /// </summary>
    /// <param name="_Src">
    ///     The texture to copy from.
    /// </param>
    /// <returns>
    ///     A reference to this texture.
    /// </returns>
    texture& operator=(const texture & _Other)
    {
        if (this != &_Other)
        {
            this->_M_extent = _Other._M_extent;
            this->_M_texture_descriptor._Set_view_mipmap_levels(_Other.get_mipmap_levels());
            _Initialize(_Other.accelerator_view, _Other.associated_accelerator_view, _Other);
        }
        return *this;
    }

    /// <summary>
    ///     Move assignment operator
    /// </summary>
    /// <param name="_Other">
    ///     The source texture to move from.
    /// </param>
    /// <returns>
    ///     A reference to this texture.
    /// </returns>
    texture& operator=(texture<_Value_type, _Rank> && _Other)
    {
        if (this != &_Other)
        {
            this->_M_extent = _Other._M_extent;
            this->_M_texture_descriptor = _Other._M_texture_descriptor;

            _Other._M_texture_descriptor._M_data_ptr = NULL;
            _Other._M_texture_descriptor._Set_texture_ptr(NULL);
        }
        return *this;
    }

    /// <summary>
    ///     Copy-to, deep copy
    /// </summary>
    /// <param name="_Dest">
    ///     The destination texture to copy to.
    /// </param>
    void copy_to(texture & _Dest) const
    {
        if (this->extent != _Dest.extent)
        {
            throw runtime_exception("The source and destination textures must have the exactly the same extent.", E_INVALIDARG);
        }

        auto _Span_id = concurrency::details::_Get_amp_trace()->_Start_copy_event_helper(concurrency::details::_Get_texture_descriptor(*this),
                                                                            concurrency::details::_Get_texture_descriptor(_Dest),
                                                                            this->get_data_length());

        this->_Copy_to(_Dest);

        concurrency::details::_Get_amp_trace()->_Write_end_event(_Span_id);
    }

    /// <summary>
    ///     Copy-to, deep copy
    /// </summary>
    /// <param name="_Dest">
    ///     The destination writeonly_texture_view to copy to.
    /// </param>
    void copy_to(const writeonly_texture_view<_Value_type, _Rank> & _Dest) const
    {
        if (this->extent != _Dest.extent)
        {
            throw runtime_exception("The source and destination textures must have the exactly the same extent.", E_INVALIDARG);
        }

        auto _Span_id = concurrency::details::_Get_amp_trace()->_Start_copy_event_helper(concurrency::details::_Get_texture_descriptor(*this),
                                                                            concurrency::details::_Get_texture_descriptor(_Dest),
                                                                            this->get_data_length());

        this->_Copy_to(_Dest);

        concurrency::details::_Get_amp_trace()->_Write_end_event(_Span_id);
    }

    /// <summary>
    ///     Destructor
    /// </summary>
    ~texture() __CPU_ONLY
    {
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type operator[] (const index<_Rank>& _Index) const __GPU_ONLY
    {
        typename details::_Texture_base<_Value_type, _Rank>::value_type _Tmp;
        _Texture_read_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Tmp, _Index, /*_Mip_level=*/0);
        return _Tmp;
    }

    /// <summary>
    ///     Get the element value indexed by _I.
    /// </summary>
    /// <param name="_I">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _I.
    /// </returns>
    const _Value_type operator[] (int _I0) const __GPU_ONLY
    {
        static_assert(_Rank == 1, "value_type texture::operator[](int) is only permissible on texture<value_type, 1>.");
        return (*this)[index<1>(_I0)];
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type operator() (const index<_Rank>& _Index) const __GPU_ONLY
    {
        return (*this)[_Index];
    }

    /// <summary>
    ///     Get the element value indexed by _I0
    /// </summary>
    /// <param name="_I0">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _I0.
    /// </returns>
    const _Value_type operator() (int _I0) const __GPU_ONLY
    {
        static_assert(_Rank == 1, "value_type texture::operator()(int) is only permissible on texture<value_type, 1>.");
        return (*this)[index<1>(_I0)];
    }

    /// <summary>
    ///     Get the element value indexed by (_I0,_I1)
    /// </summary>
    /// <param name="_I0">
    ///     The most-significant component of the index
    /// </param>
    /// <param name="_I1">
    ///     The least-significant component of the index
    /// </param>
    /// <returns>
    ///     The element value indexed by (_I0,_I1)
    /// </returns>
    const _Value_type operator() (int _I0, int _I1) const __GPU_ONLY
    {
        static_assert(_Rank == 2, "value_type texture::operator()(int, int) is only permissible on texture<value_type, 2>.");
        return (*this)[index<2>(_I0, _I1)];
    }

    /// <summary>
    ///     Get the element value indexed by (_I0,_I1,_I2)
    /// </summary>
    /// <param name="_I0">
    ///     The most-significant component of the index
    /// </param>
    /// <param name="_I1">
    ///     The next-to-most-significant component of the index
    /// </param>
    /// <param name="_I2">
    ///     The least-significant component of the index
    /// </param>
    /// <returns>
    ///     The element value indexed by (_I0,_I1,_I2)
    /// </returns>
    const _Value_type operator() (int _I0, int _I1, int _I2) const __GPU_ONLY
    {
        static_assert(_Rank == 3, "value_type texture::operator()(int, int, int) is only permissible on texture<value_type, 3>.");
        return (*this)[index<3>(_I0, _I1, _I2)];
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type get(const index<_Rank>& _Index) const __GPU_ONLY
    {
        return (*this)[_Index];
    }

    /// <summary>
    ///     Set the element indexed by _Index with value _Value.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <param name="_Value">
    ///     The value to be set to the element indexed by _Index.
    /// </param>
    void set(const index<_Rank>& _Index, const _Value_type& _Value) __GPU_ONLY
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Num_channels == 1, "Invalid value_type for set method.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Unorm_type, "Invalid value_type for set method.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Norm_type, "Invalid value_type for set method.");
        _Texture_write_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Value, _Index);
    }

    /// <summary>
    ///     Returns a CPU pointer to the raw data of this texture.
    /// </summary>
    _Ret_ void* data() __CPU_ONLY
    {
        return this->_Get_texture()->_Get_host_ptr();
    }

    /// <summary>
    ///     Returns a CPU pointer to the raw data of this texture.
    /// </summary>
    const void* data() const __CPU_ONLY
    {
        return this->_Get_texture()->_Get_host_ptr();
    }

    /// <summary>
    ///     Returns the row pitch (in bytes) of a 2D or 3D staging texture on the CPU to be
    ///     used for navigating the staging texture from row to row on the CPU.
    /// </summary>
    __declspec(property(get=get_row_pitch)) unsigned int row_pitch;
    unsigned int get_row_pitch() const __CPU_ONLY
    {
        static_assert(_Rank >= 2, "row_pitch is only applicable to staging textures with rank 2 or higher.");

        if (!this->_Get_texture()->_Is_staging()) {
            throw runtime_exception("row_pitch is only applicable to staging textures.", E_INVALIDARG);
        }

        return static_cast<unsigned int>(this->_Get_texture()->_Get_row_pitch());
    }

    /// <summary>
    ///     Returns the depth pitch (in bytes) of a 3D staging texture on the CPU to be used
    ///     for navigating the staging texture from depth slice to depth slice on the CPU.
    /// </summary>
    __declspec(property(get=get_depth_pitch)) unsigned int depth_pitch;
    unsigned int get_depth_pitch() const __CPU_ONLY
    {
        static_assert(_Rank == 3, "depth_pitch is only applicable to staging textures with rank 3.");

        if (!this->_Get_texture()->_Is_staging()) {
            throw runtime_exception("depth_pitch is only applicable to staging textures.", E_INVALIDARG);
        }

        return static_cast<unsigned int>(this->_Get_texture()->_Get_depth_pitch());
    }

    /// <summary>
    ///     Returns the accelerator_view that is the preferred target where this texture can be copied.
    /// </summary>
    __declspec(property(get=get_associated_accelerator_view)) Concurrency::accelerator_view associated_accelerator_view;
    Concurrency::accelerator_view get_associated_accelerator_view() const __CPU_ONLY
    {
        return this->_Get_texture()->_Get_accelerator_view();
    }

private:
    // Private constructor used by make_texture to create a texture from D3D texture
    texture(const Concurrency::extent<_Rank> & _Ext, const _Texture_descriptor & _Descriptor)
        : details::_Texture_base<_Value_type, _Rank>(_Ext, _Descriptor)
    {
    }

    bool _Should_create_staging_texture(const Concurrency::accelerator_view &_Av, const Concurrency::accelerator_view &_Associated_av)
    {
        return (_Is_cpu_accelerator(_Av.accelerator) && !_Is_cpu_accelerator(_Associated_av.accelerator));
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av, unsigned int _Bits_per_scalar_element) __CPU_ONLY
    {
        if (_Bits_per_scalar_element != 8 && _Bits_per_scalar_element != 16 &&
            _Bits_per_scalar_element != 32 && _Bits_per_scalar_element != 64)
        {
            throw runtime_exception("Invalid _Bits_per_scalar_element argument - it can only be 8, 16, 32, or 64.", E_INVALIDARG);
        }

        // special cases for 64 and for double based textures

        if (_Bits_per_scalar_element == 64 && _Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Double_type)
        {
            throw runtime_exception("Invalid _Bits_per_scalar_element argument - 64 is only valid for texture of double based short vector types.", E_INVALIDARG);
        }

        if (_Bits_per_scalar_element != 64 && _Short_vector_type_traits<_Value_type>::_Format_base_type_id == _Double_type)
        {
            throw runtime_exception("Invalid _Bits_per_scalar_element argument - it can only be 64 for texture of double based short vector types.", E_INVALIDARG);
        }

        details::_Is_valid_data_length(this->_M_extent.size(), _Bits_per_scalar_element * _Short_vector_type_traits<_Value_type>::_Num_channels);

        // the rest of the check is done by _Texture::_Create_texture, it depends on the underlying supported DXGI formats.

        unsigned int _Bits_per_channel = _Bits_per_scalar_element;

        if (_Short_vector_type_traits<_Value_type>::_Format_base_type_id == _Double_type)
        {
            _Bits_per_channel = _Short_vector_type_traits<_Value_type>::_Default_bits_per_channel;
        }

        std::array<size_t, 3> _Dimensions = Concurrency::graphics::details::_Get_dimensions(this->_M_extent, /*_Mip_offset=*/0);

        // release the old texture first before allocating new one to avoid the chance on hitting OOM
        this->_M_texture_descriptor._Set_texture_ptr(NULL);
        _Texture_ptr _Tex_ptr = NULL;

        // See if we need to allocate a staging texture
        if (_Should_create_staging_texture(_Av, _Associated_av)) {

            if (this->_M_texture_descriptor._Get_view_mipmap_levels() > 1)
            {
                throw runtime_exception("Creating staging textures with mipmap levels > 1 is not supported", E_INVALIDARG);
            }

            _Tex_ptr = _Texture::_Create_stage_texture(
                _Associated_av, _Av, _Rank, _Dimensions[0], _Dimensions[1], _Dimensions[2], this->_M_texture_descriptor._Get_view_mipmap_levels(),
                _Short_vector_type_traits<_Value_type>::_Format_base_type_id == _Double_type ? _Uint_type : _Short_vector_type_traits<_Value_type>::_Format_base_type_id,
                _Short_vector_type_traits<_Value_type>::_Num_channels,
                _Bits_per_channel);

            // Now map the texture
            _Tex_ptr->_Map_buffer(_Write_access, true /* _Wait */);
        }
        else {
            _Tex_ptr = _Texture::_Create_texture(_Av, _Rank, _Dimensions[0], _Dimensions[1], _Dimensions[2], this->_M_texture_descriptor._Get_view_mipmap_levels(),
                _Short_vector_type_traits<_Value_type>::_Format_base_type_id == _Double_type ? _Uint_type : _Short_vector_type_traits<_Value_type>::_Format_base_type_id,
                _Short_vector_type_traits<_Value_type>::_Num_channels,
                _Bits_per_channel);
        }

        this->_M_texture_descriptor._Set_texture_ptr(_Tex_ptr);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, unsigned int _Bits_per_scalar_element) __CPU_ONLY
    {
        _Initialize(_Av, _Av, _Bits_per_scalar_element);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av) __CPU_ONLY
    {
        _Initialize(_Av, _Associated_av, Concurrency::graphics::details::_Get_default_bits_per_scalar_element<_Value_type>());
    }

    void _Initialize(const Concurrency::accelerator_view& _Av) __CPU_ONLY
    {
        _Initialize(_Av, _Av);
    }

    template<typename _Input_iterator>
    void _Initialize(const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av, _Input_iterator _Src_first, _Input_iterator _Src_last) __CPU_ONLY
    {
        _Initialize(_Av, _Associated_av);

        auto _Span_id = Concurrency::details::_Get_amp_trace()->_Start_copy_event_helper(nullptr,
                                                                                         Concurrency::details::_Get_texture_descriptor(*this),
                                                                                         this->get_data_length());

        Concurrency::graphics::details::_Copy_async_impl(_Src_first, _Src_last, *this, index<_Rank>(), this->extent)._Get();

        Concurrency::details::_Get_amp_trace()->_Write_end_event(_Span_id);
    }

    template<typename _Input_iterator>
    void _Initialize(const Concurrency::accelerator_view& _Av, _Input_iterator _Src_first, _Input_iterator _Src_last) __CPU_ONLY
    {
        _Initialize(_Av, _Av, _Src_first, _Src_last);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element) __CPU_ONLY
    {
        _Initialize(_Av, _Associated_av, _Bits_per_scalar_element);
        Concurrency::graphics::copy(_Source, _Src_byte_size, *this);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const void * _Source, unsigned int _Src_byte_size, unsigned int _Bits_per_scalar_element) __CPU_ONLY
    {
        _Initialize(_Av, _Av, _Source, _Src_byte_size, _Bits_per_scalar_element);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av, const void * _Source, unsigned int _Src_byte_size) __CPU_ONLY
    {
        _Initialize(_Av, _Associated_av);
        Concurrency::graphics::copy(_Source, _Src_byte_size, *this);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const void * _Source, unsigned int _Src_byte_size) __CPU_ONLY
    {
        _Initialize(_Av, _Av, _Source, _Src_byte_size);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const Concurrency::accelerator_view& _Associated_av, const details::_Texture_base<_Value_type, _Rank> & _Src) __CPU_ONLY
    {
        if (_Src.bits_per_scalar_element != 0) // _Src is not created via interop
        {
            _Initialize(_Av, _Associated_av, _Src.bits_per_scalar_element);
        }
        else // _Src is created via interop, create a new texture with the same properties as the existing one.
        {
            _Texture_ptr _New_tex;
            if (_Should_create_staging_texture(_Av, _Associated_av))
            {
                 _New_tex = _Texture::_Clone_texture(concurrency::details::_Get_texture(_Src), _Associated_av, _Av);
            }
            else
            {
                _New_tex = _Texture::_Clone_texture(concurrency::details::_Get_texture(_Src),  _Av, _Associated_av);
            }
            this->_M_texture_descriptor._Set_texture_ptr(_New_tex);
        }

        auto _Span_id = Concurrency::details::_Get_amp_trace()->_Start_copy_event_helper(Concurrency::details::_Get_texture_descriptor(_Src),
                                                                                         Concurrency::details::_Get_texture_descriptor(*this),
                                                                                         this->get_data_length());

        Concurrency::graphics::details::_Copy_async_impl(_Src, index<_Rank>(), *this, index<_Rank>(), this->extent)._Get();

        Concurrency::details::_Get_amp_trace()->_Write_end_event(_Span_id);
    }

    void _Initialize(const Concurrency::accelerator_view& _Av, const details::_Texture_base<_Value_type, _Rank> & _Src) __CPU_ONLY
    {
        _Initialize(_Av, _Av, _Src);
    }
};

/// <summary>
///     A writeonly_texture_view provides writeonly access to a texture.
/// </summary>
/// <param name="_Value_type">
///     The type of the elements in the texture aggregates.
/// </param>
/// <param name="_Rank">
///     The _Rank of the corresponding extent domain.
/// </param>
template <typename _Value_type, int _Rank> class __declspec(deprecated("writeonly_texture_view is deprecated. Please use texture_view instead.")) writeonly_texture_view : public details::_Texture_base<_Value_type, _Rank>
{
    static_assert(!std::is_const<_Value_type>::value, "const value type is not supported for writeonly_texture_view.");

    using _Texture_base = details::_Texture_base<_Value_type, _Rank>;
public:
    /// <summary>
    ///     Construct a writeonly_texture_view of a texture _Src.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the writeonly view is created.
    /// </param>
    writeonly_texture_view(texture<_Value_type, _Rank>& _Src) __CPU_ONLY
        : _Texture_base(_Src, /*_Most_detailed_mipmap_level=*/0, /*_View_mipmap_levels=*/1)
    {
        _Texture* _Tex = this->_Get_texture();
        if ((_Tex->_Get_num_channels() == 3) && (_Tex->_Get_bits_per_channel() == 32)) {
            throw runtime_exception("writeonly_texture_view cannot be created from a 3-channel texture with 32 bits per scalar element.", E_INVALIDARG);
        }
        if (_Tex->_Is_staging()) {
            throw runtime_exception("writeonly_texture_view cannot be created from a staging texture object.", E_INVALIDARG);
        }
    }

    /// <summary>
    ///     Construct a writeonly_texture_view of a texture _Src.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the writeonly view is created.
    /// </param>
    writeonly_texture_view(texture<_Value_type, _Rank>& _Src) __GPU_ONLY
        : _Texture_base(_Src, /*_Flatten_mipmap_levels=*/true)
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Num_channels == 1, "Invalid value_type for the constructor.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Unorm_type, "Invalid value_type for the constructor.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Norm_type, "Invalid value_type for the constructor.");
    }

    /// <summary>
    ///     Construct a writeonly_texture_view from another writeonly_texture_view. Both are views of the same texture.
    /// </summary>
    /// <param name="_Src">
    ///     The writeonly_texture_view from which the current view is created.
    /// </param>
    writeonly_texture_view(const writeonly_texture_view<_Value_type, _Rank>& _Src) __GPU
        : _Texture_base(_Src)
    {
    }

    /// <summary>
    ///     Assignment operator. This writeonly_texture_view becomes a view of the same texture which _Other is a view of.
    /// </summary>
    /// <param name="_Other">
    ///     The source writeonly_texture_view.
    /// </param>
    writeonly_texture_view<_Value_type, _Rank>& operator=(const writeonly_texture_view<_Value_type, _Rank>& _Other) __GPU
    {
        if (this != &_Other)
        {
            this->_M_extent = _Other._M_extent;
            this->_M_texture_descriptor = _Other._M_texture_descriptor;
        }
        return *this;
    }

    /// <summary>
    ///     Destructor
    /// </summary>
    ~writeonly_texture_view() __GPU
    {
    }

    /// <summary>
    ///     Set the element indexed by _Index with value _Value.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <param name="_Value">
    ///     The value to be set to the element indexed by _Index.
    /// </param>
    void set(const index<_Rank>& _Index, const _Value_type& _Value) const __GPU_ONLY
    {
        _Texture_write_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Value, _Index);
    }
};

/// <summary>
///     A texture_view provides read and write access to a texture.
///     Note that currently texture_view can only be used to read textures whose value type is int, unsigned int and float
///     with default 32 bit bpse. To read other texture formats, use texture_view&lt;const _Value_type, _Rank&gt;.
/// </summary>
/// <param name="_Value_type">
///     The type of the elements in the texture aggregates.
/// </param>
/// <param name="_Rank">
///     The _Rank of the corresponding extent domain.
/// </param>
template <typename _Value_type, int _Rank> class texture_view : public details::_Texture_base<_Value_type, _Rank>
{
    friend class texture_view<const _Value_type, _Rank>;

    using _Texture_base = details::_Texture_base<_Value_type, _Rank>;
public:
    /// <summary>
    ///     Construct a texture_view of a texture _Src on host.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the texture_view is created.
    /// </param>
    /// <param name="_Mipmap_level">
    ///     The specific mipmap level on a _Src texture that this read and write texture_view should bind to.
    ///     The default value 0, binds to the top mosted detail mipmap level.
    /// </param>
    texture_view(texture<_Value_type, _Rank>& _Src, unsigned int _Mipmap_level = 0) __CPU_ONLY
        : _Texture_base(_Src, _Mipmap_level, /*_View_mipmap_levels=*/1)
    {
        if (this->_Get_texture()->_Is_staging()) {
            throw runtime_exception("texture_view cannot be created from a staging texture object.", E_INVALIDARG);
        }
    }

    /// <summary>
    ///     Construct a texture_view of a texture _Src on an accelerator.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the texture_view is created.
    /// </param>
    texture_view(texture<_Value_type, _Rank>& _Src) __GPU_ONLY
        : _Texture_base(_Src, /*_Flatten_mipmap_levels=*/true)
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Num_channels == 1, "writable texture_view can only be created from a single-component texture on an accelerator.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Unorm_type, "writable texture_view cannot be created from a unorm texture on an accelerator.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Norm_type, "writable texture_view cannot be created from a norm texture on an accelerator.");
    }

    /// <summary>
    ///     Construct a texture_view from another texture_view. Both are views of the same texture.
    /// </summary>
    /// <param name="_Other">
    ///     The source texture_view.
    /// </param>
    texture_view(const texture_view<_Value_type, _Rank>& _Other) __GPU
        : _Texture_base(_Other)
    {
    }

    /// <summary>
    ///     Assignment operator. This texture_view becomes a view of the same texture which _Other is a view of.
    /// </summary>
    /// <param name="_Other">
    ///     The source texture_view.
    /// </param>
    texture_view<_Value_type, _Rank>& operator=(const texture_view<_Value_type, _Rank>& _Other) __GPU
    {
        if (this != &_Other)
        {
            this->_M_extent = _Other._M_extent;
            this->_M_texture_descriptor = _Other._M_texture_descriptor;
        }
        return *this;
    }

    /// <summary>
    ///     Destructor
    /// </summary>
    ~texture_view() __GPU
    {
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type operator[] (const index<_Rank>& _Index) const __GPU_ONLY
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Num_channels == 1, "Read is only permissible on single-component writable texture_view.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Unorm_type, "Read is not permissible on a writable unorm texture_view.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Norm_type, "Read is not permissible on a writable norm texture_view.");

        _Value_type _Tmp;
        _Texture_read_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Tmp, _Index, /*_Mip_level=*/0);
        return _Tmp;
    }

    /// <summary>
    ///     Get the element value indexed by _I0.
    /// </summary>
    /// <param name="_I0">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _I0.
    /// </returns>
    const _Value_type operator[] (int _I0) const __GPU_ONLY
    {
        static_assert(_Rank == 1, "const value_type operator[](int) is only permissible on texture_view<value_type, 1>.");
        return (*this)[index<1>(_I0)];
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type operator() (const index<_Rank>& _Index) const __GPU_ONLY
    {
        return (*this)[_Index];
    }

    /// <summary>
    ///     Get the element value indexed by _I0
    /// </summary>
    /// <param name="_I0">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _I0.
    /// </returns>
    const _Value_type operator() (int _I0) const __GPU_ONLY
    {
        static_assert(_Rank == 1, "const value_type operator()(int) is only permissible on texture_view<value_type, 1>.");
        return (*this)[index<1>(_I0)];
    }

    /// <summary>
    ///     Get the element value indexed by (_I0,_I1)
    /// </summary>
    /// <param name="_I0">
    ///     The most-significant component of the index
    /// </param>
    /// <param name="_I1">
    ///     The least-significant component of the index
    /// </param>
    /// <returns>
    ///     The element value indexed by (_I0,_I1)
    /// </returns>
    const _Value_type operator() (int _I0, int _I1) const __GPU_ONLY
    {
        static_assert(_Rank == 2, "const value_type operator()(int, int) is only permissible on texture_view<value_type, 2>.");
        return (*this)[index<2>(_I0, _I1)];
    }

    /// <summary>
    ///     Get the element value indexed by (_I0,_I1,_I2)
    /// </summary>
    /// <param name="_I0">
    ///     The most-significant component of the index
    /// </param>
    /// <param name="_I1">
    ///     The next-to-most-significant component of the index
    /// </param>
    /// <param name="_I2">
    ///     The least-significant component of the index
    /// </param>
    /// <returns>
    ///     The element value indexed by (_I0,_I1,_I2)
    /// </returns>
    const _Value_type operator() (int _I0, int _I1, int _I2) const __GPU_ONLY
    {
        static_assert(_Rank == 3, "const value_type operator()(int, int, int) is only permissible on texture_view<value_type, 3>.");
        return (*this)[index<3>(_I0, _I1, _I2)];
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type get(const index<_Rank>& _Index) const __GPU_ONLY
    {
        return (*this)[_Index];
    }

    /// <summary>
    ///     Set the element indexed by _Index with value _Value.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <param name="_Value">
    ///     The value to be set to the element indexed by _Index.
    /// </param>
    void set(const index<_Rank>& _Index, const _Value_type& _Value) const __GPU_ONLY
    {
        _Texture_write_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Value, _Index);
    }
};

/// <summary>
///    filter modes supported for texture sampling
/// </summary>
enum filter_mode
{
    filter_point    = 0,
    filter_linear   = 0x15,
    filter_unknown  = 0xFFFFFFFF,
};

/// <summary>
///    address modes supported for texture sampling
/// </summary>
enum address_mode
{
    address_wrap    = 1,
    address_mirror  = 2,
    address_clamp   = 3,
    address_border  = 4,
    address_unknown = 0xFFFFFFFF,
};

/// <summary>
///     A sampler class aggregates sampling configuration information to be used for texture sampling.
/// </summary>
class sampler
{
    friend sampler direct3d::make_sampler(_In_ IUnknown *_D3D_sampler) __CPU_ONLY;
    friend _Ret_ IUnknown * direct3d::get_sampler(const Concurrency::accelerator_view &_Av, const sampler &_Sampler) __CPU_ONLY;

    template <typename _Value_type, int _Rank>
    friend class texture_view;

public:
    /// <summary>
    ///     Constructs a sampler with default filter mode (filter_lienar, same for min, mag, mip), addressing
    ///     mode (address_clamp, same for all dimensions), and border color (float_4(0.0f, 0.0f, 0.0f, 0.0f)).
    /// </summary>
    sampler() __CPU_ONLY
        : _M_filter_mode(filter_linear),
          _M_address_mode(address_clamp),
          _M_border_color(float_4(0.0f, 0.0f, 0.0f, 0.0f))
    {
        _Initialize();
    }

    /// <summary>
    ///     Constructs a sampler with specified filter mode (same for min, mag, mip), but with default addressing
    ///     mode (address_clamp, same for all dimensions) and border color ( float_4(0.0f, 0.0f, 0.0f, 0.0f)).
    /// </summary>
    /// <param name="_Filter_mode">
    ///     The filter mode to be used in sampling.
    /// </param>
    sampler(filter_mode _Filter_mode)__CPU_ONLY
        : _M_filter_mode(_Filter_mode),
          _M_address_mode(address_clamp),
          _M_border_color(float_4(0.0f, 0.0f, 0.0f, 0.0f))
    {
        _Initialize();
    }

    /// <summary>
    ///     Constructs a sampler with default filter mode (filter_linear, same for min, mag, mip), but specified
    ///     addressing mode (same for all dimensions) and border color.
    /// </summary>
    /// <param name="_Address_mode">
    ///     The addressing mode to be used in sampling for all dimensions.
    /// </param>
    /// <param name="_Border_color">
    ///     The border color to be used if address mode is address_border. If not specified, default value is float_4(0.f, 0.f, 0.f, 0.f).
    /// </param>
    sampler(address_mode _Address_mode, float_4 _Border_color = float_4(0.0f, 0.0f, 0.0f, 0.0f)) __CPU_ONLY
        : _M_filter_mode(filter_linear),
          _M_address_mode(_Address_mode),
          _M_border_color(_Border_color)
    {
        _Initialize();
    }

    /// <summary>
    ///     Constructs a sampler with specified filter mode (same for min, mag, mip), addressing
    ///     mode (same for all dimensions) and the border color.
    /// </summary>
    /// <param name="_Filter_mode">
    ///     The filter mode to be used in sampling.
    /// </param>
    /// <param name="_Address_mode">
    ///     The addressing mode to be used in sampling for all dimensions.
    /// </param>
    /// <param name="_Border_color">
    ///     The border color to be used if address mode is address_border. If not specified, default value is float_4(0.f, 0.f, 0.f, 0.f).
    /// </param>
    sampler(filter_mode _Filter_mode, address_mode _Address_mode, float_4 _Border_color = float_4(0.0f, 0.0f, 0.0f, 0.0f)) __CPU_ONLY
        : _M_filter_mode(_Filter_mode),
          _M_address_mode(_Address_mode),
          _M_border_color(_Border_color)
    {
        _Initialize();
    }

    /// <summary>
    ///     Copy constructor.
    /// </summary>
    /// <param name="_Other">
    ///     An object of type sampler from which to initialize this new sampler.
    /// </param>
    sampler(const sampler& _Other) __GPU
        : _M_sampler_descriptor(_Other._M_sampler_descriptor),
          _M_filter_mode(_Other._M_filter_mode),
          _M_address_mode(_Other._M_address_mode),
          _M_border_color(_Other._M_border_color)
    {
    }

    /// <summary>
    ///     Move constructor.
    /// </summary>
    /// <param name="_Other">
    ///     The sampler to move from.
    /// </param>
    sampler(sampler &&_Other) __GPU
        : _M_sampler_descriptor(_Other._M_sampler_descriptor),
          _M_filter_mode(_Other._M_filter_mode),
          _M_address_mode(_Other._M_address_mode),
          _M_border_color(_Other._M_border_color)
    {
        _Other._M_sampler_descriptor._M_data_ptr = NULL;
        _Other._M_sampler_descriptor._Set_sampler_ptr(NULL);
    }

    /// <summary>
    ///     Assignment operator.
    /// </summary>
    /// <param name="_Other">
    ///     An object of type sampler from which to copy into this sampler.
    /// </param>
    /// <returns>
    ///     A reference to this sampler.
    /// </returns>
    sampler& operator=(const sampler& _Other) __GPU
    {
        if (this != &_Other)
        {
            _M_filter_mode = _Other._M_filter_mode;
            _M_address_mode = _Other._M_address_mode;
            _M_border_color = _Other._M_border_color;
            _M_sampler_descriptor = _Other._M_sampler_descriptor;
        }
        return *this;
    }

    /// <summary>
    ///     Move assignment operator.
    /// </summary>
    /// <param name="_Other">
    ///     An object of type sampler to move from.
    /// </param>
    /// <returns>
    ///     A reference to this sampler.
    /// </returns>
    sampler& operator=(sampler&& _Other) __GPU
    {
        if (this != &_Other)
        {
            _M_filter_mode = _Other._M_filter_mode;
            _M_address_mode = _Other._M_address_mode;
            _M_border_color = _Other._M_border_color;
            _M_sampler_descriptor = _Other._M_sampler_descriptor;
            _Other._M_sampler_descriptor._M_data_ptr = NULL;
            _Other._M_sampler_descriptor._Set_sampler_ptr(NULL);
        }
        return *this;
    }

    /// <summary>
    ///     Returns the sampler's filter mode
    /// </summary>
    __declspec(property(get=get_filter_mode)) Concurrency::graphics::filter_mode filter_mode;
    Concurrency::graphics::filter_mode get_filter_mode() const __GPU
    {
        return _M_filter_mode;
    }

    /// <summary>
    ///     Returns the sampler's address mode
    /// </summary>
    __declspec(property(get=get_address_mode)) Concurrency::graphics::address_mode address_mode;
    Concurrency::graphics::address_mode get_address_mode() const __GPU
    {
        return _M_address_mode;
    }

    /// <summary>
    ///     Returns the sampler's border value
    /// </summary>
    __declspec(property(get=get_border_color)) Concurrency::graphics::float_4 border_color;
    Concurrency::graphics::float_4 get_border_color() const __GPU
    {
        return _M_border_color;
    }

private:
    // internal storage abstraction
    typedef Concurrency::details::_Sampler_descriptor _Sampler_descriptor;

    // a private constructor to be used for constructing a sampler via interop.
    sampler(const _Sampler_descriptor & _Descriptor) __CPU_ONLY
        : _M_sampler_descriptor(_Descriptor),
          _M_filter_mode(filter_unknown),
          _M_address_mode (address_unknown),
          _M_border_color(float_4(0.0f, 0.0f, 0.0f, 0.0f))
    {
        // Although we could query border value from the adopted sampler, but it's not that useful
        // given that this is the only thing that we could query and when the address mode is not
        // address_border, border value is not relevant.
    }

    _Ret_ _Sampler* _Get_sampler_ptr() const __CPU_ONLY
    {
        return _M_sampler_descriptor._Get_sampler_ptr();
    }

    void _Initialize() __CPU_ONLY
    {
        // Check if the given filter_mode and address_mode are valid C++ AMP ones
        if ((_M_filter_mode != filter_point && _M_filter_mode != filter_linear) ||
           (_M_address_mode != address_wrap && _M_address_mode != address_mirror &&
            _M_address_mode != address_clamp && _M_address_mode != address_border))
        {
            throw runtime_exception("Invalid sampler configuration", E_INVALIDARG);
        }

        _Sampler_ptr samplerPtr = _Sampler::_Create(_M_filter_mode, _M_address_mode,
                            _M_border_color.r, _M_border_color.g, _M_border_color.b, _M_border_color.a);
        _M_sampler_descriptor._Set_sampler_ptr(samplerPtr);
    }

    const _Sampler_descriptor & _Get_descriptor() const __GPU_ONLY
    {
        return _M_sampler_descriptor;
    }

    _Sampler_descriptor _M_sampler_descriptor;
    Concurrency::graphics::filter_mode _M_filter_mode;
    Concurrency::graphics::address_mode _M_address_mode;
    float_4 _M_border_color;
};

/// <summary>
///     A texture_view&lt;const _Value_type, _Rank&gt; provides read-only access and sampling capability to a texture.
/// </summary>
/// <param name="_Value_type">
///     The type of the elements in the texture aggregates.
/// </param>
/// <param name="_Rank">
///     The _Rank of the corresponding extent domain.
/// </param>
template <typename _Value_type, int _Rank> class texture_view<const _Value_type, _Rank> : public details::_Texture_base<_Value_type, _Rank>
{
public:
    typedef const _Value_type value_type;
    typedef typename short_vector<float, _Rank>::type coordinates_type;
    typedef typename short_vector<typename details::_Texture_base<_Value_type, _Rank>::scalar_type, 4>::type gather_return_type;

    using _Texture_base = details::_Texture_base<_Value_type, _Rank>;
    /// <summary>
    ///     Construct a read-only texture_view of a texture _Src on an accelerator.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the read-only view is created.
    /// </param>
    texture_view(const texture<_Value_type, _Rank>& _Src) __GPU_ONLY
        : _Texture_base(_Src)
    {
        // only on the gpu it is not allowed
        static_assert(_Short_vector_type_traits<_Value_type>::_Num_channels != 1, "Read-only texture_view cannot be created from single-component textures on an accelerator.");
    }

    /// <summary>
    ///     Construct a texture_view of a texture _Src on the host.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the read-only view is created.
    /// </param>
    texture_view(const texture<_Value_type, _Rank>& _Src) __CPU_ONLY
        : _Texture_base(_Src)
    {
        if (this->_Get_texture()->_Is_staging()) {
            throw runtime_exception("Read-only texture_view cannot be created from a staging texture object.", E_INVALIDARG);
        }
    }

    /// <summary>
    ///     Construct a read-only texture_view with specific range of mipmap levels of a texture _Src on the host.
    /// </summary>
    /// <param name="_Src">
    ///     The texture on which the read-only view is created.
    /// </param>
    /// <param name="_Most_detailed_mip">
    ///     Most detailed mipmap level for the view.
    /// </param>
    /// <param name="_Mip_levels">
    ///     The number of mipmap levels accessible for the view.
    /// </param>
    texture_view(const texture<_Value_type, _Rank>& _Src, unsigned int _Most_detailed_mip, unsigned int _Mip_levels) __CPU_ONLY
        : _Texture_base(_Src, _Most_detailed_mip, _Mip_levels)
    {
        if (this->_Get_texture()->_Is_staging()) {
            throw runtime_exception("Read-only texture_view cannot be created from a staging texture object.", E_INVALIDARG);
        }
    }

    /// <summary>
    ///     Construct a read-only texture_view of a writable texture_view.
    /// </summary>
    /// <param name="_Other">
    ///     The writable texture view from which the read-only view is created.
    /// </param>
    texture_view(const texture_view<_Value_type, _Rank>& _Other) __CPU_ONLY
        : _Texture_base(_Other)
    {
    }

    /// <summary>
    ///     Construct a read-only texture_view from another read-only texture_view. Both are views of the same texture.
    /// </summary>
    /// <param name="_Other">
    ///     The source read-only texture_view.
    /// </param>
    texture_view(const texture_view<const _Value_type, _Rank>& _Other) __GPU
        : _Texture_base(_Other)
    {
    }

    /// <summary>
    ///     Construct a read-only texture_view from another read-only texture_view.
    ///      Allows narrowing down the accessible range of mipmap levels for the texture_view.
    ///      Both are views of the same texture.
    /// </summary>
    /// <param name="_Other">
    ///     The source read-only texture_view.
    /// </param>
    /// <param name="_Most_detailed_mip">
    ///     Top level mipmap for the view, relative to the input texture_view.
    /// </param>
    /// <param name="_Mip_levels">
    ///     The number of mipmap levels accessible for the view.
    /// </param>
    texture_view(const texture_view<const _Value_type, _Rank>& _Other, unsigned int _Most_detailed_mip, unsigned int _Mip_levels) __CPU_ONLY
        : _Texture_base(_Other, _Most_detailed_mip, _Mip_levels)
    {
    }

    /// <summary>
    ///     Assignment operator. This read-only texture_view becomes a view of the same texture which _Other is a view of.
    /// </summary>
    /// <param name="_Other">
    ///     The source read-only texture_view.
    /// </param>
    texture_view<const _Value_type, _Rank>& operator=(const texture_view<const _Value_type, _Rank>& _Other) __GPU
    {
        if (this != &_Other)
        {
            this->_M_extent = _Other._M_extent;
            this->_M_texture_descriptor = _Other._M_texture_descriptor;
        }
        return *this;
    }

    /// <summary>
    ///     Assignment operator from a writable texture_view.
    ///     This read-only texture_view becomes a view of the same texture which _Other is a view of.
    /// </summary>
    /// <param name="_Other">
    ///     The source writable texture_view.
    /// </param>
    texture_view<const _Value_type, _Rank>& operator=(const texture_view<_Value_type, _Rank>& _Other) __CPU_ONLY
    {
        this->_M_extent = _Other._M_extent;
        this->_M_texture_descriptor = _Other._M_texture_descriptor;
        return *this;
    }

    /// <summary>
    ///     Destructor
    /// </summary>
    ~texture_view() __GPU
    {
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type operator[] (const index<_Rank>& _Index) const __GPU_ONLY
    {
        _Value_type _Tmp;
        _Texture_read_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Tmp, _Index, /*_Mip_level=*/0);
        return _Tmp;
    }

    /// <summary>
    ///     Get the element value indexed by _I.
    /// </summary>
    /// <param name="_I">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _I.
    /// </returns>
    const _Value_type operator[] (int _I0) const __GPU_ONLY
    {
        static_assert(_Rank == 1, "value_type operator[](int) is only permissible on texture_view<value_type, 1>.");
        return (*this)[index<1>(_I0)];
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type operator() (const index<_Rank>& _Index) const __GPU_ONLY
    {
        return (*this)[_Index];
    }

    /// <summary>
    ///     Get the element value indexed by _I0
    /// </summary>
    /// <param name="_I0">
    ///     The index.
    /// </param>
    /// <returns>
    ///     The element value indexed by _I0.
    /// </returns>
    const _Value_type operator() (int _I0) const __GPU_ONLY
    {
        static_assert(_Rank == 1, "value_type texture_view::operator()(int) is only permissible on texture_view<value_type, 1>.");
        return (*this)[index<1>(_I0)];
    }

    /// <summary>
    ///     Get the element value indexed by (_I0,_I1)
    /// </summary>
    /// <param name="_I0">
    ///     The most-significant component of the index
    /// </param>
    /// <param name="_I1">
    ///     The least-significant component of the index
    /// </param>
    /// <returns>
    ///     The element value indexed by (_I0,_I1)
    /// </returns>
    const _Value_type operator() (int _I0, int _I1) const __GPU_ONLY
    {
        static_assert(_Rank == 2, "value_type texture_view::operator()(int, int) is only permissible on texture_view<value_type, 2>.");
        return (*this)[index<2>(_I0, _I1)];
    }

    /// <summary>
    ///     Get the element value indexed by (_I0,_I1,_I2)
    /// </summary>
    /// <param name="_I0">
    ///     The most-significant component of the index
    /// </param>
    /// <param name="_I1">
    ///     The next-to-most-significant component of the index
    /// </param>
    /// <param name="_I2">
    ///     The least-significant component of the index
    /// </param>
    /// <returns>
    ///     The element value indexed by (_I0,_I1,_I2)
    /// </returns>
    const _Value_type operator() (int _I0, int _I1, int _I2) const __GPU_ONLY
    {
        static_assert(_Rank == 3, "value_type texture_view::operator()(int, int, int) is only permissible on texture_view<value_type, 3>.");
        return (*this)[index<3>(_I0, _I1, _I2)];
    }

    /// <summary>
    ///     Get the element value indexed by _Index.
    /// </summary>
    /// <param name="_Index">
    ///     The index.
    /// </param>
    /// <param name="_Mip_level">
    ///     The mipmap level from which we should get indexed value.
    ///     The default value 0 represents most detailed mipmap level.
    /// </param>
    /// <returns>
    ///     The element value indexed by _Index.
    /// </returns>
    const _Value_type get(const index<_Rank>& _Index, unsigned int _Mip_level = 0) const __GPU_ONLY
    {
        _Value_type _Tmp;
        _Texture_read_helper<index<_Rank>, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Tmp, _Index, _Mip_level);
        return _Tmp;
    }

    /// <summary>
    ///     Sample the texture at the given coordinates and level of detail using the specified sampling configuration.
    /// </summary>
    /// <param name="_Sampler">
    ///     The sampler that configures the sampling operation.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <param name="_Level_of_detail">
    ///     The value specifies the mipmap level to sample from.
    ///     Fractional value is used to interpolate between two mipmap levels.
    /// </param>
    /// <returns>
    ///     The interpolated value.
    /// </returns>
    const _Value_type sample(const sampler& _Sampler, const coordinates_type& _Coord, float _Level_of_detail = 0.0f) const __GPU_ONLY
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Uint_type, "sample is not allowed for uint component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Int_type, "sample is not allowed for int component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Double_type, "sample is not allowed for double component types in the texture value_type.");

        _Value_type _Tmp;
        _Texture_sample_helper<coordinates_type, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, _Sampler._Get_descriptor()._M_data_ptr, &_Tmp, _Coord, 4 /*Sampling*/, _Level_of_detail);
        return _Tmp;
    }

    /// <summary>
    ///     Sample the texture at the given coordinates and level of detail using the predefined sampling configuration.
    /// </summary>
    /// <param name="_Filter_mode">
    ///     The filter mode of the predefined sampler to be used.
    /// </param>
    /// <param name="_Address_mode">
    ///     The address mode of the predefined sampler to be used.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <param name="_Level_of_detail">
    ///     The value specifies the mipmap level to sample from.
    ///     Fractional value is used to interpolate between two mipmap levels.
    /// </param>
    /// <returns>
    ///     The interpolated value.
    /// </returns>
    template<filter_mode _Filter_mode = filter_linear, address_mode _Address_mode = address_clamp>
    const _Value_type sample(const coordinates_type& _Coord, float _Level_of_detail = 0.0f) const __GPU_ONLY
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Uint_type, "sample is not allowed for uint component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Int_type, "sample is not allowed for int component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Double_type, "sample is not allowed for double component types in the texture value_type.");
        static_assert((_Filter_mode == filter_point || _Filter_mode == filter_linear), "Invalid filter mode for sample method.");
        static_assert((_Address_mode == address_wrap || _Address_mode == address_clamp || _Address_mode == address_mirror || _Address_mode == address_border),
                                "Invalid address mode for sample method.");

        _Value_type _Tmp;
        // Predefined sampler id is constructed as filter_mode << 16 | address_mode. This is a contract between BE and runtime. Modify with caution!
        _Texture_predefined_sample_helper<coordinates_type, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Tmp, _Coord, _Filter_mode << 16 |_Address_mode, 4 /*Sampling*/, _Level_of_detail);
        return _Tmp;
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the specified sampling configuration and return the red (x) component of the four texels samples.
    /// </summary>
    /// <param name="_Sampler">
    ///     The sampler that configures the sampling operation.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the red (x) component of the 4 texel values sampled.
    /// </returns>
    const gather_return_type gather_red(const sampler& _Sampler, const coordinates_type& _Coord) const __GPU_ONLY
    {
        return _Gather(_Sampler, _Coord, 0);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the specified sampling configuration and return the green (y) component of the four texels samples.
    /// </summary>
    /// <param name="_Sampler">
    ///     The sampler that configures the sampling operation.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the green (y) component of the 4 texel values sampled.
    /// </returns>
    const gather_return_type gather_green(const sampler& _Sampler, const coordinates_type& _Coord) const __GPU_ONLY
    {
        static_assert(1 < _Short_vector_type_traits<_Value_type>::_Num_channels, "gather_green is valid only for textures with 2 or more components in the value_type.");

        return _Gather(_Sampler, _Coord, 1);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the specified sampling configuration and return the blue (z) component of the four texels samples.
    /// </summary>
    /// <param name="_Sampler">
    ///     The sampler that configures the sampling operation.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the blue (z) component of the 4 texel values sampled.
    /// </returns>
    const gather_return_type gather_blue(const sampler& _Sampler, const coordinates_type& _Coord) const __GPU_ONLY
    {
        static_assert(2 < _Short_vector_type_traits<_Value_type>::_Num_channels, "gather_blue is valid only for textures with 3 or more components in the value_type.");

        return _Gather(_Sampler, _Coord, 2);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the specified sampling configuration and return the alpha (w) component of the four texels samples.
    /// </summary>
    /// <param name="_Sampler">
    ///     The sampler that configures the sampling operation.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the alpha (w) component of the 4 texel values sampled.
    /// </returns>
    const gather_return_type gather_alpha(const sampler& _Sampler, const coordinates_type& _Coord) const __GPU_ONLY
    {
        static_assert(3 < _Short_vector_type_traits<_Value_type>::_Num_channels, "gather_alpha is valid only for textures with 4 components in the value_type.");

        return _Gather(_Sampler, _Coord, 3);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the predefined sampling configuration and return the red (x) component of the four texels samples.
    /// </summary>
    /// <param name="_Address_mode">
    ///     The address mode of the predefined sampler to be used.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the red (x) component of the 4 texel values sampled.
    /// </returns>
    template<address_mode _Address_mode = address_clamp>
    const gather_return_type gather_red(const coordinates_type& _Coord) const __GPU_ONLY
    {
        return _Gather<_Address_mode>(_Coord, 0);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the predefined sampling configuration and return the green (y) component of the four texels samples.
    /// </summary>
    /// <param name="_Address_mode">
    ///     The address mode of the predefined sampler to be used.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the green (y)component of the 4 texel values sampled.
    /// </returns>
    template<address_mode _Address_mode = address_clamp>
    const gather_return_type gather_green(const coordinates_type& _Coord) const __GPU_ONLY
    {
        static_assert(1 < _Short_vector_type_traits<_Value_type>::_Num_channels, "gather_green is valid only for textures with 2 or more components in the value_type.");

        return _Gather<_Address_mode>(_Coord, 1);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the predefined sampling configuration and return the blue (z) component of the four texels samples.
    /// </summary>
    /// <param name="_Address_mode">
    ///     The address mode of the predefined sampler to be used.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the blue (z) component of the 4 texel values sampled.
    /// </returns>
    template<address_mode _Address_mode = address_clamp>
    const gather_return_type gather_blue(const coordinates_type& _Coord) const __GPU_ONLY
    {
        static_assert(2 < _Short_vector_type_traits<_Value_type>::_Num_channels, "gather_blue is valid only for textures with 3 or more components in the value_type.");

        return _Gather<_Address_mode>(_Coord, 2);
    }

    /// <summary>
    ///     Sample the texture at the given coordinates using the predefined sampling configuration and return the alpha (w) component of the four texels samples.
    /// </summary>
    /// <param name="_Address_mode">
    ///     The address mode of the predefined sampler to be used.
    /// </param>
    /// <param name="_Coord">
    ///     Coordinate vector for sampling.
    /// </param>
    /// <returns>
    ///     Rank 4 short vector containing the alpha (w) component of the 4 texel values sampled.
    /// </returns>
    template<address_mode _Address_mode = address_clamp>
    const gather_return_type gather_alpha(const coordinates_type& _Coord) const __GPU_ONLY
    {
        static_assert(3 < _Short_vector_type_traits<_Value_type>::_Num_channels, "gather_alpha is valid only for textures with 4 components in the value_type.");

        return _Gather<_Address_mode>(_Coord, 3);
    }

private:
    const gather_return_type _Gather(const sampler& _Sampler, const coordinates_type& _Coord, unsigned int _Component) const __GPU_ONLY
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Uint_type, "gather is not allowed for uint component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Int_type, "gather is not allowed for int component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Double_type, "gather is not allowed for double component types in the texture value_type.");
        static_assert(_Rank == 2, "gather methods are only permissible on texture_view<value_type, 2>.");

        gather_return_type _Tmp;
        _Texture_sample_helper<coordinates_type, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, _Sampler._Get_descriptor()._M_data_ptr, &_Tmp, _Coord, _Component, /*_Level_of_detail=*/0.0f);
        return _Tmp;
    }

    template<address_mode _Address_mode>
    const gather_return_type _Gather(const coordinates_type& _Coord, unsigned int _Component) const __GPU_ONLY
    {
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Uint_type, "gather is not allowed for uint component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Int_type, "gather is not allowed for int component types in the texture value_type.");
        static_assert(_Short_vector_type_traits<_Value_type>::_Format_base_type_id != _Double_type, "gather is not allowed for double component types in the texture value_type.");
        static_assert(_Rank == 2, "gather methods are only permissible on texture_view<value_type, 2>.");
        static_assert((_Address_mode == address_wrap || _Address_mode == address_clamp || _Address_mode == address_mirror || _Address_mode == address_border),
                                "Invalid address mode for gather methods.");

        gather_return_type _Tmp;
        // Predefined sampler id is constructed as filter_mode << 16 | address_mode. This is a contract between BE and runtime. Modify with caution!
        // gather only used the address_mode of the sampler, internally we use filter_point so that the predefined sampler id scheme is same for both sample and gather.
        _Texture_predefined_sample_helper<coordinates_type, _Rank>::func(this->_M_texture_descriptor._M_data_ptr, &_Tmp, _Coord, filter_point << 16 |_Address_mode, _Component, /*_Level_of_detail=*/0.0f);
        return _Tmp;
    }
};


namespace details
{
template<int _Rank>
Concurrency::extent<_Rank> _Make_texture(const Concurrency::accelerator_view &_Av, _In_ IUnknown *_D3D_texture, _Texture_base_type_id _Id, _Inout_ _Texture ** _Tex, DXGI_FORMAT _View_format) __CPU_ONLY
{
    if (_D3D_texture == NULL)
    {
        throw runtime_exception("NULL D3D texture pointer.", E_INVALIDARG);
    }

    if (!Concurrency::details::_Is_D3D_accelerator_view(_Av)) {
        throw runtime_exception("Cannot create D3D texture on a non-D3D accelerator_view.", E_INVALIDARG);
    }

    _Texture * _Tex_ptr = _Texture::_Adopt_texture(_Rank, _Id, _D3D_texture, _Av, _View_format);
    if (_Tex_ptr->_Is_staging())
    {
        _Tex_ptr->_Map_buffer(_Write_access, true /* _Wait */);
    }
    Concurrency::extent<_Rank> _Ext = Concurrency::graphics::details::_Create_extent<_Rank>(_Tex_ptr->_Get_width(), _Tex_ptr->_Get_height(), _Tex_ptr->_Get_depth());

    _Is_valid_extent(_Ext);
    details::_Is_valid_data_length(_Ext.size(), _Tex_ptr->_Get_bits_per_element());

    *_Tex = _Tex_ptr;
    return _Ext;
}

} // namespace details

namespace direct3d
{
    /// <summary>
    ///     Get the D3D texture interface underlying a texture.
    /// </summary>
    /// <param name="_Rank">
    ///     The rank of the texture to get underlying D3D texture of.
    /// </param>
    /// <param name="_Value_type">
    ///     The type of the elements in the texture to get underlying D3D texture of.
    /// </param>
    /// <param name="_Texture">
    ///     A texture on a D3D accelerator_view for which the underlying D3D texture interface is returned.
    /// </param>
    /// <returns>
    ///     The IUnknown interface pointer corresponding to the D3D texture underlying the texture.
    /// </returns>
    template<typename _Value_type, int _Rank> _Ret_ IUnknown *get_texture(const texture<_Value_type, _Rank> &_Texture) __CPU_ONLY
    {
        return Concurrency::details::_D3D_interop::_Get_D3D_texture(Concurrency::details::_Get_texture(_Texture));
    }

    /// <summary>
    ///     Get the D3D texture interface underlying a texture viewed by a writeonly_texture_view.
    /// </summary>
    /// <param name="_Rank">
    ///     The rank of the texture to get underlying D3D texture of.
    /// </param>
    /// <param name="_Value_type">
    ///     The type of the elements in the texture to get underlying D3D texture of.
    /// </param>
    /// <param name="_Texture">
    ///     A writeonly_texture_view of a texture on a D3D accelerator_view for which the underlying D3D texture interface is returned.
    /// </param>
    /// <returns>
    ///     The IUnknown interface pointer corresponding to the D3D texture underlying the texture.
    /// </returns>
    template<typename _Value_type, int _Rank> _Ret_ IUnknown *get_texture(const writeonly_texture_view<_Value_type, _Rank> &_Texture) __CPU_ONLY
    {
        return Concurrency::details::_D3D_interop::_Get_D3D_buffer(Concurrency::details::_Get_texture(_Texture));
    }

    /// <summary>
    ///     Get the D3D texture interface underlying a texture viewed by a texture_view.
    /// </summary>
    /// <param name="_Rank">
    ///     The rank of the texture to get underlying D3D texture of.
    /// </param>
    /// <param name="_Value_type">
    ///     The type of the elements in the texture to get underlying D3D texture of.
    /// </param>
    /// <param name="_Texture">
    ///     A texture_view of a texture on a D3D accelerator_view for which the underlying D3D texture interface is returned.
    /// </param>
    /// <returns>
    ///     The IUnknown interface pointer corresponding to the D3D texture underlying the texture.
    /// </returns>
    template<typename _Value_type, int _Rank> _Ret_ IUnknown *get_texture(const texture_view<_Value_type, _Rank> &_Texture) __CPU_ONLY
    {
        return Concurrency::details::_D3D_interop::_Get_D3D_buffer(Concurrency::details::_Get_texture(_Texture));
    }

    /// <summary>
    ///     Create an texture from a D3D texture interface pointer, optionally using the specified DXGI format for all
    ///     views on this texture.
    /// </summary>
    /// <param name="_Rank">
    ///     The rank of the texture to be created from the D3D texture.
    /// </param>
    /// <param name="_Value_type">
    ///     The type of the elements of the texture to be created from the D3D texture.
    /// </param>
    /// <param name="_Av">
    ///     A D3D accelerator view on which the texture is to be created.
    /// </param>
    /// <param name="_D3D_texture">
    ///     IUnknown interface pointer of the D3D texture to create the texture from.
    /// </param>
    /// <param name="_View_format">
    ///     The DXGI format to use for views created from this texture.  Pass DXGI_FORMAT_UNKNOWN (the default)
    ///     to derive the format from the underlying format of _D3D_texture and the _Value_type of this template.
    ///     The provided format must be compatible with the underlying format of _D3D_texture.
    /// </param>
    /// <returns>
    ///     A texture using the provided D3D texture.
    /// </returns>
    template<typename _Value_type, int _Rank> texture<_Value_type, _Rank> make_texture(const Concurrency::accelerator_view &_Av, _In_ IUnknown *_D3D_texture,
                                                                                       DXGI_FORMAT _View_format /*= DXGI_FORMAT_UKNNOWN*/) __CPU_ONLY
    {
        _Texture * _Tex_ptr = NULL;
        Concurrency::extent<_Rank> _Ext = Concurrency::graphics::details::_Make_texture<_Rank>(_Av, _D3D_texture,
            _Short_vector_type_traits<_Value_type>::_Format_base_type_id == _Double_type ? _Uint_type : _Short_vector_type_traits<_Value_type>::_Format_base_type_id,
            &_Tex_ptr, _View_format);

        _ASSERTE(_Tex_ptr);
        return texture<_Value_type, _Rank>(_Ext, _Texture_descriptor(_Tex_ptr));
    }

    /// <summary>
    ///     Get the D3D sampler state interface on the given accelerator view that represents the specified sampler object.
    /// </summary>
    /// <param name="_Av">
    ///     A D3D accelerator view on which the D3D sampler state is to be created.
    /// </param>
    /// <param name="_Sampler">
    ///     A sampler object for which the underlying D3D sampler state interface is created.
    /// </param>
    /// <returns>
    ///     The IUnknown interface pointer corresponding to the D3D sampler state that represents the given sampler.
    /// </returns>
    inline _Ret_ IUnknown * get_sampler(const Concurrency::accelerator_view &_Av, const sampler &_Sampler) __CPU_ONLY
    {
        return Concurrency::details::_D3D_interop::_Get_D3D_sampler(_Av, _Sampler._Get_sampler_ptr());
    }

    /// <summary>
    ///     Create a sampler from a D3D sampler state interface pointer.
    /// </summary>
    /// <param name="_D3D_sampler">
    ///     IUnknown interface pointer of the D3D sampler state to create the sampler from.
    /// </param>
    /// <returns>
    ///     A sampler represents the provided D3D sampler state.
    /// </returns>
    inline sampler make_sampler(_In_ IUnknown *_D3D_sampler) __CPU_ONLY
    {
        return sampler(_Sampler_descriptor(_Sampler::_Create(_D3D_interop::_Get_D3D_sampler_data_ptr(_D3D_sampler))));
    }

    /// <summary>
    ///     Compares a 4-byte reference value and an 8-byte source value and
    ///     accumulates a vector of 4 sums. Each sum corresponds to the masked
    ///     sum of absolute differences of different byte alignments between
    ///     the reference value and the source value.
    /// </summary>
    /// <param name="_Reference">
    ///     The reference array of 4 bytes in one uint value
    /// </param>
    /// <param name="_Source">
    ///     The source array of 8 bytes in a vector of two uint values.
    /// </param>
    /// <param name="_Accum">
    ///     A vector of 4 values to be added to the masked sum of absolute
    ///     differences of the different byte alignments between the reference
    ///     value and the source value.
    /// </param>
    /// <returns>
    ///     Returns a vector of 4 sums. Each sum corresponds to the masked sum
    ///     of absolute differences of different byte alignments between the reference
    ///     value and the source value.
    /// </returns>
    inline uint4 msad4(uint _Reference, uint2 _Source, uint4 _Accum) __GPU_ONLY
    {
        uint4 _Tmp;
        __dp_d3d_msad4(reinterpret_cast<uint*>(&_Tmp), _Reference, _Source.x, _Source.y, _Accum.x, _Accum.y, _Accum.z, _Accum.w);
        return _Tmp;
    }
} // namespace direct3d

} //namespace graphics
} //namespace Concurrency

#pragma warning( pop )
                                                                                                                                                     // ios standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _IOS_
#define _IOS_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <xlocnum>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <class _Elem, class _Traits>
class basic_ios : public ios_base { // base class for basic_istream/basic_ostream
public:
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Mysb       = basic_streambuf<_Elem, _Traits>;
    using _Ctype      = ctype<_Elem>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit __CLR_OR_THIS_CALL basic_ios(_Mysb* _Strbuf) {
        init(_Strbuf);
    }

    __CLR_OR_THIS_CALL ~basic_ios() noexcept override {}

    void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {
        // set state, possibly reraise exception
        ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);
    }

#if _HAS_OLD_IOSTREAMS_MEMBERS
    void __CLR_OR_THIS_CALL clear(io_state _State) { // set state to _State
        clear(static_cast<iostate>(_State));
    }
#endif // _HAS_OLD_IOSTREAMS_MEMBERS

    void __CLR_OR_THIS_CALL setstate(
        iostate _State, bool _Reraise = false) { // merge _State into state, possibly reraise exception
        clear(rdstate() | _State, _Reraise);
    }

#if _HAS_OLD_IOSTREAMS_MEMBERS
    void __CLR_OR_THIS_CALL setstate(io_state _State) { // merge _State into state
        setstate(static_cast<iostate>(_State));
    }
#endif // _HAS_OLD_IOSTREAMS_MEMBERS

    basic_ios& __CLR_OR_THIS_CALL copyfmt(const basic_ios& _Right) { // copy format parameters
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }

    _Myos* __CLR_OR_THIS_CALL tie() const {
        return _Tiestr;
    }

    _Myos* __CLR_OR_THIS_CALL tie(_Myos* _Newtie) { // set tie pointer
        _Myos* _Oldtie = _Tiestr;
        _Tiestr        = _Newtie;
        return _Oldtie;
    }

    _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const {
        return _Mystrbuf;
    }

    _Mysb* __CLR_OR_THIS_CALL rdbuf(_Mysb* _Strbuf) { // set stream buffer pointer
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        clear();
        return _Oldstrbuf;
    }

    locale __CLR_OR_THIS_CALL imbue(const locale& _Loc) { // set locale to argument
        locale _Oldlocale = ios_base::imbue(_Loc);
        const auto _Rdbuf = rdbuf();
        if (_Rdbuf) {
            _Rdbuf->pubimbue(_Loc);
        }

        return _Oldlocale;
    }

    _Elem __CLR_OR_THIS_CALL fill() const {
        return _Fillch;
    }

    _Elem __CLR_OR_THIS_CALL fill(_Elem _Newfill) { // set fill character
        _Elem _Oldfill = _Fillch;
        _Fillch        = _Newfill;
        return _Oldfill;
    }

    char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const { // convert _Ch to byte using imbued locale
        return _STD use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }

    _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale
        return _STD use_facet<_Ctype>(getloc()).widen(_Byte);
    }

    void __CLR_OR_THIS_CALL move(basic_ios& _Right) {
        if (this != _STD addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void __CLR_OR_THIS_CALL move(basic_ios&& _Right) {
        if (this != _STD addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void __CLR_OR_THIS_CALL swap(basic_ios& _Right) noexcept { // swap all but rdbuf() with right
        ios_base::swap(_Right);
        _STD swap(_Fillch, _Right._Fillch);
        _STD swap(_Tiestr, _Right._Tiestr);
    }

    void __CLR_OR_THIS_CALL set_rdbuf(_Mysb* _Strbuf) { // set stream buffer pointer without changing state
        _Mystrbuf = _Strbuf;
    }

protected:
    void __CLR_OR_THIS_CALL init(_Mysb* _Strbuf = nullptr,
        bool _Isstd                             = false) { // initialize with stream buffer pointer
        _Init(); // initialize ios_base
        _Mystrbuf = _Strbuf;
        _Tiestr   = nullptr;
        _Fillch   = widen(' ');

        if (!_Mystrbuf) {
            setstate(badbit);
        }

        if (_Isstd) {
            _Addstd(this); // special handling for standard streams
        }
    }

    __CLR_OR_THIS_CALL basic_ios() {}

private:
    _Mysb* _Mystrbuf; // pointer to stream buffer
    _Myos* _Tiestr; // pointer to tied output stream
    _Elem _Fillch; // the fill character

public:
    __CLR_OR_THIS_CALL basic_ios(const basic_ios&) = delete;
    basic_ios& __CLR_OR_THIS_CALL operator=(const basic_ios&) = delete;
};

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_ios<char, char_traits<char>>;
template class _CRTIMP2_PURE_IMPORT basic_ios<wchar_t, char_traits<wchar_t>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_ios<unsigned short, char_traits<unsigned short>>;
#endif // __FORCE_INSTANCE
#endif // defined(_DLL_CPPLIB)

inline ios_base& __CLRCALL_OR_CDECL boolalpha(ios_base& _Iosbase) { // set boolalpha
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL dec(ios_base& _Iosbase) { // set basefield to dec
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL defaultfloat(ios_base& _Iosbase) { // clear floatfield
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL fixed(ios_base& _Iosbase) { // set floatfield to fixed
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL hex(ios_base& _Iosbase) { // set basefield to hex
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL hexfloat(ios_base& _Iosbase) { // set floatfield to hexfloat
    _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL internal(ios_base& _Iosbase) { // set adjustfield to internal
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL left(ios_base& _Iosbase) { // set adjustfield to left
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL noboolalpha(ios_base& _Iosbase) { // clear boolalpha
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL noshowbase(ios_base& _Iosbase) { // clear showbase
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL noshowpoint(ios_base& _Iosbase) { // clear showpoint
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL noshowpos(ios_base& _Iosbase) { // clear showpos
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL noskipws(ios_base& _Iosbase) { // clear skipws
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL nounitbuf(ios_base& _Iosbase) { // clear unitbuf
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL nouppercase(ios_base& _Iosbase) { // clear uppercase
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL oct(ios_base& _Iosbase) { // set oct in basefield
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL right(ios_base& _Iosbase) { // set right in adjustfield
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL scientific(ios_base& _Iosbase) { // set scientific in floatfield
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL showbase(ios_base& _Iosbase) { // set showbase
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL showpoint(ios_base& _Iosbase) { // set showpoint
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL showpos(ios_base& _Iosbase) { // set showpos
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL skipws(ios_base& _Iosbase) { // set skipws
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL unitbuf(ios_base& _Iosbase) { // set unitbuf
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}

inline ios_base& __CLRCALL_OR_CDECL uppercase(ios_base& _Iosbase) { // set uppercase
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD hexfloat;
}
#endif // _HAS_TR1_NAMESPACE

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _IOS_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ry to find Boost by stepping backwards through the Boost versions
  # we know about.
  # Build a list of path suffixes for each version.
  set(_boost_PATH_SUFFIXES)
  foreach(_boost_VER ${_boost_TEST_VERSIONS})
    # Add in a path suffix, based on the required version, ideally
    # we could read this from version.hpp, but for that to work we'd
    # need to know the include dir already
    set(_boost_BOOSTIFIED_VERSION)

    # Transform 1.35 => 1_35 and 1.36.0 => 1_36_0
    if(_boost_VER MATCHES "([0-9]+)\\.([0-9]+)\\.([0-9]+)")
        set(_boost_BOOSTIFIED_VERSION
          "${CMAKE_MATCH_1}_${CMAKE_MATCH_2}_${CMAKE_MATCH_3}")
    elseif(_boost_VER MATCHES "([0-9]+)\\.([0-9]+)")
        set(_boost_BOOSTIFIED_VERSION
          "${CMAKE_MATCH_1}_${CMAKE_MATCH_2}")
    endif()

    list(APPEND _boost_PATH_SUFFIXES
      "boost-${_boost_BOOSTIFIED_VERSION}"
      "boost_${_boost_BOOSTIFIED_VERSION}"
      "boost/boost-${_boost_BOOSTIFIED_VERSION}"
      "boost/boost_${_boost_BOOSTIFIED_VERSION}"
      )

  endforeach()

  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_INCLUDE_SEARCH_DIRS")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_PATH_SUFFIXES")

  # Look for a standard boost header file.
  find_path(Boost_INCLUDE_DIR
    NAMES         boost/config.hpp
    HINTS         ${_boost_INCLUDE_SEARCH_DIRS}
    PATH_SUFFIXES ${_boost_PATH_SUFFIXES}
    )
endif()

# ------------------------------------------------------------------------
#  Extract version information from version.hpp
# ------------------------------------------------------------------------

if(Boost_INCLUDE_DIR)
  _Boost_DEBUG_PRINT("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
                     "location of version.hpp: ${Boost_INCLUDE_DIR}/boost/version.hpp")

  # Extract Boost_VERSION_MACRO and Boost_LIB_VERSION from version.hpp
  set(Boost_VERSION_MACRO 0)
  set(Boost_LIB_VERSION "")
  file(STRINGS "${Boost_INCLUDE_DIR}/boost/version.hpp" _boost_VERSION_HPP_CONTENTS REGEX "#define BOOST_(LIB_)?VERSION ")
  if("${_boost_VERSION_HPP_CONTENTS}" MATCHES "#define BOOST_VERSION ([0-9]+)")
    set(Boost_VERSION_MACRO "${CMAKE_MATCH_1}")
  endif()
  if("${_boost_VERSION_HPP_CONTENTS}" MATCHES "#define BOOST_LIB_VERSION \"([0-9_]+)\"")
    set(Boost_LIB_VERSION "${CMAKE_MATCH_1}")
  endif()
  unset(_boost_VERSION_HPP_CONTENTS)

  # Calculate version components
  math(EXPR Boost_VERSION_MAJOR "${Boost_VERSION_MACRO} / 100000")
  math(EXPR Boost_VERSION_MINOR "${Boost_VERSION_MACRO} / 100 % 1000")
  math(EXPR Boost_VERSION_PATCH "${Boost_VERSION_MACRO} % 100")
  set(Boost_VERSION_COUNT 3)

  # Define alias variables for backwards compat.
  set(Boost_MAJOR_VERSION ${Boost_VERSION_MAJOR})
  set(Boost_MINOR_VERSION ${Boost_VERSION_MINOR})
  set(Boost_SUBMINOR_VERSION ${Boost_VERSION_PATCH})

  # Define Boost version in x.y.z format
  set(Boost_VERSION_STRING "${Boost_VERSION_MAJOR}.${Boost_VERSION_MINOR}.${Boost_VERSION_PATCH}")

  # Define final Boost_VERSION
  cmake_policy(GET CMP0093 _Boost_CMP0093
    PARENT_SCOPE # undocumented, do not use outside of CMake
  )
  if("x${_Boost_CMP0093}x" STREQUAL "xNEWx")
    set(Boost_VERSION ${Boost_VERSION_STRING})
  else()
    set(Boost_VERSION ${Boost_VERSION_MACRO})
  endif()
  unset(_Boost_CMP0093)

  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION_STRING")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION_MACRO")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION_MAJOR")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION_MINOR")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION_PATCH")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_VERSION_COUNT")
endif()

# ------------------------------------------------------------------------
#  Prefix initialization
# ------------------------------------------------------------------------

if ( NOT DEFINED Boost_LIB_PREFIX )
  # Boost's static libraries use a "lib" prefix on DLL platforms
  # to distinguish them from the DLL import libraries.
  if (Boost_USE_STATIC_LIBS AND (
      (WIN32 AND NOT CYGWIN)
      OR GHSMULTI
      ))
    set(Boost_LIB_PREFIX "lib")
  else()
    set(Boost_LIB_PREFIX "")
  endif()
endif()

if ( NOT Boost_NAMESPACE )
  set(Boost_NAMESPACE "boost")
endif()

_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_LIB_PREFIX")
_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "Boost_NAMESPACE")

# ------------------------------------------------------------------------
#  Suffix initialization and compiler suffix detection.
# ------------------------------------------------------------------------

set(_Boost_VARS_NAME
  Boost_NAMESPACE
  Boost_COMPILER
  Boost_THREADAPI
  Boost_USE_DEBUG_PYTHON
  Boost_USE_MULTITHREADED
  Boost_USE_STATIC_LIBS
  Boost_USE_STATIC_RUNTIME
  Boost_USE_STLPORT
  Boost_USE_STLPORT_DEPRECATED_NATIVE_IOSTREAMS
  )
_Boost_CHANGE_DETECT(_Boost_CHANGE_LIBNAME ${_Boost_VARS_NAME})

# Setting some more suffixes for the library
if (Boost_COMPILER)
  set(_boost_COMPILER ${Boost_COMPILER})
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
                         "_boost_COMPILER" SOURCE "user-specified via Boost_COMPILER")
else()
  # Attempt to guess the compiler suffix
  # NOTE: this is not perfect yet, if you experience any issues
  # please report them and use the Boost_COMPILER variable
  # to work around the problems.
  _Boost_GUESS_COMPILER_PREFIX(_boost_COMPILER)
endif()

set (_boost_MULTITHREADED "-mt")
if( NOT Boost_USE_MULTITHREADED )
  set (_boost_MULTITHREADED "")
endif()
_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_MULTITHREADED")

#======================
# Systematically build up the Boost ABI tag for the 'tagged' and 'versioned' layouts
# http://boost.org/doc/libs/1_66_0/more/getting_started/windows.html#library-naming
# http://boost.org/doc/libs/1_66_0/boost/config/auto_link.hpp
# http://boost.org/doc/libs/1_66_0/tools/build/src/tools/common.jam
# http://boost.org/doc/libs/1_66_0/boostcpp.jam
set( _boost_RELEASE_ABI_TAG "-")
set( _boost_DEBUG_ABI_TAG   "-")
# Key       Use this library when:
#  s        linking statically to the C++ standard library and
#           compiler runtime support libraries.
if(Boost_USE_STATIC_RUNTIME)
  set( _boost_RELEASE_ABI_TAG "${_boost_RELEASE_ABI_TAG}s")
  set( _boost_DEBUG_ABI_TAG   "${_boost_DEBUG_ABI_TAG}s")
endif()
#  g        using debug versions of the standard and runtime
#           support libraries
if(WIN32 AND Boost_USE_DEBUG_RUNTIME)
  if("x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xMSVC"
          OR "x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xClang"
          OR "x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xIntel"
          OR "x${CMAKE_CXX_COMPILER_ID}" STREQUAL "xIntelLLVM")
    string(APPEND _boost_DEBUG_ABI_TAG "g")
  endif()
endif()
#  y        using special debug build of python
if(Boost_USE_DEBUG_PYTHON)
  string(APPEND _boost_DEBUG_ABI_TAG "y")
endif()
#  d        using a debug version of your code
string(APPEND _boost_DEBUG_ABI_TAG "d")
#  p        using the STLport standard library rather than the
#           default one supplied with your compiler
if(Boost_USE_STLPORT)
  string(APPEND _boost_RELEASE_ABI_TAG "p")
  string(APPEND _boost_DEBUG_ABI_TAG "p")
endif()
#  n        using the STLport deprecated "native iostreams" feature
#           removed from the documentation in 1.43.0 but still present in
#           boost/config/auto_link.hpp
if(Boost_USE_STLPORT_DEPRECATED_NATIVE_IOSTREAMS)
  string(APPEND _boost_RELEASE_ABI_TAG "n")
  string(APPEND _boost_DEBUG_ABI_TAG "n")
endif()

#  -x86     Architecture and address model tag
#           First character is the architecture, then word-size, either 32 or 64
#           Only used in 'versioned' layout, added in Boost 1.66.0
if(DEFINED Boost_ARCHITECTURE)
  set(_boost_ARCHITECTURE_TAG "${Boost_ARCHITECTURE}")
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
                         "_boost_ARCHITECTURE_TAG" SOURCE "user-specified via Boost_ARCHITECTURE")
else()
  set(_boost_ARCHITECTURE_TAG "")
  # {CMAKE_CXX_COMPILER_ARCHITECTURE_ID} is not currently set for all compilers
  if(NOT "x${CMAKE_CXX_COMPILER_ARCHITECTURE_ID}" STREQUAL "x" AND NOT Boost_VERSION_STRING VERSION_LESS 1.66.0)
    string(APPEND _boost_ARCHITECTURE_TAG "-")
    # This needs to be kept in-sync with the section of CMakePlatformId.h.in
    # inside 'defined(_WIN32) && defined(_MSC_VER)'
    if(CMAKE_CXX_COMPILER_ARCHITECTURE_ID STREQUAL "IA64")
      string(APPEND _boost_ARCHITECTURE_TAG "i")
    elseif(CMAKE_CXX_COMPILER_ARCHITECTURE_ID STREQUAL "X86"
              OR CMAKE_CXX_COMPILER_ARCHITECTURE_ID STREQUAL "x64")
      string(APPEND _boost_ARCHITECTURE_TAG "x")
    elseif(CMAKE_CXX_COMPILER_ARCHITECTURE_ID MATCHES "^ARM")
      string(APPEND _boost_ARCHITECTURE_TAG "a")
    elseif(CMAKE_CXX_COMPILER_ARCHITECTURE_ID STREQUAL "MIPS")
      string(APPEND _boost_ARCHITECTURE_TAG "m")
    endif()

    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
      string(APPEND _boost_ARCHITECTURE_TAG "64")
    else()
      string(APPEND _boost_ARCHITECTURE_TAG "32")
    endif()
  endif()
  _Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
                         "_boost_ARCHITECTURE_TAG" SOURCE "detected")
endif()

_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_RELEASE_ABI_TAG")
_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_DEBUG_ABI_TAG")

# ------------------------------------------------------------------------
#  Begin finding boost libraries
# ------------------------------------------------------------------------

set(_Boost_VARS_LIB "")
foreach(c DEBUG RELEASE)
  set(_Boost_VARS_LIB_${c} BOOST_LIBRARYDIR Boost_LIBRARY_DIR_${c})
  list(APPEND _Boost_VARS_LIB ${_Boost_VARS_LIB_${c}})
  _Boost_CHANGE_DETECT(_Boost_CHANGE_LIBDIR_${c} ${_Boost_VARS_DIR} ${_Boost_VARS_LIB_${c}} Boost_INCLUDE_DIR)
  # Clear Boost_LIBRARY_DIR_${c} if it did not change but other input affecting the
  # location did.  We will find a new one based on the new inputs.
  if(_Boost_CHANGE_LIBDIR_${c} AND NOT _Boost_LIBRARY_DIR_${c}_CHANGED)
    unset(Boost_LIBRARY_DIR_${c} CACHE)
  endif()

  # If Boost_LIBRARY_DIR_[RELEASE,DEBUG] is set, prefer its value.
  if(Boost_LIBRARY_DIR_${c})
    set(_boost_LIBRARY_SEARCH_DIRS_${c} ${Boost_LIBRARY_DIR_${c}} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
  else()
    set(_boost_LIBRARY_SEARCH_DIRS_${c} "")
    if(BOOST_LIBRARYDIR)
      list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c} ${BOOST_LIBRARYDIR})
    elseif(_ENV_BOOST_LIBRARYDIR)
      list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c} ${_ENV_BOOST_LIBRARYDIR})
    endif()

    if(BOOST_ROOT)
      list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c} ${BOOST_ROOT}/lib ${BOOST_ROOT}/stage/lib)
      _Boost_UPDATE_WINDOWS_LIBRARY_SEARCH_DIRS_WITH_PREBUILT_PATHS(_boost_LIBRARY_SEARCH_DIRS_${c} "${BOOST_ROOT}")
    elseif(_ENV_BOOST_ROOT)
      list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c} ${_ENV_BOOST_ROOT}/lib ${_ENV_BOOST_ROOT}/stage/lib)
      _Boost_UPDATE_WINDOWS_LIBRARY_SEARCH_DIRS_WITH_PREBUILT_PATHS(_boost_LIBRARY_SEARCH_DIRS_${c} "${_ENV_BOOST_ROOT}")
    endif()

    list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c}
      ${Boost_INCLUDE_DIR}/lib
      ${Boost_INCLUDE_DIR}/../lib
      ${Boost_INCLUDE_DIR}/stage/lib
      )
    _Boost_UPDATE_WINDOWS_LIBRARY_SEARCH_DIRS_WITH_PREBUILT_PATHS(_boost_LIBRARY_SEARCH_DIRS_${c} "${Boost_INCLUDE_DIR}/..")
    _Boost_UPDATE_WINDOWS_LIBRARY_SEARCH_DIRS_WITH_PREBUILT_PATHS(_boost_LIBRARY_SEARCH_DIRS_${c} "${Boost_INCLUDE_DIR}")
    if( Boost_NO_SYSTEM_PATHS )
      list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c} NO_CMAKE_SYSTEM_PATH NO_SYSTEM_ENVIRONMENT_PATH)
    else()
      foreach(ver ${_boost_TEST_VERSIONS})
        string(REPLACE "." "_" ver "${ver}")
        _Boost_UPDATE_WINDOWS_LIBRARY_SEARCH_DIRS_WITH_PREBUILT_PATHS(_boost_LIBRARY_SEARCH_DIRS_${c} "C:/local/boost_${ver}")
      endforeach()
      _Boost_UPDATE_WINDOWS_LIBRARY_SEARCH_DIRS_WITH_PREBUILT_PATHS(_boost_LIBRARY_SEARCH_DIRS_${c} "C:/boost")
      list(APPEND _boost_LIBRARY_SEARCH_DIRS_${c} PATHS
        C:/boost/lib
        C:/boost
        /sw/local/lib
        )
    endif()
  endif()
endforeach()

_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_LIBRARY_SEARCH_DIRS_RELEASE")
_Boost_DEBUG_PRINT_VAR("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}" "_boost_LIBRARY_SEARCH_DIRS_DEBUG")

# Support preference of static libs by adjusting CMAKE_FIND_LIBRARY_SUFFIXES
if( Boost_USE_STATIC_LIBS )
  set( _boost_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
  if(WIN32)
    list(INSERT CMAKE_FIND_LIBRARY_SUFFIXES 0 .lib .a)
  else()
    set(CMAKE_FIND_LIBRARY_SUFFIXES .a)
  endif()
endif()

# We want to use the tag inline below without risking double dashes
if(_boost_RELEASE_ABI_TAG)
  if(${_boost_RELEASE_ABI_TAG} STREQUAL "-")
    set(_boost_RELEASE_ABI_TAG "")
  endif()
endif()
if(_boost_DEBUG_ABI_TAG)
  if(${_boost_DEBUG_ABI_TAG} STREQUAL "-")
    set(_boost_DEBUG_ABI_TAG "")
  endif()
endif()

# The previous behavior of FindBoost when Boost_USE_STATIC_LIBS was enabled
# on WIN32 was to:
#  1. Search for static libs compiled against a SHARED C++ standard runtime library (use if found)
#  2. Search for static libs compiled against a STATIC C++ standard runtime library (use if found)
# We maintain this behavior since changing it could break people's builds.
# To disable the ambiguous behavior, the user need only
# set Boost_USE_STATIC_RUNTIME either ON or OFF.
set(_boost_STATIC_RUNTIME_WORKAROUND false)
if(WIN32 AND Boost_USE_STATIC_LIBS)
  if(NOT DEFINED Boost_USE_STATIC_RUNTIME)
    set(_boost_STATIC_RUNTIME_WORKAROUND TRUE)
  endif()
endif()

# On versions < 1.35, remove the System library from the considered list
# since it wasn't added until 1.35.
if(Boost_VERSION_STRING AND Boost_FIND_COMPONENTS)
  if(Boost_VERSION_STRING VERSION_LESS 1.35.0)
    list(REMOVE_ITEM Boost_FIND_COMPONENTS system)
  endif()
endif()

# Additional components may be required via component dependencies.
# Add any missing components to the list.
_Boost_MISSING_DEPENDENCIES(Boost_FIND_COMPONENTS _Boost_EXTRA_FIND_COMPONENTS)

# If thread is required, get the thread libs as a dependency
if("thread" IN_LIST Boost_FIND_COMPONENTS)
  if(Boost_FIND_QUIETLY)
    set(_Boost_find_quiet QUIET)
  else()
    set(_Boost_find_quiet "")
  endif()
  find_package(Threads ${_Boost_find_quiet})
  unset(_Boost_find_quiet)
endif()

# If the user changed any of our control inputs flush previous results.
if(_Boost_CHANGE_LIBDIR_DEBUG OR _Boost_CHANGE_LIBDIR_RELEASE OR _Boost_CHANGE_LIBNAME)
  foreach(COMPONENT ${_Boost_COMPONENTS_SEARCHED})
    string(TOUPPER ${COMPONENT} UPPERCOMPONENT)
    foreach(c DEBUG RELEASE)
      set(_var Boost_${UPPERCOMPONENT}_LIBRARY_${c})
      unset(${_var} CACHE)
      set(${_var} "${_var}-NOTFOUND")
    endforeach()
  endforeach()
  set(_Boost_COMPONENTS_SEARCHED "")
endif()

foreach(COMPONENT ${Boost_FIND_COMPONENTS})
  string(TOUPPER ${COMPONENT} UPPERCOMPONENT)

  set( _boost_docstring_release "Boost ${COMPONENT} library (release)")
  set( _boost_docstring_debug   "Boost ${COMPONENT} library (debug)")

  # Compute component-specific hints.
  set(_Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT "")
  if(${COMPONENT} STREQUAL "mpi" OR ${COMPONENT} STREQUAL "mpi_python" OR
     ${COMPONENT} STREQUAL "graph_parallel")
    foreach(lib ${MPI_CXX_LIBRARIES} ${MPI_C_LIBRARIES})
      if(IS_ABSOLUTE "${lib}")
        get_filename_component(libdir "${lib}" PATH)
        string(REPLACE "\\" "/" libdir "${libdir}")
        list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT ${libdir})
      endif()
    endforeach()
  endif()

  # Handle Python version suffixes
  unset(COMPONENT_PYTHON_VERSION_MAJOR)
  unset(COMPONENT_PYTHON_VERSION_MINOR)
  if(${COMPONENT} MATCHES "^(python|mpi_python|numpy)([0-9])\$")
    set(COMPONENT_UNVERSIONED "${CMAKE_MATCH_1}")
    set(COMPONENT_PYTHON_VERSION_MAJOR "${CMAKE_MATCH_2}")
  elseif(${COMPONENT} MATCHES "^(python|mpi_python|numpy)([0-9])\\.?([0-9]+)\$")
    set(COMPONENT_UNVERSIONED "${CMAKE_MATCH_1}")
    set(COMPONENT_PYTHON_VERSION_MAJOR "${CMAKE_MATCH_2}")
    set(COMPONENT_PYTHON_VERSION_MINOR "${CMAKE_MATCH_3}")
  endif()

  unset(_Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME)
  if (COMPONENT_PYTHON_VERSION_MINOR)
    # Boost >= 1.67
    list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME "${COMPONENT_UNVERSIONED}${COMPONENT_PYTHON_VERSION_MAJOR}${COMPONENT_PYTHON_VERSION_MINOR}")
    # Debian/Ubuntu (Some versions omit the 2 and/or 3 from the suffix)
    list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME "${COMPONENT_UNVERSIONED}${COMPONENT_PYTHON_VERSION_MAJOR}-py${COMPONENT_PYTHON_VERSION_MAJOR}${COMPONENT_PYTHON_VERSION_MINOR}")
    list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME "${COMPONENT_UNVERSIONED}-py${COMPONENT_PYTHON_VERSION_MAJOR}${COMPONENT_PYTHON_VERSION_MINOR}")
    # Gentoo
    list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME "${COMPONENT_UNVERSIONED}-${COMPONENT_PYTHON_VERSION_MAJOR}.${COMPONENT_PYTHON_VERSION_MINOR}")
    # RPMs
    list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME "${COMPONENT_UNVERSIONED}-${COMPONENT_PYTHON_VERSION_MAJOR}${COMPONENT_PYTHON_VERSION_MINOR}")
  endif()
  if (COMPONENT_PYTHON_VERSION_MAJOR AND NOT COMPONENT_PYTHON_VERSION_MINOR)
    # Boost < 1.67
    list(APPEND _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME "${COMPONENT_UNVERSIONED}${COMPONENT_PYTHON_VERSION_MAJOR}")
  endif()

  # Consolidate and report component-specific hints.
  if(_Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME)
    list(REMOVE_DUPLICATES _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME)
    _Boost_DEBUG_PRINT("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
      "Component-specific library search names for ${COMPONENT_NAME}: ${_Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME}")
  endif()
  if(_Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT)
    list(REMOVE_DUPLICATES _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT)
    _Boost_DEBUG_PRINT("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
      "Component-specific library search paths for ${COMPONENT}: ${_Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT}")
  endif()

  #
  # Find headers
  #
  _Boost_COMPONENT_HEADERS("${COMPONENT}" Boost_${UPPERCOMPONENT}_HEADER_NAME)
  # Look for a standard boost header file.
  if(Boost_${UPPERCOMPONENT}_HEADER_NAME)
    if(EXISTS "${Boost_INCLUDE_DIR}/${Boost_${UPPERCOMPONENT}_HEADER_NAME}")
      set(Boost_${UPPERCOMPONENT}_HEADER ON)
    else()
      set(Boost_${UPPERCOMPONENT}_HEADER OFF)
    endif()
  else()
    set(Boost_${UPPERCOMPONENT}_HEADER ON)
    message(WARNING "No header defined for ${COMPONENT}; skipping header check "
                    "(note: header-only libraries have no designated component)")
  endif()

  #
  # Find RELEASE libraries
  #
  unset(_boost_RELEASE_NAMES)
  foreach(component IN LISTS _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME COMPONENT)
    foreach(compiler IN LISTS _boost_COMPILER)
      list(APPEND _boost_RELEASE_NAMES
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_RELEASE_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_RELEASE_ABI_TAG}${_boost_ARCHITECTURE_TAG}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_RELEASE_ABI_TAG} )
    endforeach()
    list(APPEND _boost_RELEASE_NAMES
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_RELEASE_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_RELEASE_ABI_TAG}${_boost_ARCHITECTURE_TAG}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_RELEASE_ABI_TAG}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component} )
    if(_boost_STATIC_RUNTIME_WORKAROUND)
      set(_boost_RELEASE_STATIC_ABI_TAG "-s${_boost_RELEASE_ABI_TAG}")
      foreach(compiler IN LISTS _boost_COMPILER)
        list(APPEND _boost_RELEASE_NAMES
          ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_RELEASE_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
          ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_RELEASE_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}
          ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_RELEASE_STATIC_ABI_TAG} )
      endforeach()
      list(APPEND _boost_RELEASE_NAMES
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_RELEASE_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_RELEASE_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_RELEASE_STATIC_ABI_TAG} )
    endif()
  endforeach()
  if(Boost_THREADAPI AND ${COMPONENT} STREQUAL "thread")
    _Boost_PREPEND_LIST_WITH_THREADAPI(_boost_RELEASE_NAMES ${_boost_RELEASE_NAMES})
  endif()
  _Boost_DEBUG_PRINT("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
                     "Searching for ${UPPERCOMPONENT}_LIBRARY_RELEASE: ${_boost_RELEASE_NAMES}")

  # if Boost_LIBRARY_DIR_RELEASE is not defined,
  # but Boost_LIBRARY_DIR_DEBUG is, look there first for RELEASE libs
  if(NOT Boost_LIBRARY_DIR_RELEASE AND Boost_LIBRARY_DIR_DEBUG)
    list(INSERT _boost_LIBRARY_SEARCH_DIRS_RELEASE 0 ${Boost_LIBRARY_DIR_DEBUG})
  endif()

  # Avoid passing backslashes to _Boost_FIND_LIBRARY due to macro re-parsing.
  string(REPLACE "\\" "/" _boost_LIBRARY_SEARCH_DIRS_tmp "${_boost_LIBRARY_SEARCH_DIRS_RELEASE}")

  if(Boost_USE_RELEASE_LIBS)
    _Boost_FIND_LIBRARY(Boost_${UPPERCOMPONENT}_LIBRARY_RELEASE RELEASE
      NAMES ${_boost_RELEASE_NAMES}
      HINTS ${_boost_LIBRARY_SEARCH_DIRS_tmp}
      NAMES_PER_DIR
      DOC "${_boost_docstring_release}"
      )
  endif()

  #
  # Find DEBUG libraries
  #
  unset(_boost_DEBUG_NAMES)
  foreach(component IN LISTS _Boost_FIND_LIBRARY_HINTS_FOR_COMPONENT_NAME COMPONENT)
    foreach(compiler IN LISTS _boost_COMPILER)
      list(APPEND _boost_DEBUG_NAMES
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_DEBUG_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_DEBUG_ABI_TAG}${_boost_ARCHITECTURE_TAG}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_DEBUG_ABI_TAG} )
    endforeach()
    list(APPEND _boost_DEBUG_NAMES
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_DEBUG_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_DEBUG_ABI_TAG}${_boost_ARCHITECTURE_TAG}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_DEBUG_ABI_TAG}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}
      ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component} )
    if(_boost_STATIC_RUNTIME_WORKAROUND)
      set(_boost_DEBUG_STATIC_ABI_TAG "-s${_boost_DEBUG_ABI_TAG}")
      foreach(compiler IN LISTS _boost_COMPILER)
        list(APPEND _boost_DEBUG_NAMES
          ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_DEBUG_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
          ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_DEBUG_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}
          ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${compiler}${_boost_MULTITHREADED}${_boost_DEBUG_STATIC_ABI_TAG} )
      endforeach()
      list(APPEND _boost_DEBUG_NAMES
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_DEBUG_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}-${Boost_LIB_VERSION}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_DEBUG_STATIC_ABI_TAG}${_boost_ARCHITECTURE_TAG}
        ${Boost_LIB_PREFIX}${Boost_NAMESPACE}_${component}${_boost_MULTITHREADED}${_boost_DEBUG_STATIC_ABI_TAG} )
    endif()
  endforeach()
  if(Boost_THREADAPI AND ${COMPONENT} STREQUAL "thread")
     _Boost_PREPEND_LIST_WITH_THREADAPI(_boost_DEBUG_NAMES ${_boost_DEBUG_NAMES})
  endif()
  _Boost_DEBUG_PRINT("${CMAKE_CURRENT_LIST_FILE}" "${CMAKE_CURRENT_LIST_LINE}"
                     "Searching for ${UPPERCOMPONENT}_LIBRARY_DEBUG: ${_boost_DEBUG_NAMES}")

  # if Boost_LIBRARY_DIR_DEBUG is not defined,
  # but Boost_LIBRARY_DIR_RELEASE is, look there first for DEBUG libs
  if(NOT Boost_LIBRARY_DIR_DEBUG AND Boost_LIBRARY_DIR_RELEASE)
    list(INSERT _boost_LIBRARY_SEARCH_DIRS_DEBUG 0 ${Boost_LIBRARY_DIR_RELEASE})
  endif()

  # Avoid passing backslashes to _Boost_FIND_LIBRARY due to macro re-parsing.
  string(REPLACE "\\" "/" _boost_LIBRARY_SEARCH_DIRS_tmp "${_boost_LIBRARY_SEARCH_DIRS_DEBUG}")

  if(Boost_USE_DEBUG_LIBS)
    _Boost_FIND_LIBRARY(Boost_${UPPERCOMPONENT}_LIBRARY_DEBUG DEBUG
      NAMES ${_boost_DEBUG_NAMES}
      HINTS ${_boost_LIBRARY_SEARCH_DIRS_tmp}
      NAMES_PER_DIR
      DOC "${_boost_docstring_debug}"
      )
  endif ()

  if(Boost_REALPATH)
    _Boost_SWAP_WITH_REALPATH(Boost_${UPPERCOMPONENT}_LIBRARY_RELEASE "${_boost_docstring_release}")
    _Boost_SWAP_WITH_REALPATH(Boost_${UPPERCOMPONENT}_LIBRARY_DEBUG   "${_boost_docstring_debug}"  )
  endif()

  _Boost_ADJUST_LIB_VARS(${UPPERCOMPONENT})

  # Check if component requires some compiler features
  _Boost_COMPILER_FEATURES(${COMPONENT} _Boost_${UPPERCOMPONENT}_COMPILER_FEATURES)

endforeach()

# Restore the original find library ordering
if( Boost_USE_STATIC_LIBS )
  set(CMAKE_FIND_LIBRARY_SUFFIXES ${_boost_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES})
endif()

# ------------------------------------------------------------------------
#  End finding boost libraries
# ------------------------------------------------------------------------

set(Boost_INCLUDE_DIRS ${Boost_INCLUDE_DIR})
set(Boost_LIBRARY_DIRS)
if(Boost_LIBRARY_DIR_RELEASE)
  list(APPEND Boost_LIBRARY_DIRS ${Boost_LIBRARY_DIR_RELEASE})
endif()
if(Boost_LIBRARY_DIR_DEBUG)
  list(APPEND Boost_LIBRARY_DIRS ${Boost_LIBRARY_DIR_DEBUG})
endif()
if(Boost_LIBRARY_DIRS)
  list(REMOVE_DUPLICATES Boost_LIBRARY_DIRS)
endif()

# ------------------------------------------------------------------------
#  Call FPHSA helper, see https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html
# ------------------------------------------------------------------------

# Define aliases as needed by the component handler in the FPHSA helper below
foreach(_comp IN LISTS Boost_FIND_COMPONENTS)
  string(TOUPPER ${_comp} _uppercomp)
  if(DEFINED Boost_${_uppercomp}_FOUND)
    set(Boost_${_comp}_FOUND ${Boost_${_uppercomp}_FOUND})
  endif()
endforeach()

find_package_handle_standard_args(Boost
  REQUIRED_VARS Boost_INCLUDE_DIR
  VERSION_VAR Boost_VERSION_STRING
  HANDLE_COMPONENTS)

if(Boost_FOUND)
  if( NOT Boost_LIBRARY_DIRS )
    # Compatibility Code for backwards compatibility with CMake
    # 2.4's FindBoost module.

    # Look for the boost library path.
    # Note that the user may not have installed any libraries
    # so it is quite possible the Boost_LIBRARY_DIRS may not exist.
    set(_boost_LIB_DIR ${Boost_INCLUDE_DIR})

    if("${_boost_LIB_DIR}" MATCHES "boost-[0-9]+")
      get_filename_component(_boost_LIB_DIR ${_boost_LIB_DIR} PATH)
    endif()

    if("${_boost_LIB_DIR}" MATCHES "/include$")
      # Strip off the trailing "/include" in the path.
      get_filename_component(_boost_LIB_DIR ${_boost_LIB_DIR} PATH)
    endif()

    if(EXISTS "${_boost_LIB_DIR}/lib")
      string(APPEND _boost_LIB_DIR /lib)
    elseif(EXISTS "${_boost_LIB_DIR}/stage/lib")
      string(APPEND _boost_LIB_DIR "/stage/lib")
    else()
      set(_boost_LIB_DIR "")
    endif()

    if(_boost_LIB_DIR AND EXISTS "${_boost_LIB_DIR}")
      set(Boost_LIBRARY_DIRS ${_boost_LIB_DIR})
    endif()

  endif()
else()
  # Boost headers were not found so no components were found.
  foreach(COMPONENT ${Boost_FIND_COMPONENTS})
    string(TOUPPER ${COMPONENT} UPPERCOMPONENT)
    set(Boost_${UPPERCOMPONENT}_FOUND 0)
  endforeach()
endif()

# ------------------------------------------------------------------------
#  Add imported targets
# ------------------------------------------------------------------------

if(Boost_FOUND)
  # The builtin CMake package in Boost 1.70+ introduces a new name
  # for the header-only lib, let's provide the same UI in module mode
  if(NOT TARGET Boost::headers)
    add_library(Boost::headers INTERFACE IMPORTED)
    if(Boost_INCLUDE_DIRS)
      set_target_properties(Boost::headers PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${Boost_INCLUDE_DIRS}")
    endif()
  endif()

  # Define the old target name for header-only libraries for backwards
  # compat.
  if(NOT TARGET Boost::boost)
    add_library(Boost::boost INTERFACE IMPORTED)
    set_target_properties(Boost::boost
      PROPERTIES INTERFACE_LINK_LIBRARIES Boost::headers)
  endif()

  foreach(COMPONENT ${Boost_FIND_COMPONENTS})
    if(_Boost_IMPORTED_TARGETS AND NOT TARGET Boost::${COMPONENT})
      string(TOUPPER ${COMPONENT} UPPERCOMPONENT)
      if(Boost_${UPPERCOMPONENT}_FOUND)
        if(Boost_USE_STATIC_LIBS)
          add_library(Boost::${COMPONENT} STATIC IMPORTED)
        else()
          # Even if Boost_USE_STATIC_LIBS is OFF, we might have static
          # libraries as a result.
          add_library(Boost::${COMPONENT} UNKNOWN IMPORTED)
        endif()
        if(Boost_INCLUDE_DIRS)
          set_target_properties(Boost::${COMPONENT} PROPERTIES
            INTERFACE_INCLUDE_DIRECTORIES "${Boost_INCLUDE_DIRS}")
        endif()
        if(EXISTS "${Boost_${UPPERCOMPONENT}_LIBRARY}")
          set_target_properties(Boost::${COMPONENT} PROPERTIES
            IMPORTED_LINK_INTERFACE_LANGUAGES "CXX"
            IMPORTED_LOCATION "${Boost_${UPPERCOMPONENT}_LIBRARY}")
        endif()
        if(EXISTS "${Boost_${UPPERCOMPONENT}_LIBRARY_RELEASE}")
          set_property(TARGET Boost::${COMPONENT} APPEND PROPERTY
            IMPORTED_CONFIGURATIONS RELEASE)
          set_target_properties(Boost::${COMPONENT} PROPERTIES
            IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "CXX"
            IMPORTED_LOCATION_RELEASE "${Boost_${UPPERCOMPONENT}_LIBRARY_RELEASE}")
        endif()
        if(EXISTS "${Boost_${UPPERCOMPONENT}_LIBRARY_DEBUG}")
          set_property(TARGET Boost::${COMPONENT} APPEND PROPERTY
            IMPORTED_CONFIGURATIONS DEBUG)
          set_target_properties(Boost::${COMPONENT} PROPERTIES
            IMPORTED_LINK_INTERFACE_LANGUAGES_DEBUG "CXX"
            IMPORTED_LOCATION_DEBUG "${Boost_${UPPERCOMPONENT}_LIBRARY_DEBUG}")
        endif()
        if(_Boost_${UPPERCOMPONENT}_DEPENDENCIES)
          unset(_Boost_${UPPERCOMPONENT}_TARGET_DEPENDENCIES)
          foreach(dep ${_Boost_${UPPERCOMPONENT}_DEPENDENCIES})
            list(APPEND _Boost_${UPPERCOMPONENT}_TARGET_DEPENDENCIES Boost::${dep})
          endforeach()
          if(COMPONENT STREQUAL "thread")
            list(APPEND _Boost_${UPPERCOMPONENT}_TARGET_DEPENDENCIES Threads::Threads)
          endif()
          set_target_properties(Boost::${COMPONENT} PROPERTIES
            INTERFACE_LINK_LIBRARIES "${_Boost_${UPPERCOMPONENT}_TARGET_DEPENDENCIES}")
        endif()
        if(_Boost_${UPPERCOMPONENT}_COMPILER_FEATURES)
          set_target_properties(Boost::${COMPONENT} PROPERTIES
            INTERFACE_COMPILE_FEATURES "${_Boost_${UPPERCOMPONENT}_COMPILER_FEATURES}")
        endif()
      endif()
    endif()
  endforeach()

  # Supply Boost_LIB_DIAGNOSTIC_DEFINITIONS as a convenience target. It
  # will only contain any interface definitions on WIN32, but is created
  # on all platforms to keep end user code free from platform dependent
  # code.  Also provide convenience targets to disable autolinking and
  # enable dynamic linking.
  if(NOT TARGET Boost::diagnostic_definitions)
    add_library(Boost::diagnostic_definitions INTERFACE IMPORTED)
    add_library(Boost::disable_autolinking INTERFACE IMPORTED)
    add_library(Boost::dynamic_linking INTERFACE IMPORTED)
    set_target_properties(Boost::dynamic_linking PROPERTIES
      INTERFACE_COMPILE_DEFINITIONS "BOOST_ALL_DYN_LINK")
  endif()
  if(WIN32)
    # In windows, automatic linking is performed, so you do not have
    # to specify the libraries.  If you are linking to a dynamic
    # runtime, then you can choose to link to either a static or a
    # dynamic Boost library, the default is to do a static link.  You
    # can alter this for a specific library "whatever" by defining
    # BOOST_WHATEVER_DYN_LINK to force Boost library "whatever" to be
    # linked dynamically.  Alternatively you can force all Boost
    # libraries to dynamic link by defining BOOST_ALL_DYN_LINK.

    # This feature can be disabled for Boost library "whatever" by
    # defining BOOST_WHATEVER_NO_LIB, or for all of Boost by defining
    # BOOST_ALL_NO_LIB.

    # If you want to observe which libraries are being linked against
    # then defining BOOST_LIB_DIAGNOSTIC will cause the auto-linking
    # code to emit a #pragma message each time a library is selected
    # for linking.
    set(Boost_LIB_DIAGNOSTIC_DEFINITIONS "-DBOOST_LIB_DIAGNOSTIC")
    set_target_properties(Boost::diagnostic_definitions PROPERTIES
      INTERFACE_COMPILE_DEFINITIONS "BOOST_LIB_DIAGNOSTIC")
    set_target_properties(Boost::disable_autolinking PROPERTIES
      INTERFACE_COMPILE_DEFINITIONS "BOOST_ALL_NO_LIB")
  endif()
endif()

# ------------------------------------------------------------------------
#  Finalize
# ------------------------------------------------------------------------

# Report Boost_LIBRARIES
set(Boost_LIBRARIES "")
foreach(_comp IN LISTS Boost_FIND_COMPONENTS)
  string(TOUPPER ${_comp} _uppercomp)
  if(Boost_${_uppercomp}_FOUND)
    list(APPEND Boost_LIBRARIES ${Boost_${_uppercomp}_LIBRARY})
    if(_comp STREQUAL "thread")
      list(APPEND Boost_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})
    endif()
  endif()
endforeach()

# Configure display of cache entries in GUI.
foreach(v BOOSTROOT BOOST_ROOT ${_Boost_VARS_INC} ${_Boost_VARS_LIB})
  get_property(_type CACHE ${v} PROPERTY TYPE)
  if(_type)
    set_property(CACHE ${v} PROPERTY ADVANCED 1)
    if("x${_type}" STREQUAL "xUNINITIALIZED")
      if("x${v}" STREQUAL "xBoost_ADDITIONAL_VERSIONS")
        set_property(CACHE ${v} PROPERTY TYPE STRING)
      else()
        set_property(CACHE ${v} PROPERTY TYPE PATH)
      endif()
    endif()
  endif()
endforeach()

# Record last used values of input variables so we can
# detect on the next run if the user changed them.
foreach(v
    ${_Boost_VARS_INC} ${_Boost_VARS_LIB}
    ${_Boost_VARS_DIR} ${_Boost_VARS_NAME}
    )
  if(DEFINED ${v})
    set(_${v}_LAST "${${v}}" CACHE INTERNAL "Last used ${v} value.")
  else()
    unset(_${v}_LAST CACHE)
  endif()
endforeach()

# Maintain a persistent list of components requested anywhere since
# the last flush.
set(_Boost_COMPONENTS_SEARCHED "${_Boost_COMPONENTS_SEARCHED}")
list(APPEND _Boost_COMPONENTS_SEARCHED ${Boost_FIND_COMPONENTS})
list(REMOVE_DUPLICATES _Boost_COMPONENTS_SEARCHED)
list(SORT _Boost_COMPONENTS_SEARCHED)
set(_Boost_COMPONENTS_SEARCHED "${_Boost_COMPONENTS_SEARCHED}"
  CACHE INTERNAL "Components requested for this build tree.")

# Restore project's policies
cmake_policy(POP)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      MZ                @                                       	!L!This program cannot be run in DOS mode.
$       PE  L b         " 0  b                                                +  `                             O                 l  '        t                                                               H           .text   a       b                    `.rsrc            d              @  @.reloc            j              @  B                      H     l-  L  	       ,z    ~                                     0 ~     (   
E      
         + r  p
+#r	  p
+r  p
+r  p
+r%  ps!  
z(  rc  p("  
(  ~#  
($  
,(=  (%  
s!  
z*  0 X     ~  -/r}  p(&  
  ('  
o(  
(  t      ('  
o(  

~  o  t  *~()  
o*  
s+  
o,  
(-  
(.  
*&(/  
*:(  }  *   0 2     
T+{  o0  
3*KXRKXTK7*f{  {p  o1  
}q  *0 2      !      {  o2  
}q  }t  !  *.r  ps3  
z.r  ps3  
z.r ps3  
z.r' ps3  
z.rQ ps3  
z.r ps3  
z.r ps3  
z.r ps3  
z.r ps3  
z.r- ps3  
z(4  
*~  *&s-  *.s    * 0 :          ~#  
~#  
(t  o5  
,	   (v  -   ~#  
(u  o5  
,   ~6  
(w  ~#  
($  
,   ,o7  
,o7  
(  +j/*(9  
{   MZ  3/{  1{  (  +Xj/*(9  
{  X+%{   PE  3(  +j/*(9  
+*{&   PE  .*}-  (:  
}.  *	*     Q 6        s 
    b{-  (x  ,	  **   0 8         (!  ,o;  
, ("  -(A  o<  
*   
      0 -     s{  
}  }  {  |  s=  
(#  *   0 +     s}  
s>  
}  ~  s?  
($  {  * 0 5   	  s  
}  }  }    s?  
($  {  *   0 >   
  ~#  
($  
,*
+X
(@  
-E  i(A  
(B  
oC  
*v{.  {-  ~#  
(z  ('  *0 3     s  
}  }  {    s=  
(#  {  *{/  * 0      (  }7  
&
 *         +  0      (4  
}3  }4  (0  
-{4  (@  (%  
oD  
*(,  -{4  (>  o<  
*{4  (?  (%  
oE  
(F  
}5  {7  {5  s  oL  {7  |6  oM  *F{5  %-&*(G  
* 0 ?     {7  -  *(3  
-  *(1  2  sH  
(  +(  +* 0 /    s>  

{4  ()  ,
(K  
,*rW prW p(L  
oM  
r[ p(N  
(K  
,*rW prW p(L  
oM  
(O  
,(K  
,*rW prW p(L  
oM  
re p(P  
(Q  
-ro p(L  
-+P  %;(R  
,F	+6(S  
(K  
,*rW prW p(L  
oM  
Xi2{4  (9  rs p(T  
(%  
oE  
* 0 t     sU  

oQ  +HoV  
t  s+  %o_  }/  %oa  }0  %ob  }1  %od  m}2  oW  
oX  
-u  	,	o7  
*    Ta     0      {0  {1  {2  (4  
oO  0({4  (<  (%  
oD  
{3  ry psH  *oN  +,oV  
t  -{/  	oU  o\  	oV  sH  oX  
-u  ,o7  
*      S 8     0 >     
{6  oX   of  #&{4  (:  oD  
{4  (B  oD  
 *        #-  0      {6   oZ  *~8  -r{ p  ('  
oY  
sZ  
8  ~8  *~9  *9  *V(6  r p~9  o[  
*V(6  r p~9  o[  
*V(6  r p~9  o[  
*V(6  rK p~9  o[  
*V(6  rk p~9  o[  
*V(6  r p~9  o[  
*V(6  r p~9  o[  
*V(6  r p~9  o[  
*V(6  r p~9  o[  
*V(6  r p~9  o[  
*{<  *{=  *{>  *{?  *{@  *   0 g       (4  
}<  }=  }>  (C  ~:  o\  
~;  X}@  (G  ~;  2(C  (G  ~;  Yo]  
+}?  *(C  *jrs p:  ~:  o^  
;  *  0 X     
{-  (y  32{  (;  o<  
*{  {$  ((  o_  

  X,{!  -*:{  o`  
* 0 Z     {  oa  

+) (b  
{  -{  (c  
+}   (d  
-   o7  
{  *      6B     0 l     
{-   (y  3{  (;  o<  
*{
  69{.  {-  {  ~#  
(z  (9  
|,  se  
('  }  *BSJB         v4.0.30319     l     #~  X  |  #Strings    9    #US =     #GUID   =    #Blob         W	   3      P   +               e   :   s                           
         	            
              M M     U ( 	     A. }
.  
m . .  Q  
]  <
 ?	.   b
M
  8. l. &   X  \M M H       1        
T  
 
 m u< 	m (m q. E R
. .   } W  M   =.  Y. = 0  D m V            T        Y      m     }Y     Y     4       =             V  !    !     !  - & !  m ) !   - !  Y / !    Y / *   >Y 3 ,    tY 8 5   Y : C   O  A K     A N     A Q     A T     A W     A [     A ]   [  A g   <  A i    A t 	  n t 	  p t 	  q t 	  r t 
 X   } t 
 o   ~ t 
     t 
     t     Y  t     Y  {     Y  }  +   Y    @   Y          Q ! 1             !  ( 3 1             R  F    N *	 3 > *	   3 aT  3T   w  ! ! ! O!  ^  d	1 1 ! Z! !  ! 6! rlVVuVVtV<VV#VV+VaV V>VVVVVIVV6VVbVVV	VVVV:VV&V_V	V	VVVVVVVV	VVV    j         }     VVV]VzVjVVH  	      lVVHVYVVVP            @ @!     U `!     /
                j!     |!     u# !     /,	 !     7       u#       /,       7 "    @ "    dG *"    L 6"    JW B"    U# N"    
#" Z"    	#% f"     ( r"    h( ~"    <L) "     , "    o, "    	t, "     / "    /       @}/       J 2       3       	t4 "     7 $     9 0$     : $     = $     @ $     B <%     DF %     zG %     I %     ^ K "     K %     + K  &    K &    	 N &    N ('     {O d(     Q (     R )     
S *     T "     W .*    W Z*    L	W a*    X	$W i*    X *    X *    X *    X *    wX *    hX *    X +    X +    X /+    X E+     X M+     X U+    +X ]+    	 X e+    7 X p+    /X +     ^ [ +    [        [     '6[     <\     C]      ^     I^     C`        a     Oa        c     Uc     $+d        d     Zd      . e     _e        i     V i     >+j        j      j       k     +k     +k      	 k     ik      ! k     mk     u#o     0
#r     u#u     0
#x     /,{     h~     `W     zG           1L     RL     7     @       x       9       |                            t "      ,     }  "      l,     j  "      |,       "      ,     U                            (            O     M   l               E         x        M    O     M   O        O                 x                           g            )        2      `   2      	   2      2                  (   2               g               B            B            ;                                              (                      8    O    M  O      O    M  O      l            M    E      x      x         ?   F   v   #                        [   c           F      l      o   	      B      &   	      g              p  l     }    }  l 	     
 )  1  9  A  I  Q  Y  a  i  q  y                & , ! q4 4  :    4 4	H Y M T QW ]   il u z t	   K s   9  5   i      	 ! R R           !9$!*1;31z9 .   9M 	 $  ala9M ,  oJ y m^4  a4  a' 
z (  6   G< X		]< ' p  * C H M R W \  a $f (k ,p 0u 4z 8 < @ D H L P T X \ ` d h l p t x |                "	 %	 W	 H	 R	 M	 DC	 HH	 LM	 PW	 Tk	 X'  H.   .  	.  (. # 1. + T. 3 v. ; |. C 1. K . S v. [ v. c . k . s . { 
	.  	A  HI  (i  (  H [ v  ( c 1C [C HC Hi ( H (c  H ( Hc   ( H  H  (c  H ( Hc % ( H  H (c O H	   H# H#c y# (# H) (C HC C (Cc C HI  a 	c Hc (cc c Hi  H (c  H  H 1  
 H t H  H # H# EC HC Hc Hc H H H H H d
 H 
 H# HC Hc  a	 H H H H H` H H H H H _ a c e                  *                        !      "      #      $      %              
       	    
                   !    "    #    $    %     )    *    +    , A c      ?EI].=f                  F    l	          {  l                !	  ;      (    Z  B            6   7   8   9 	  :   ;   <   =   >   ?   @   A   B   C   D   E !  F #  G %  O '  U )  V +  X -  \ /  ] 1  _ 3  a 5  b 7  d 9            "   $   &   (   *   ,   .   	bQ    D  D 9 @ | @  @       t        	                 v         	                    v               v	           ~  " 
 # 
 $  %  &  '  (  )  *  +  q  q         <>c__DisplayClass4_0 <>c__DisplayClass5_0 <>c__DisplayClass6_0 <>c__DisplayClass9_0 <ExtractPdbPath>b__0 <ParseImports>b__0 <ProcessImports>b__0 <FindImport>b__0 _VtblGap1_1 IEnumerable`1 Action`1 ICollection`1 IList`1 e_res1 _VtblGap1_2 Func`2 e_res2 _VtblGap1_4 _VtblGap3_4 _VtblGap2_5 _VtblGap4_67 _VtblGap2_18 get_UTF8 PtrToStringUtf8 <Module> GENERIC_READ FILE_SHARE_READ FILE_MAP_READ get_GUID _FILETIME IMAGE_DOS_SIGNATURE IMAGE_NT_SIGNATURE OPEN_EXISTING tagSTATSTG System.IO IMAGE_DOS_HEADER _ULARGE_INTEGER _LARGE_INTEGER IMAGE_IMPORT_DESCRIPTOR IMAGE_NT_HEADERS SymTagUDT PAGE_READONLY IMAGE_DEBUG_DIRECTORY value__ ImageRvaToVa Microsoft.Dia SizeOfData SymTagData get_ImageDirectoryEntryToData AddressOfRawData PointerToRawData rva cb mscorlib e_magic System.Collections.Generic e_lfarlc e_crlc e_minalloc e_maxalloc get_symIndexId pcbRead Microsoft.Dia.ISequentialStream.RemoteRead bytesRead UnMapAndLoad get_UnMapLoad Add grfLocksSupported reserved riid get_IsInvalid e_oemid clsid Guid <Instance>k__BackingField <Sourcefile>k__BackingField <Line>k__BackingField <TestClassSignature>k__BackingField <Symbol>k__BackingField <IndexOfSerializedTrait>k__BackingField FixedElementField SymTagFuncDebugEnd SymTagCompiland SymTagFriend get_AttemptsToFind found SymTagBaseInterface SymTagUsingNamespace get_Instance TryCreateDiaInstance CreateInstance IDiaDataSource _diaDataSource FileMode dwShareMode grfMode SymTagCallee SymTagInlinee Age LoadedImage loadedImage mappedAsImage image get_GenerateFullPDBMessage Invoke SymTagVTable GetEnvironmentVariable Enumerable IDisposable executable SafeHandle SafeFileHandle RuntimeTypeHandle GetTypeFromHandle FindPdbFile _pdbFile ParsePeFile IDiaSourceFile get_sourceFile CreateFile hTemplateFile MapViewOfFile UnmapViewOfFile get_ParsingFile hFile get_Sourcefile NsfUndecoratedName imageName PdbFileName lpFileName GetFileName get_fileName lpName pwcsName GetDirectoryName get_name dwHighDateTime dwLowDateTime atime ctime mtime get_Line Combine line NsNone Microsoft.Dia.IStream.Clone SymTagVTableShape get_globalScope SymTagHLSLType SymTagManagedType ComInterfaceType SymTagBaseType ValueType SymTagFunctionArgType dwLockType SymTagCustomType SymTagFunctionType comparisonType SymTagPointerType SymTagVectorType SymTagMatrixType SymTagArrayType type FileShare Compare System.Core get_TestClassSignature get_ProcessArchitecture get_Culture set_Culture resourceCulture get_CodeBase pBase Dispose predicate Create EditorBrowsableState SymTagInlineSite SymTagCallSite SymTagHeapAllocationSite Microsoft.Dia.IStream.RemoteWrite Microsoft.Dia.ISequentialStream.RemoteWrite ThreadStaticAttribute DispIdAttribute CompilerGeneratedAttribute GuidAttribute GeneratedCodeAttribute UnverifiableCodeAttribute DebuggerNonUserCodeAttribute SuppressMessageAttribute NeutralResourcesLanguageAttribute DebuggableAttribute EditorBrowsableAttribute ComVisibleAttribute AssemblyTitleAttribute InterfaceTypeAttribute UnsafeValueTypeAttribute AssemblyTrademarkAttribute TargetFrameworkAttribute AssemblyFileVersionAttribute SecurityPermissionAttribute AssemblyConfigurationAttribute AssemblyDescriptionAttribute DefaultMemberAttribute FixedBufferAttribute TypeIdentifierAttribute DefaultDllImportSearchPathsAttribute CompilationRelaxationsAttribute AssemblyProductAttribute AssemblyCopyrightAttribute AssemblyCompanyAttribute RuntimeCompatibilityAttribute ReadByte value NsfCaseSensitive NsfCaseInsensitive dlibMove SymTagExe get_Size cbSize lpFileSize bufferSize Microsoft.Dia.IStream.SetSize libNewSize size SizeOf LastIndexOf SymTagTypedef symTag grfStatFlag seg Encoding System.Runtime.Versioning LogWarning CreateFileMapping UnescapeDataString ToString symbolFilterString GetString Substring pstatstg dwMaximumSizeHigh dwFileOffsetHigh get_Path ExtractPdbPath pdbPath DllImportSearchPath path get_Length SeparatorLength get_length Uri fLock SymTagBlock RemoteSeek SymTagThunk OriginalFirstThunk Marshal SymTagLabel System.ComponentModel DiaDll msdia140.dll Kernel32.dll kernel32.dll dbghelp.dll GoogleTestAdapter.DiaResolver.dll SymTagNull get_Symbol IDiaSymbol SymTagPublicSymbol nativeSymbol symbol loadDataFromIStream pIStream FileStream _fileStream ISequentialStream DiaMemoryStream StubMemoryStream Item System SymTagCustom ppstm SymTagEnum e_csum resourceMan Open findChildren pcbWritten ForwarderChain SeekOrigin seekOrigin dwOrigin Join Microsoft.Dia.IStream.LockRegion Microsoft.Dia.IStream.UnlockRegion SymTagDimension ChangeExtension pathExtension MajorVersion MinorVersion IDiaSession _diaSession openSession ppSession NsfRegularExpression NativeSourceFileLocation ToSourceFileLocation RuntimeInformation SymTagAnnotation System.Globalization SecurityAction action pLastRvaSection AddressSection get_addressSection System.Reflection SymTagFunction plibNewPosition newPosition dwCreationDisposition get_UseLinkerOption NotImplementedException GoogleTestAdapter.Common StringComparison pattern Microsoft.Dia.IStream.RemoteCopyTo PdbInfo CultureInfo DebugInfo e_oeminfo e_ovno Zero dwNumberOfBytesToMap e_cp e_ip e_cblp TimeDateStamp e_sp SymTagCoffGroup System.Linq Char findLinesByAddr e_cparhdr IDiaLineNumber get_lineNumber FileHeader OptionalHeader UriBuilder <e_res1>e__FixedBuffer <e_res2>e__FixedBuffer <FileHeader>e__FixedBuffer <OptionalHeader>e__FixedBuffer buffer get_ResourceManager ILogger _logger System.CodeDom.Compiler SymTagCaller PeParser outer GoogleTestAdapter.DiaResolver IDiaResolver LockServer GetAssemblyBaseDir get_msdiaError get_LoadError get_PdbFileNotFoundError LogError get_LineNumberError Separator IEnumerator GetEnumerator .ctor .cctor UIntPtr ptr e_cs Characteristics System.Diagnostics NativeMethods System.Runtime.InteropServices System.Runtime.CompilerServices System.Resources GoogleTestAdapter.DiaResolver.Resources.resources DebuggingModes Microsoft.Win32.SafeHandles GetSymbolNamesAndAddresses dwFlagsAndAttributes lpFileMappingAttributes lpSecurityAttributes compareFlags grfCommitFlags System.Diagnostics.CodeAnalysis SymTagCompilandDetails diaSymbols IDiaEnumSymbols pathExtensions System.Security.Permissions System.Collections GetFunctions NameSearchOptions IDiaEnumLineNumbers GetLineNumbers pNtHeaders e_ss SymTagBaseClass dwDesiredAccess FileAccess MappedAddress lpBaseAddress grfStateBits ParseImports ProcessImports imports Exists Concat Format Stat hFileMappingObject DllGetClassObject Select flProtect libOffset AddressOffset get_addressOffset offset Is32Bit get_IndexOfSerializedTrait op_Explicit Split Microsoft.Dia.IStream.Commit ppResult Environment get_Current get_count QuadPart SymTagFuncDebugStart Microsoft.Dia.IStream.Revert FindImport currentImport import SymTagExport ToList NsfFNameExt MoveNext System.Text SymTagCompilandEnv pv e_lfanew dwMaximumSizeLow dwFileOffsetLow GetFileSizeEx SymTagMax index FindFunctionsByRegex get_Assembly GetExecutingAssembly Copy _binary LoadLibrary DiaFactory DiaSourceFactory IDiaResolverFactory DefaultDiaResolverFactory IClassFactory directoryEntry op_Equality System.Security IsNullOrEmpty   x 8 6  x 6 4  a r m  a r m 6 4  =U n k n o w n   p l a t f o r m   a r c h i t e c t u r e .  m s d i a 1 4 0 . d l l  Ie 6 7 5 6 1 3 5 - 1 e 6 5 - 4 d 1 7 - 8 5 7 6 - 6 1 0 7 6 1 3 9 8 c 3 c I S t r e a m . C l o n e  I S t r e a m . C o m m i t  %I S t r e a m . L o c k R e g i o n  )I S t r e a m . R e m o t e C o p y T o  9I S e q u e n t i a l S t r e a m . R e m o t e R e a d  ;I S e q u e n t i a l S t r e a m . R e m o t e W r i t e  'I S t r e a m . R e m o t e W r i t e  I S t r e a m . R e v e r t  I S t r e a m . S e t S i z e  )I S t r e a m . U n l o c k R e g i o n  "  	. p d b  	P A T H  ;  : :   OG o o g l e T e s t A d a p t e r . D i a R e s o l v e r . R e s o u r c e s  A t t e m p t s T o F i n d  -G e n e r a t e F u l l P D B M e s s a g e  3I m a g e D i r e c t o r y E n t r y T o D a t a  L i n e N u m b e r E r r o r  L o a d E r r o r  m s d i a E r r o r  P a r s i n g F i l e  )P d b F i l e N o t F o u n d E r r o r  U n M a p L o a d  U s e L i n k e r O p t i o n   QJ@(f\3        A M u   a  a   eee   e       E   

  

(0   
( 
0 88         !%)-X	@L55  
@L 5 
L 9  
 5@h}@  TL\}T      	,  		       		$4 z\V4?_
: $          $  RSA1     W.jvlL;6!r<wwO)2!d\L(]b,e,=t]o-~^=&Ce m4MZm s d i a 1 4 0 . d l l                             	   
                                                                      !   "   #   $   %   &   '   (   )   *   +   MZPE   .System.Security.Permissions.SecurityPermissionAttribute, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089TSkipVerification+,  System.Runtime.InteropServices.CustomMarshalers.EnumeratorToEnumVariantMarshaler, CustomMarshalers, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a i 	q`Pt
xe    P     	 ee i 		
 |	 	 p 	
 	 p     q e
 L 8 8 q8 q q q  8	 q q  @X L@ X T			       	 	 p `   \	 h	  d  h	 			T  
 t	X 				 			 

 			 	 	 	 8      ( ( 	(   d 	 h         TWrapNonExceptionThrows      " GoogleTestAdapter.DiaResolver  ! Encapsulation of the Dia DLL      ' "Christian Soltenborn, Jonas Gefele  " Copyright  2015, 2016, 2017  ) $fdc95d92-5e1e-4bdf-aa35-181851fce755   0.17.0.9  
 en-US        M .NETFramework,Version=v4.7.2 TFrameworkDisplayName.NET Framework 4.7.2: Microsoft.PerformanceCA1811:AvoidUncalledPrivateCode  c ZSystem.UInt16, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089     c ZSystem.UInt16, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
     a XSystem.Byte, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089     a XSystem.Byte, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089           ) $00000001-0000-0000-C000-000000000046  A 3System.Resources.Tools.StronglyTypedResourceBuilder15.0.0.0  ) $79F1BB5F-B66E-48E5-B6A9-1545C323CA3D  ) $FE30E878-54AC-44F1-81BA-39DE940F6052  	 Item  ) $CAB72C48-443B-48F5-9B0B-42F0820AB29A  ) $B388EB14-BE4D-421D-A8A1-6CF7AB057086  ) $2F609EE1-D1C8-4E24-8288-3326BADCD211  ) $A2EF5353-F5A8-4EB3-90D2-CB526ACB3CDD   
symIndexId  ) $CB787B2F-BD6C-4635-BA52-933126BD2DCD  ) $0C733A30-2A1C-11CE-ADE5-00AA0044773D  ) $0000000C-0000-0000-C000-000000000046  B $106173A0-0173-4E5C-84E7-E915422BE997Microsoft.Dia.SymTagEnum  A $106173A0-0173-4E5C-84E7-E915422BE997Microsoft.Dia._FILETIME  F $106173A0-0173-4E5C-84E7-E915422BE997Microsoft.Dia._LARGE_INTEGER  G $106173A0-0173-4E5C-84E7-E915422BE997Microsoft.Dia._ULARGE_INTEGER  B $106173A0-0173-4E5C-84E7-E915422BE997Microsoft.Dia.tagSTATSTG  ! 	ReSharperUnusedMember.Local                	                     lSystem.Resources.ResourceReader, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089#System.Resources.RuntimeResourceSet   
       PADPADP*K{\dSPzeT5      "  R      E           !   b  A t t e m p t s T o F i n d     ,G e n e r a t e F u l l P D B M e s s a g e    2I m a g e D i r e c t o r y E n t r y T o D a t a    L i n e N u m b e r E r r o r    L o a d E r r o r    P a r s i n g F i l e    (P d b F i l e N o t F o u n d E r r o r    U n M a p L o a d a  U s e L i n k e r O p t i o n w  m s d i a E r r o r   Attempts to find PDB: {0}qIn order to get source locations for your tests, please ensure to generate *full* PDBs for your test executables.!ImageDirectoryEntryToData failed!$Failed to locate line number for {0}Cannot load {0}.Parsing PDB file {0}`Couldn't find the .pdb file of file '{0}'. You will not get any source locations for your tests.UnMapAndLoad failed!yUse linker option /DEBUG:FULL (Visual Studio 2017) or /DEBUG (Visual Studio 2015 and older) - do not use /DEBUG:FASTLINK!gCouldn't find the msdia.dll to parse *.pdb files. You will not get any source locations for your tests.       sACSD.ZT#ZAwCL[.[8@^(77UD&fFvv)xKzTBc/bmD@yl%[~unvs    b           a  RSDS&i@4?   D:\a\_work\1\s\out\intermediate\GoogleTestAdapter\Release\DiaResolver\GoogleTestAdapter.DiaResolver.pdb                                                                                                                                                                                                             _CorDllMain mscoree.dll     %                                                                                                                                                                                                                                                                                                     0                     H   X  Z          Z4   V S _ V E R S I O N _ I N F O           	      	   ?                         D    V a r F i l e I n f o     $    T r a n s l a t i o n          S t r i n g F i l e I n f o      0 0 0 0 0 4 b 0   R   C o m m e n t s   E n c a p s u l a t i o n   o f   t h e   D i a   D L L     f #  C o m p a n y N a m e     C h r i s t i a n   S o l t e n b o r n ,   J o n a s   G e f e l e     d   F i l e D e s c r i p t i o n     G o o g l e T e s t A d a p t e r . D i a R e s o l v e r   2 	  F i l e V e r s i o n     0 . 1 7 . 0 . 9     d "  I n t e r n a l N a m e   G o o g l e T e s t A d a p t e r . D i a R e s o l v e r . d l l   ^   L e g a l C o p y r i g h t   C o p y r i g h t      2 0 1 5 ,   2 0 1 6 ,   2 0 1 7     *   L e g a l T r a d e m a r k s         l "  O r i g i n a l F i l e n a m e   G o o g l e T e s t A d a p t e r . D i a R e s o l v e r . d l l   \   P r o d u c t N a m e     G o o g l e T e s t A d a p t e r . D i a R e s o l v e r   6 	  P r o d u c t V e r s i o n   0 . 1 7 . 0 . 9     : 	  A s s e m b l y   V e r s i o n   0 . 1 7 . 0 . 9                                                                                                                                                                                                                                                                                                                                                        1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      '    0'	*H'u0'q10	`He 0\
+7N0L0
+70	  010	`He  +qFt#Hh`]i0c|q\L003  R39    R0	*H 0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110210902183259Z220901183259Z0t10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Corporation0"0	*H  0
 #4BWq%:/LJ'_5@-qM ACPb"{6B5}oN/Esl4/N]/J|D]
y\lYz2S
n `Du$ThFrGh)33N0ml8{c!SP>r?~g+G|t|@IA*~NWM ~0z0U%0
+7L+0U5ZAkN|Fy0PUI0GE0C1)0'U Microsoft Operations Puerto Rico10U230012+4675970U#0HndP77"mu0TUM0K0IGEChttp://www.microsoft.com/pkiops/crl/MicCodSigPCA2011_2011-07-08.crl0a+U0S0Q+0Ehttp://www.microsoft.com/pkiops/certs/MicCodSigPCA2011_2011-07-08.crt0U0 0	*H  I7,dL@a@b,g`_ZGY1)R-tL]AG)\_K	CGK#=WcoNdS34;IS8EOh:zQ40Y v/.L*o1cJg>wQ)\]L "jyD18/&.v[KX&bnwv&=bjujAZAz8`+3Y3u4kfeu8kY(*1+8^T\INKBG7q#j3~^2
[ >MX[%$23+=F%R2av/U:kzc'tE9!dvP[l]rMw286O."y<I2i0z0b
a     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20110110708205909Z260708210909Z0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20110"0	*H  0
 r.nM4X!B*kZP8I7k891Byd~`$lIh^S
,+z	Y`fv2R&/PD].uhm:\F8dnd5xc-@\yI)w=+ZMV(zr:I^C{{>]O/Y;-3X>2=8~,NV!5%9ndS#_R!t%_('(8%9J6|#faj(I_%]!K>RW?$z[/#p]QFw _UK9#ID|Erzr$FWMI0[f{KI)(}gbx_/W\w((m(,@7OD	LC/tnx X,]`>O3NFl 00	+7 0UHndP77"mu0	+7
 S u b C A0U0U00U#0r-:1CN1#40ZUS0Q0OMKIhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut2011_2011_03_22.crl0^+R0P0N+0Bhttp://www.microsoft.com/pki/certs/MicRooCerAut2011_2011_03_22.crt0U 00	+7.00?+3http://www.microsoft.com/pkiops/docs/primarycps.htm0@+042  L e g a l _ p o l i c y _ s t a t e m e n t . 0	*H  gTy.tg"cB}ye_.,>rm?
;Gic"5]e}FPU|K<BRk>.)=w9dD=xz#}t&F*hh.*?*kXIc	inZF+;5n%'(M=2-[I9

QEX82q'',: iYhnot@*(>?MfMo}Ev@*e]Rbc6']cA[>wuaaA(e/\ FY	KH )?Ew5zz"HG#kKux7yK#hui;0Lumc=VNOW"x2!zA
?]WqVNHEBv[
HkymmjRszP1v0r00~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20113  R39    R0	`He 0	*H	1
+70
+710
+70/	*H	1" Rwe;jn.@Q0B
+71402 M i c r o s o f thttp://www.microsoft.com0	*H  5t{(IlsZ~7 ]g=8]~ro8T;>eOZ9q
]Uo7OOg:36J60/ZRy9:Q*?"- :$O5Tzzmxa,.wn,+T{jIP7FA@XBx]gz.x+VcRB6F>' 0
+710	*H010	`He 0Q*H	@<08
+Y
010	`He  ^!:|"0f[6>V_xX`7 bPC:20220630205912.319Z0010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:E5A6-E27C-592E1%0#UMicrosoft Time-Stamp ServiceW003  71%   0	*H 0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100211202190512Z230228190512Z010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:E5A6-E27C-592E1%0#UMicrosoft Time-Stamp Service0"0	*H  0
 mAgK;?Z$!?PABvbpij;<5pX>_>mZ./2FA/$JzU)XfpGdrXNLu5@6o4
9p;d#r}QDpS`8gJnX /~o\3	u
n;&X~_0e> 5Ni^Fs:}VCWs2\co#KT=!\{mO<}0[_Xe _1C ep~,e 6d$}kh}kt+|:]"#%q'NGE~fGmK0bT~m"R&+ph"qJSaCMHyzWPW"?Up:cYFo'4Gkb 6020UbWW`|~o0U#0] ^b]eS5r0_UX0V0TRPNhttp://www.microsoft.com/pkiops/crl/Microsoft%20Time-Stamp%20PCA%202010(1).crl0l+`0^0\+0Phttp://www.microsoft.com/pkiops/certs/Microsoft%20Time-Stamp%20PCA%202010(1).crt0U0 0U%0
+0	*H  6'gA  	D#niy[g/mW~GHV=nX"%'@+^'3d^z[9tJ-Am,jp(p)(sE9l7<|vJs"&e_FdFODr@jMd#95+![vV&e7dA,=t/%5bhHUnCrK	Hw(0WiWF0p,kdvA;c}u;(oKS.rqJIZ4>iac(`P o1-)}^oO~>`,KRAs&B\uX^`LV]pANy(tv^Wq6\0q0Y3   kI     0	*H 010	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100210930182225Z300930183225Z0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100"0	*H  0
 Lr!y$ylNu5WlJ>`3\OfSqZ~JZ6gF#w2`}jRDFkvPDq\Q17
8n&S|9azri65&d;{3[~Rb%j]SVM9,Qpi6-p15($~TUmh;Fz)7EFn20\O,bJq[g`= s}AFu_4 }~Er/}_~66L+nQsM7t4G|?L^s=CN39LBh.QFjZasg^(v3r 
co6d[!]_0tPa65Gk\RQ]%PzlrR<7?xE^ri{>j. 00	+7 0#	+7*Rd<F5)/0U] ^b]eS5r0\U U0S0Q+7L}0A0?+3http://www.microsoft.com/pkiops/Docs/Repository.htm0U%0
+0	+7
 S u b C A0U0U00U#0V\bh=[0VUO0M0KIGEhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*H  U}*,g1$[rKo\>NGdx=139q6?dl|u9m1l"fg:SMx6.V i	{jo)n?Humm#TxSu$W=heV(U'$@]='@8)TBjBRu6as.,k{n?,	x[It=J>f;O2tLrou04zP
X@<TmctH,NG-qd$sm	WITds[DZk(g($8Kn!TkjEG^OLvWT	iD~|als
Af=iAI~~;>1Q{p(6L
4$5g+"'B=%tt[j>~13}{8pD::bpcSMmqjU3Xpf070010	UUS10U
Washington10URedmond10U
Microsoft Corporation1%0#UMicrosoft America Operations1&0$UThales TSS ESN:E5A6-E27C-592E1%0#UMicrosoft Time-Stamp Service#
0+ GXSf(KOc0~0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100	*H  hX0"20220701011236Z20220702011236Z0w0=
+Y
1/0-0
 hX 0
 +,0 0
 i 06
+Y
1(0&0
+Y

0  
0 0	*H  OYnt<K;	M@TIVx%;1`zI37#Gs(vTsj;QBY;n],`	z(;jGWV.}{[10	00|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20103  71%   0	`He J0	*H	1*H	0/	*H	1" _{ZKs]e{	JO|hUJL0*H	/1000 \K{i#?wTw2O,I00~0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20103  71%   0" j7t*
X-f'0	*H  y|Mm:ng7A7Y@]o&
HE?w)Gpr4oao?y.;?93*;bhT,tIkc?Y/ux+smHpx5/itL	&Iq/fQYv0=##O};rryrI{^F<Y_uS	j2Zp4KY@BXDR`j6f
3u09BzER)zO8m5`wnzN0OLqjreXVp)57 _J[} ]oqm3y;mcM%0y!!l dfR	 Vzjfo]}q5f
+=(l3@5M+{W~9i:C>Co1#('K[/^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
# file Copyright.txt or https://cmake.org/licensing for details.

#[=======================================================================[.rst:
FindBullet
----------

Try to find the Bullet physics engine



::

  This module defines the following variables



::

  BULLET_FOUND - Was bullet found
  BULLET_INCLUDE_DIRS - the Bullet include directories
  BULLET_LIBRARIES - Link to this, by default it includes
                     all bullet components (Dynamics,
                     Collision, LinearMath, & SoftBody)



::

  This module accepts the following variables



::

  BULLET_ROOT - Can be set to bullet install path or Windows build path
#]=======================================================================]

macro(_FIND_BULLET_LIBRARY _var)
  find_library(${_var}
     NAMES
        ${ARGN}
     HINTS
        ${BULLET_ROOT}
        ${BULLET_ROOT}/lib/Release
        ${BULLET_ROOT}/lib/Debug
        ${BULLET_ROOT}/out/release8/libs
        ${BULLET_ROOT}/out/debug8/libs
     PATH_SUFFIXES lib
  )
  mark_as_advanced(${_var})
endmacro()

macro(_BULLET_APPEND_LIBRARIES _list _release)
  set(_debug ${_release}_DEBUG)
  if(${_debug})
    set(${_list} ${${_list}} optimized ${${_release}} debug ${${_debug}})
  else()
    set(${_list} ${${_list}} ${${_release}})
  endif()
endmacro()

find_path(BULLET_INCLUDE_DIR NAMES btBulletCollisionCommon.h
  HINTS
    ${BULLET_ROOT}/include
    ${BULLET_ROOT}/src
  PATH_SUFFIXES bullet
)

# Find the libraries

_FIND_BULLET_LIBRARY(BULLET_DYNAMICS_LIBRARY        BulletDynamics)
_FIND_BULLET_LIBRARY(BULLET_DYNAMICS_LIBRARY_DEBUG  BulletDynamics_Debug BulletDynamics_d)
_FIND_BULLET_LIBRARY(BULLET_COLLISION_LIBRARY       BulletCollision)
_FIND_BULLET_LIBRARY(BULLET_COLLISION_LIBRARY_DEBUG BulletCollision_Debug BulletCollision_d)
_FIND_BULLET_LIBRARY(BULLET_MATH_LIBRARY            BulletMath LinearMath)
_FIND_BULLET_LIBRARY(BULLET_MATH_LIBRARY_DEBUG      BulletMath_Debug BulletMath_d LinearMath_Debug LinearMath_d)
_FIND_BULLET_LIBRARY(BULLET_SOFTBODY_LIBRARY        B